'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

var _objectWithoutPropertiesLoose = _interopDefault(require('@babel/runtime/helpers/objectWithoutPropertiesLoose'));
var core = require('@react-spring/core/index.cjs.js');
var stringInterpolation = require('@react-spring/shared/stringInterpolation');
var _inheritsLoose = _interopDefault(require('@babel/runtime/helpers/inheritsLoose'));
var shared = require('@react-spring/shared');
var animated$1 = require('@react-spring/animated/index.cjs.js');
var colorNames = _interopDefault(require('@react-spring/shared/colors'));

var isUnitlessNumber = {
  animationIterationCount: true,
  borderImageOutset: true,
  borderImageSlice: true,
  borderImageWidth: true,
  boxFlex: true,
  boxFlexGroup: true,
  boxOrdinalGroup: true,
  columnCount: true,
  columns: true,
  flex: true,
  flexGrow: true,
  flexPositive: true,
  flexShrink: true,
  flexNegative: true,
  flexOrder: true,
  gridRow: true,
  gridRowEnd: true,
  gridRowSpan: true,
  gridRowStart: true,
  gridColumn: true,
  gridColumnEnd: true,
  gridColumnSpan: true,
  gridColumnStart: true,
  fontWeight: true,
  lineClamp: true,
  lineHeight: true,
  opacity: true,
  order: true,
  orphans: true,
  tabSize: true,
  widows: true,
  zIndex: true,
  zoom: true,
  // SVG-related properties
  fillOpacity: true,
  floodOpacity: true,
  stopOpacity: true,
  strokeDasharray: true,
  strokeDashoffset: true,
  strokeMiterlimit: true,
  strokeOpacity: true,
  strokeWidth: true
};

var prefixKey = function prefixKey(prefix, key) {
  return prefix + key.charAt(0).toUpperCase() + key.substring(1);
};

var prefixes = ['Webkit', 'Ms', 'Moz', 'O'];
isUnitlessNumber = Object.keys(isUnitlessNumber).reduce(function (acc, prop) {
  prefixes.forEach(function (prefix) {
    return acc[prefixKey(prefix, prop)] = acc[prop];
  });
  return acc;
}, isUnitlessNumber);

function dangerousStyleValue(name, value, isCustomProperty) {
  if (value == null || typeof value === 'boolean' || value === '') return '';
  if (!isCustomProperty && typeof value === 'number' && value !== 0 && !(isUnitlessNumber.hasOwnProperty(name) && isUnitlessNumber[name])) return value + 'px'; // Presumes implicit 'px' suffix for unitless numbers

  return ('' + value).trim();
}

var attributeCache = {};
function applyAnimatedValues(instance, props) {
  if (!instance.nodeType || !instance.setAttribute) {
    return false;
  }

  var style = props.style,
      children = props.children,
      scrollTop = props.scrollTop,
      scrollLeft = props.scrollLeft,
      attributes = _objectWithoutPropertiesLoose(props, ["style", "children", "scrollTop", "scrollLeft"]);

  if (scrollTop !== void 0) instance.scrollTop = scrollTop;
  if (scrollLeft !== void 0) instance.scrollLeft = scrollLeft; // Set textContent, if children is an animatable value

  if (children !== void 0) instance.textContent = children; // Apply CSS styles

  for (var styleName in style) {
    if (!style.hasOwnProperty(styleName)) continue;
    var isCustomProperty = styleName.indexOf('--') === 0;
    var styleValue = dangerousStyleValue(styleName, style[styleName], isCustomProperty);
    if (styleName === 'float') styleName = 'cssFloat';
    if (isCustomProperty) instance.style.setProperty(styleName, styleValue);else instance.style[styleName] = styleValue;
  }

  var isFilterElement = instance.nodeName === 'filter' || instance.parentNode && instance.parentNode.nodeName === 'filter'; // Apply DOM attributes

  for (var name in attributes) {
    // Attributes are written in dash case
    var attributeName = isFilterElement || instance.hasAttribute(name) ? name : attributeCache[name] || (attributeCache[name] = name.replace(/([A-Z])/g, function (n) {
      return '-' + n.toLowerCase();
    }));
    instance.setAttribute(attributeName, attributes[name]);
  }
}

/** The transform-functions
 * (https://developer.mozilla.org/fr/docs/Web/CSS/transform-function)
 * that you can pass as keys to your animated component style and that will be
 * animated. Perspective has been left out as it would conflict with the
 * non-transform perspective style.
 */

var domTransforms = ['matrix', 'translate', 'scale', 'rotate', 'skew']; // x, y, z and translate will get 'px' as unit default

var pxDefaults = ['x', 'y', 'z', 'translate']; // rotate and skew will get 'deg' as unit default

var dgDefaults = ['rotate', 'skew']; // adds a unit to the value when the value is unit-less (ie a number)

var mergeUnit = function mergeUnit(value, unit) {
  return shared.is.num(value) && value !== 0 ? value + unit : value;
}; // gets the default unit for a key


var getUnit = function getUnit(key) {
  return pxDefaults.some(function (name) {
    return key.startsWith(name);
  }) ? 'px' : dgDefaults.some(function (name) {
    return key.startsWith(name);
  }) ? 'deg' : '';
};
/**
 * Returns the right Animated object based on the value type.
 *
 * x: AnimatedValue         --> x
 * 40px                     --> AnimatedValue(40px)
 * [40, 30]                 --> AnimatedValue([40,30])
 * [40, y: AnimatedValue]   --> AnimatedArray([AnimatedValue(40), y])
 *
 * @param value
 */


var ensureAnimated = function ensureAnimated(value) {
  if (value === void 0) {
    value = 0;
  }

  return shared.is.arr(value) && value.some(animated$1.isAnimated) ? new animated$1.AnimatedArray(value.map(ensureAnimated)) : animated$1.isAnimated(value) ? value : new animated$1.AnimatedValue(value);
};
/**
 * Checks if the input value matches the identity value.
 *
 * isValueIdentity(0, 0)              --> true
 * isValueIdentity('0px', 0)          --> true
 * isValueIdentity([0, '0px', 0], 0)  --> true
 *
 * @param styleValue
 * @param id
 */


var isValueIdentity = function isValueIdentity(styleValue, id) {
  return shared.is.arr(styleValue) ? styleValue.every(function (v) {
    return isValueIdentity(v, id);
  }) : shared.is.num(styleValue) ? styleValue === id : parseFloat(styleValue) === id;
};
/**
 * Checks if the style value is the identity for a given key.
 *
 * isTransformIdentity('scale', 1)               --> true
 * isTransformIdentity('scale', [1,1])
 * isTransformIdentity('rotate3d', [1,1,1,0])    --> true
 * isTransformIdentity('x', 0)                   --> true
 *
 * @param key
 * @param styleValue
 */


var isTransformIdentity = function isTransformIdentity(key, styleValue) {
  return key === 'rotate3d' ? isValueIdentity(shared.is.arr(styleValue) ? styleValue[3] : styleValue, 0) : key.startsWith('scale') ? isValueIdentity(styleValue, 1) : isValueIdentity(styleValue, 0);
};
/**
 * This AnimatedStyle will simplify animated components transforms by
 * interpolating all transform function passed as keys in the style object
 * including shortcuts such as x, y and z for translateX/Y/Z
 */


var AnimatedStyle =
/*#__PURE__*/
function (_AnimatedObject) {
  _inheritsLoose(AnimatedStyle, _AnimatedObject);

  function AnimatedStyle(_ref) {
    if (_ref === void 0) {
      _ref = {};
    }

    var _ref2 = _ref,
        x = _ref2.x,
        y = _ref2.y,
        z = _ref2.z,
        style = _objectWithoutPropertiesLoose(_ref2, ["x", "y", "z"]);

    var props = []; // transforms will be an array of functions applied to the props. Each function
    // will return the interpolated transformed string, and a flag indicating if the
    // interpolation result is an identity transform of its own

    var transforms = []; // first we deal with x, y, z to group them into a single translate3d

    if (x || y || z) {
      // xyz should be an AnimatedValue or AnimatedArray
      var xyz = ensureAnimated([x || 0, y || 0, z || 0]); // we add it to the array of Animated objects that will be interpolated

      props.push(xyz); // we add the interpolation function to our transform array

      transforms.push(function (_ref3) {
        var vx = _ref3[0],
            vy = _ref3[1],
            vz = _ref3[2];
        return ["translate3d(" + mergeUnit(vx, getUnit('x')) + "," + mergeUnit(vy, getUnit('y')) + "," + mergeUnit(vz, getUnit('z')) + ")", isValueIdentity([vx, vy, vz], 0)];
      });
    } // then for each style key that matches the supported transform functions,
    // we add the input value to the props and the interpolation transform
    // function


    shared.each(style, function (value, key) {
      if (key === 'transform') {
        props.push(ensureAnimated(value));
        transforms.push(function (transform) {
          return [transform, transform === ''];
        });
      } else if (domTransforms.some(function (transform) {
        return key.startsWith(transform);
      })) {
        var unit = getUnit(key);
        props.push(ensureAnimated(value));
        transforms.push(key === 'rotate3d' ? function (_ref4) {
          var x = _ref4[0],
              y = _ref4[1],
              z = _ref4[2],
              deg = _ref4[3];
          return ["rotate3d(" + x + "," + y + "," + z + "," + mergeUnit(deg, unit) + ")", isTransformIdentity(key, deg)];
        } : function (arg) {
          return [shared.is.arr(arg) ? key + "(" + arg.map(function (v) {
            return mergeUnit(v, unit);
          }).join(',') + ")" : key + "(" + mergeUnit(arg, unit) + ")", isTransformIdentity(key, arg)];
        });
        delete style[key];
      }
    }); // finally, we set the transform key of the animated style to the
    // interpolation of all the props, using the transform functions we defined
    // above

    if (props.length > 0) {
      style.transform = animated$1.to(props, function () {
        var transform = '';
        var identity = true;

        for (var i = 0; i < arguments.length; i++) {
          var _transforms$i = transforms[i](i < 0 || arguments.length <= i ? undefined : arguments[i]),
              t = _transforms$i[0],
              id = _transforms$i[1];

          transform += ' ' + t;
          identity = identity && id;
        } // if the identity flag was true for all transforms, we set the transform
        // to none, otherwise we return the concatenated transform string


        return identity ? 'none' : transform;
      });
    }

    return _AnimatedObject.call(this, style) || this;
  }

  return AnimatedStyle;
}(animated$1.AnimatedObject);

var elements = ['a', 'abbr', 'address', 'area', 'article', 'aside', 'audio', 'b', 'base', 'bdi', 'bdo', 'big', 'blockquote', 'body', 'br', 'button', 'canvas', 'caption', 'cite', 'code', 'col', 'colgroup', 'data', 'datalist', 'dd', 'del', 'details', 'dfn', 'dialog', 'div', 'dl', 'dt', 'em', 'embed', 'fieldset', 'figcaption', 'figure', 'footer', 'form', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'head', 'header', 'hgroup', 'hr', 'html', 'i', 'iframe', 'img', 'input', 'ins', 'kbd', 'keygen', 'label', 'legend', 'li', 'link', 'main', 'map', 'mark', 'menu', 'menuitem', 'meta', 'meter', 'nav', 'noscript', 'object', 'ol', 'optgroup', 'option', 'output', 'p', 'param', 'picture', 'pre', 'progress', 'q', 'rp', 'rt', 'ruby', 's', 'samp', 'script', 'section', 'select', 'small', 'source', 'span', 'strong', 'style', 'sub', 'summary', 'sup', 'table', 'tbody', 'td', 'textarea', 'tfoot', 'th', 'thead', 'time', 'title', 'tr', 'track', 'u', 'ul', 'var', 'video', 'wbr', // SVG
'circle', 'clipPath', 'defs', 'ellipse', 'foreignObject', 'g', 'image', 'line', 'linearGradient', 'mask', 'path', 'pattern', 'polygon', 'polyline', 'radialGradient', 'rect', 'stop', 'svg', 'text', 'tspan'];

var animated = animated$1.extendAnimated(animated$1.withAnimated, elements);

core.Globals.assign({
  defaultElement: 'div',
  colorNames: colorNames,
  applyAnimatedValues: applyAnimatedValues,
  createStringInterpolator: stringInterpolation.createStringInterpolator,
  createAnimatedStyle: function createAnimatedStyle(style) {
    return new AnimatedStyle(style);
  },
  getComponentProps: function getComponentProps(_ref) {
    var scrollTop = _ref.scrollTop,
        scrollLeft = _ref.scrollLeft,
        props = _objectWithoutPropertiesLoose(_ref, ["scrollTop", "scrollLeft"]);

    return props;
  }
});

Object.keys(core).forEach(function (k) {
  if (k !== 'default') Object.defineProperty(exports, k, {
    enumerable: true,
    get: function () {
      return core[k];
    }
  });
});
exports.a = animated;
exports.animated = animated;
//# sourceMappingURL=index.cjs.js.map
