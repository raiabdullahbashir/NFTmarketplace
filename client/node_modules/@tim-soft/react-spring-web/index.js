import _objectWithoutPropertiesLoose from '@babel/runtime/helpers/esm/objectWithoutPropertiesLoose';
import { Globals } from '@react-spring/core';
export * from '@react-spring/core';
import { createStringInterpolator } from '@react-spring/shared/stringInterpolation';
import { is, each } from '@react-spring/shared';
import { AnimatedObject, isAnimated, AnimatedArray, AnimatedValue, to, extendAnimated, withAnimated } from '@react-spring/animated';
import colorNames from '@react-spring/shared/colors';

let isUnitlessNumber = {
  animationIterationCount: true,
  borderImageOutset: true,
  borderImageSlice: true,
  borderImageWidth: true,
  boxFlex: true,
  boxFlexGroup: true,
  boxOrdinalGroup: true,
  columnCount: true,
  columns: true,
  flex: true,
  flexGrow: true,
  flexPositive: true,
  flexShrink: true,
  flexNegative: true,
  flexOrder: true,
  gridRow: true,
  gridRowEnd: true,
  gridRowSpan: true,
  gridRowStart: true,
  gridColumn: true,
  gridColumnEnd: true,
  gridColumnSpan: true,
  gridColumnStart: true,
  fontWeight: true,
  lineClamp: true,
  lineHeight: true,
  opacity: true,
  order: true,
  orphans: true,
  tabSize: true,
  widows: true,
  zIndex: true,
  zoom: true,
  // SVG-related properties
  fillOpacity: true,
  floodOpacity: true,
  stopOpacity: true,
  strokeDasharray: true,
  strokeDashoffset: true,
  strokeMiterlimit: true,
  strokeOpacity: true,
  strokeWidth: true
};

const prefixKey = (prefix, key) => prefix + key.charAt(0).toUpperCase() + key.substring(1);

const prefixes = ['Webkit', 'Ms', 'Moz', 'O'];
isUnitlessNumber = Object.keys(isUnitlessNumber).reduce((acc, prop) => {
  prefixes.forEach(prefix => acc[prefixKey(prefix, prop)] = acc[prop]);
  return acc;
}, isUnitlessNumber);

function dangerousStyleValue(name, value, isCustomProperty) {
  if (value == null || typeof value === 'boolean' || value === '') return '';
  if (!isCustomProperty && typeof value === 'number' && value !== 0 && !(isUnitlessNumber.hasOwnProperty(name) && isUnitlessNumber[name])) return value + 'px'; // Presumes implicit 'px' suffix for unitless numbers

  return ('' + value).trim();
}

const attributeCache = {};
function applyAnimatedValues(instance, props) {
  if (!instance.nodeType || !instance.setAttribute) {
    return false;
  }

  const style = props.style,
        children = props.children,
        scrollTop = props.scrollTop,
        scrollLeft = props.scrollLeft,
        attributes = _objectWithoutPropertiesLoose(props, ["style", "children", "scrollTop", "scrollLeft"]);

  if (scrollTop !== void 0) instance.scrollTop = scrollTop;
  if (scrollLeft !== void 0) instance.scrollLeft = scrollLeft; // Set textContent, if children is an animatable value

  if (children !== void 0) instance.textContent = children; // Apply CSS styles

  for (let styleName in style) {
    if (!style.hasOwnProperty(styleName)) continue;
    var isCustomProperty = styleName.indexOf('--') === 0;
    var styleValue = dangerousStyleValue(styleName, style[styleName], isCustomProperty);
    if (styleName === 'float') styleName = 'cssFloat';
    if (isCustomProperty) instance.style.setProperty(styleName, styleValue);else instance.style[styleName] = styleValue;
  }

  const isFilterElement = instance.nodeName === 'filter' || instance.parentNode && instance.parentNode.nodeName === 'filter'; // Apply DOM attributes

  for (let name in attributes) {
    // Attributes are written in dash case
    const attributeName = isFilterElement || instance.hasAttribute(name) ? name : attributeCache[name] || (attributeCache[name] = name.replace(/([A-Z])/g, n => '-' + n.toLowerCase()));
    instance.setAttribute(attributeName, attributes[name]);
  }
}

/** The transform-functions
 * (https://developer.mozilla.org/fr/docs/Web/CSS/transform-function)
 * that you can pass as keys to your animated component style and that will be
 * animated. Perspective has been left out as it would conflict with the
 * non-transform perspective style.
 */

const domTransforms = ['matrix', 'translate', 'scale', 'rotate', 'skew']; // x, y, z and translate will get 'px' as unit default

const pxDefaults = ['x', 'y', 'z', 'translate']; // rotate and skew will get 'deg' as unit default

const dgDefaults = ['rotate', 'skew']; // adds a unit to the value when the value is unit-less (ie a number)

const mergeUnit = (value, unit) => is.num(value) && value !== 0 ? value + unit : value; // gets the default unit for a key


const getUnit = key => pxDefaults.some(name => key.startsWith(name)) ? 'px' : dgDefaults.some(name => key.startsWith(name)) ? 'deg' : '';
/**
 * Returns the right Animated object based on the value type.
 *
 * x: AnimatedValue         --> x
 * 40px                     --> AnimatedValue(40px)
 * [40, 30]                 --> AnimatedValue([40,30])
 * [40, y: AnimatedValue]   --> AnimatedArray([AnimatedValue(40), y])
 *
 * @param value
 */


const ensureAnimated = function ensureAnimated(value) {
  if (value === void 0) {
    value = 0;
  }

  return is.arr(value) && value.some(isAnimated) ? new AnimatedArray(value.map(ensureAnimated)) : isAnimated(value) ? value : new AnimatedValue(value);
};
/**
 * Checks if the input value matches the identity value.
 *
 * isValueIdentity(0, 0)              --> true
 * isValueIdentity('0px', 0)          --> true
 * isValueIdentity([0, '0px', 0], 0)  --> true
 *
 * @param styleValue
 * @param id
 */


const isValueIdentity = (styleValue, id) => is.arr(styleValue) ? styleValue.every(v => isValueIdentity(v, id)) : is.num(styleValue) ? styleValue === id : parseFloat(styleValue) === id;
/**
 * Checks if the style value is the identity for a given key.
 *
 * isTransformIdentity('scale', 1)               --> true
 * isTransformIdentity('scale', [1,1])
 * isTransformIdentity('rotate3d', [1,1,1,0])    --> true
 * isTransformIdentity('x', 0)                   --> true
 *
 * @param key
 * @param styleValue
 */


const isTransformIdentity = (key, styleValue) => key === 'rotate3d' ? isValueIdentity(is.arr(styleValue) ? styleValue[3] : styleValue, 0) : key.startsWith('scale') ? isValueIdentity(styleValue, 1) : isValueIdentity(styleValue, 0);
/**
 * This AnimatedStyle will simplify animated components transforms by
 * interpolating all transform function passed as keys in the style object
 * including shortcuts such as x, y and z for translateX/Y/Z
 */


class AnimatedStyle extends AnimatedObject {
  constructor(_ref) {
    if (_ref === void 0) {
      _ref = {};
    }

    let _ref2 = _ref,
        x = _ref2.x,
        y = _ref2.y,
        z = _ref2.z,
        style = _objectWithoutPropertiesLoose(_ref2, ["x", "y", "z"]);

    const props = []; // transforms will be an array of functions applied to the props. Each function
    // will return the interpolated transformed string, and a flag indicating if the
    // interpolation result is an identity transform of its own

    const transforms = []; // first we deal with x, y, z to group them into a single translate3d

    if (x || y || z) {
      // xyz should be an AnimatedValue or AnimatedArray
      const xyz = ensureAnimated([x || 0, y || 0, z || 0]); // we add it to the array of Animated objects that will be interpolated

      props.push(xyz); // we add the interpolation function to our transform array

      transforms.push((_ref3) => {
        let vx = _ref3[0],
            vy = _ref3[1],
            vz = _ref3[2];
        return [`translate3d(${mergeUnit(vx, getUnit('x'))},${mergeUnit(vy, getUnit('y'))},${mergeUnit(vz, getUnit('z'))})`, isValueIdentity([vx, vy, vz], 0)];
      });
    } // then for each style key that matches the supported transform functions,
    // we add the input value to the props and the interpolation transform
    // function


    each(style, (value, key) => {
      if (key === 'transform') {
        props.push(ensureAnimated(value));
        transforms.push(transform => [transform, transform === '']);
      } else if (domTransforms.some(transform => key.startsWith(transform))) {
        const unit = getUnit(key);
        props.push(ensureAnimated(value));
        transforms.push(key === 'rotate3d' ? (_ref4) => {
          let x = _ref4[0],
              y = _ref4[1],
              z = _ref4[2],
              deg = _ref4[3];
          return [`rotate3d(${x},${y},${z},${mergeUnit(deg, unit)})`, isTransformIdentity(key, deg)];
        } : arg => [is.arr(arg) ? `${key}(${arg.map(v => mergeUnit(v, unit)).join(',')})` : `${key}(${mergeUnit(arg, unit)})`, isTransformIdentity(key, arg)]);
        delete style[key];
      }
    }); // finally, we set the transform key of the animated style to the
    // interpolation of all the props, using the transform functions we defined
    // above

    if (props.length > 0) {
      style.transform = to(props, function () {
        let transform = '';
        let identity = true;

        for (let i = 0; i < arguments.length; i++) {
          const _transforms$i = transforms[i](i < 0 || arguments.length <= i ? undefined : arguments[i]),
                t = _transforms$i[0],
                id = _transforms$i[1];

          transform += ' ' + t;
          identity = identity && id;
        } // if the identity flag was true for all transforms, we set the transform
        // to none, otherwise we return the concatenated transform string


        return identity ? 'none' : transform;
      });
    }

    super(style);
  }

}

const elements = ['a', 'abbr', 'address', 'area', 'article', 'aside', 'audio', 'b', 'base', 'bdi', 'bdo', 'big', 'blockquote', 'body', 'br', 'button', 'canvas', 'caption', 'cite', 'code', 'col', 'colgroup', 'data', 'datalist', 'dd', 'del', 'details', 'dfn', 'dialog', 'div', 'dl', 'dt', 'em', 'embed', 'fieldset', 'figcaption', 'figure', 'footer', 'form', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'head', 'header', 'hgroup', 'hr', 'html', 'i', 'iframe', 'img', 'input', 'ins', 'kbd', 'keygen', 'label', 'legend', 'li', 'link', 'main', 'map', 'mark', 'menu', 'menuitem', 'meta', 'meter', 'nav', 'noscript', 'object', 'ol', 'optgroup', 'option', 'output', 'p', 'param', 'picture', 'pre', 'progress', 'q', 'rp', 'rt', 'ruby', 's', 'samp', 'script', 'section', 'select', 'small', 'source', 'span', 'strong', 'style', 'sub', 'summary', 'sup', 'table', 'tbody', 'td', 'textarea', 'tfoot', 'th', 'thead', 'time', 'title', 'tr', 'track', 'u', 'ul', 'var', 'video', 'wbr', // SVG
'circle', 'clipPath', 'defs', 'ellipse', 'foreignObject', 'g', 'image', 'line', 'linearGradient', 'mask', 'path', 'pattern', 'polygon', 'polyline', 'radialGradient', 'rect', 'stop', 'svg', 'text', 'tspan'];

const animated = extendAnimated(withAnimated, elements);

Globals.assign({
  defaultElement: 'div',
  colorNames,
  applyAnimatedValues,
  createStringInterpolator,
  createAnimatedStyle: style => new AnimatedStyle(style),
  getComponentProps: (_ref) => {
    let scrollTop = _ref.scrollTop,
        scrollLeft = _ref.scrollLeft,
        props = _objectWithoutPropertiesLoose(_ref, ["scrollTop", "scrollLeft"]);

    return props;
  }
});

export { animated as a, animated };
//# sourceMappingURL=index.js.map
