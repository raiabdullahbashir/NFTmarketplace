{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar react_1 = require(\"react\");\n\nexports.is = {\n  arr: Array.isArray,\n  obj: function (a) {\n    return !!a && a.constructor.name === 'Object';\n  },\n  fun: function (a) {\n    return typeof a === 'function';\n  },\n  str: function (a) {\n    return typeof a === 'string';\n  },\n  num: function (a) {\n    return typeof a === 'number';\n  },\n  und: function (a) {\n    return a === void 0;\n  }\n};\n/** An unsafe object/array/set iterator that allows for better minification */\n\nexports.each = function (obj, cb, ctx) {\n  if (exports.is.fun(obj.forEach)) {\n    obj.forEach(cb, ctx);\n  } else {\n    Object.keys(obj).forEach(function (key) {\n      return cb.call(ctx, obj[key], key);\n    });\n  }\n};\n\nexports.toArray = function (a) {\n  return exports.is.und(a) ? [] : Array.isArray(a) ? a : [a];\n};\n\nexports.useOnce = function (effect) {\n  return react_1.useEffect(effect, []);\n};\n\nexports.useForceUpdate = function () {\n  return react_1.useReducer(function () {\n    return {};\n  }, 0)[1];\n};\n/** Use a value from the previous render */\n\n\nfunction usePrev(value) {\n  var prevRef = react_1.useRef(undefined);\n  react_1.useEffect(function () {\n    prevRef.current = value;\n  });\n  return prevRef.current;\n}\n\nexports.usePrev = usePrev;","map":{"version":3,"sources":["../src/helpers.ts"],"names":[],"mappings":";;;;;;AAAA,IAAA,OAAA,GAAA,OAAA,CAAA,OAAA,CAAA;;AASa,OAAA,CAAA,EAAA,GAAK;EAChB,GAAG,EAAE,KAAK,CAAC,OADK;EAEhB,GAAG,EAAE,UAAgB,CAAhB,EAAoB;IACvB,OAAA,CAAC,CAAC,CAAF,IAAO,CAAC,CAAC,WAAF,CAAc,IAAd,KAAuB,QAA9B;EAAsC,CAHxB;EAIhB,GAAG,EAAE,UAAC,CAAD,EAAW;IAAoB,OAAA,OAAO,CAAP,KAAA,UAAA;EAAuB,CAJ3C;EAKhB,GAAG,EAAE,UAAC,CAAD,EAAW;IAAkB,OAAA,OAAO,CAAP,KAAA,QAAA;EAAqB,CALvC;EAMhB,GAAG,EAAE,UAAC,CAAD,EAAW;IAAkB,OAAA,OAAO,CAAP,KAAA,QAAA;EAAqB,CANvC;EAOhB,GAAG,EAAE,UAAC,CAAD,EAAW;IAAqB,OAAA,CAAC,KAAK,KAAN,CAAA;EAAY;AAPjC,CAAL;AA8Bb;;AACa,OAAA,CAAA,IAAA,GAAe,UAAC,GAAD,EAAiB,EAAjB,EAA0B,GAA1B,EAAkC;EAC5D,IAAI,OAAA,CAAA,EAAA,CAAG,GAAH,CAAO,GAAG,CAAC,OAAX,CAAJ,EAAyB;IACvB,GAAG,CAAC,OAAJ,CAAY,EAAZ,EAAgB,GAAhB;EACD,CAFD,MAEO;IACL,MAAM,CAAC,IAAP,CAAY,GAAZ,EAAiB,OAAjB,CAAyB,UAAA,GAAA,EAAG;MAAI,OAAA,EAAE,CAAC,IAAH,CAAQ,GAAR,EAAa,GAAG,CAAC,GAAD,CAAhB,EAAA,GAAA,CAAA;IAA2B,CAA3D;EACD;AACF,CANY;;AAQA,OAAA,CAAA,OAAA,GAAU,UAAI,CAAJ,EAAoB;EACzC,OAAA,OAAA,CAAA,EAAA,CAAG,GAAH,CAAO,CAAP,IAAY,EAAZ,GAAiB,KAAK,CAAC,OAAN,CAAc,CAAd,IAAmB,CAAnB,GAAuB,CAAC,CAAD,CAAxC;AAA2C,CADhC;;AAGA,OAAA,CAAA,OAAA,GAAU,UAAC,MAAD,EAA6B;EAAK,OAAA,OAAA,CAAA,SAAA,CAAU,MAAV,EAAA,EAAA,CAAA;AAAqB,CAAjE;;AAEA,OAAA,CAAA,cAAA,GAAiB,YAAA;EAAM,OAAA,OAAA,CAAA,UAAA,CAAW,YAAA;IAAM,OAAA,EAAA;EAAI,CAArB,EAAuB,CAAvB,EAAA,CAAA,CAAA;AAA4C,CAAnE;AAEb;;;AACA,SAAgB,OAAhB,CAA2B,KAA3B,EAAmC;EACjC,IAAM,OAAO,GAAG,OAAA,CAAA,MAAA,CAAY,SAAZ,CAAhB;EACA,OAAA,CAAA,SAAA,CAAU,YAAA;IACR,OAAO,CAAC,OAAR,GAAkB,KAAlB;EACD,CAFD;EAGA,OAAO,OAAO,CAAC,OAAf;AACD;;AAND,OAAA,CAAA,OAAA,GAAA,OAAA","sourcesContent":["import { useEffect, useReducer, useRef } from 'react'\nimport { Indexable, OneOrMore } from './types'\n\ninterface IsArray {\n  <T>(a: T): a is T & readonly any[]\n}\n\ntype PlainObject<T> = Exclude<T & Indexable, Function | readonly any[]>\n\nexport const is = {\n  arr: Array.isArray as IsArray,\n  obj: <T extends any>(a: T): a is PlainObject<T> =>\n    !!a && a.constructor.name === 'Object',\n  fun: (a: unknown): a is Function => typeof a === 'function',\n  str: (a: unknown): a is string => typeof a === 'string',\n  num: (a: unknown): a is number => typeof a === 'number',\n  und: (a: unknown): a is undefined => a === void 0,\n}\n\ninterface EachFn {\n  <T = any, This = any>(\n    obj: ReadonlySet<T>,\n    cb: (this: This, value: T) => void,\n    ctx?: This\n  ): void\n\n  <T = any, This = any>(\n    arr: readonly T[],\n    cb: (this: This, value: T, index: number) => void,\n    ctx?: This\n  ): void\n\n  <T = any, This = any>(\n    obj: Indexable<T>,\n    cb: (this: This, value: T, key: string) => void,\n    ctx?: This\n  ): void\n}\n\n/** An unsafe object/array/set iterator that allows for better minification */\nexport const each: EachFn = (obj: Indexable, cb: any, ctx: any) => {\n  if (is.fun(obj.forEach)) {\n    obj.forEach(cb, ctx)\n  } else {\n    Object.keys(obj).forEach(key => cb.call(ctx, obj[key], key))\n  }\n}\n\nexport const toArray = <T>(a?: OneOrMore<T>): T[] =>\n  is.und(a) ? [] : Array.isArray(a) ? a : [a]\n\nexport const useOnce = (effect: React.EffectCallback) => useEffect(effect, [])\n\nexport const useForceUpdate = () => useReducer(() => ({}), 0)[1] as (() => void)\n\n/** Use a value from the previous render */\nexport function usePrev<T>(value: T): T | undefined {\n  const prevRef = useRef<any>(undefined)\n  useEffect(() => {\n    prevRef.current = value\n  })\n  return prevRef.current\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"script"}