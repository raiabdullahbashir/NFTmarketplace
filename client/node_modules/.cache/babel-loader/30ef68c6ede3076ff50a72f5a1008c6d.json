{"ast":null,"code":"import { concat, hexlify } from \"@ethersproject/bytes\";\nimport { toUtf8Bytes, toUtf8String } from \"@ethersproject/strings\";\nimport { keccak256 } from \"@ethersproject/keccak256\";\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\nimport { ens_normalize } from \"./ens-normalize/lib\";\nconst Zeros = new Uint8Array(32);\nZeros.fill(0);\n\nfunction checkComponent(comp) {\n  if (comp.length === 0) {\n    throw new Error(\"invalid ENS name; empty component\");\n  }\n\n  return comp;\n}\n\nfunction ensNameSplit(name) {\n  const bytes = toUtf8Bytes(ens_normalize(name));\n  const comps = [];\n\n  if (name.length === 0) {\n    return comps;\n  }\n\n  let last = 0;\n\n  for (let i = 0; i < bytes.length; i++) {\n    const d = bytes[i]; // A separator (i.e. \".\"); copy this component\n\n    if (d === 0x2e) {\n      comps.push(checkComponent(bytes.slice(last, i)));\n      last = i + 1;\n    }\n  } // There was a stray separator at the end of the name\n\n\n  if (last >= bytes.length) {\n    throw new Error(\"invalid ENS name; empty component\");\n  }\n\n  comps.push(checkComponent(bytes.slice(last)));\n  return comps;\n}\n\nexport function ensNormalize(name) {\n  return ensNameSplit(name).map(comp => toUtf8String(comp)).join(\".\");\n}\nexport function isValidName(name) {\n  try {\n    return ensNameSplit(name).length !== 0;\n  } catch (error) {}\n\n  return false;\n}\nexport function namehash(name) {\n  /* istanbul ignore if */\n  if (typeof name !== \"string\") {\n    logger.throwArgumentError(\"invalid ENS name; not a string\", \"name\", name);\n  }\n\n  let result = Zeros;\n  const comps = ensNameSplit(name);\n\n  while (comps.length) {\n    result = keccak256(concat([result, keccak256(comps.pop())]));\n  }\n\n  return hexlify(result);\n}\nexport function dnsEncode(name) {\n  return hexlify(concat(ensNameSplit(name).map(comp => {\n    // DNS does not allow components over 63 bytes in length\n    if (comp.length > 63) {\n      throw new Error(\"invalid DNS encoded entry; length exceeds 63 bytes\");\n    }\n\n    const bytes = new Uint8Array(comp.length + 1);\n    bytes.set(comp, 1);\n    bytes[0] = bytes.length - 1;\n    return bytes;\n  }))) + \"00\";\n}","map":{"version":3,"sources":["../src.ts/namehash.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { concat, hexlify } from \"@ethersproject/bytes\";\nimport { toUtf8Bytes, toUtf8String } from \"@ethersproject/strings\";\nimport { keccak256 } from \"@ethersproject/keccak256\";\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\nimport { ens_normalize } from \"./ens-normalize/lib\";\nconst Zeros = new Uint8Array(32);\nZeros.fill(0);\nfunction checkComponent(comp) {\n    if (comp.length === 0) {\n        throw new Error(\"invalid ENS name; empty component\");\n    }\n    return comp;\n}\nfunction ensNameSplit(name) {\n    const bytes = toUtf8Bytes(ens_normalize(name));\n    const comps = [];\n    if (name.length === 0) {\n        return comps;\n    }\n    let last = 0;\n    for (let i = 0; i < bytes.length; i++) {\n        const d = bytes[i];\n        // A separator (i.e. \".\"); copy this component\n        if (d === 0x2e) {\n            comps.push(checkComponent(bytes.slice(last, i)));\n            last = i + 1;\n        }\n    }\n    // There was a stray separator at the end of the name\n    if (last >= bytes.length) {\n        throw new Error(\"invalid ENS name; empty component\");\n    }\n    comps.push(checkComponent(bytes.slice(last)));\n    return comps;\n}\nexport function ensNormalize(name) {\n    return ensNameSplit(name).map((comp) => toUtf8String(comp)).join(\".\");\n}\nexport function isValidName(name) {\n    try {\n        return (ensNameSplit(name).length !== 0);\n    }\n    catch (error) { }\n    return false;\n}\nexport function namehash(name) {\n    /* istanbul ignore if */\n    if (typeof (name) !== \"string\") {\n        logger.throwArgumentError(\"invalid ENS name; not a string\", \"name\", name);\n    }\n    let result = Zeros;\n    const comps = ensNameSplit(name);\n    while (comps.length) {\n        result = keccak256(concat([result, keccak256(comps.pop())]));\n    }\n    return hexlify(result);\n}\nexport function dnsEncode(name) {\n    return hexlify(concat(ensNameSplit(name).map((comp) => {\n        // DNS does not allow components over 63 bytes in length\n        if (comp.length > 63) {\n            throw new Error(\"invalid DNS encoded entry; length exceeds 63 bytes\");\n        }\n        const bytes = new Uint8Array(comp.length + 1);\n        bytes.set(comp, 1);\n        bytes[0] = bytes.length - 1;\n        return bytes;\n    }))) + \"00\";\n}\n//# sourceMappingURL=namehash.js.map"]},"metadata":{},"sourceType":"module"}