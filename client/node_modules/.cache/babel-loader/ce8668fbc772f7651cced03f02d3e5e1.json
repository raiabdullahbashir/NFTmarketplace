{"ast":null,"code":"\"use strict\";\n/* Sourced from 0x.js */\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar ethUtil = require(\"ethereumjs-util\");\n\nexports.signatureUtils = {\n  isValidSignature: function (data, signature, signerAddress) {\n    var dataBuff = ethUtil.toBuffer(data); // const msgHashBuff = ethUtil.hashPersonalMessage(dataBuff);\n\n    var msgHashBuff = dataBuff;\n\n    try {\n      var pubKey = ethUtil.ecrecover(msgHashBuff, signature.v, ethUtil.toBuffer(signature.r), ethUtil.toBuffer(signature.s));\n      var retrievedAddress = ethUtil.bufferToHex(ethUtil.pubToAddress(pubKey));\n      return retrievedAddress === signerAddress;\n    } catch (err) {\n      return false;\n    }\n  },\n  parseSignatureHexAsVRS: function (signatureHex) {\n    var signatureBuffer = ethUtil.toBuffer(signatureHex);\n    var v = signatureBuffer[0];\n\n    if (v < 27) {\n      v += 27;\n    }\n\n    var r = signatureBuffer.slice(1, 33);\n    var s = signatureBuffer.slice(33, 65);\n    var ecSignature = {\n      v: v,\n      r: ethUtil.bufferToHex(r),\n      s: ethUtil.bufferToHex(s)\n    };\n    return ecSignature;\n  },\n  parseSignatureHexAsRSV: function (signatureHex) {\n    var _a = ethUtil.fromRpcSig(signatureHex),\n        v = _a.v,\n        r = _a.r,\n        s = _a.s;\n\n    var ecSignature = {\n      v: v,\n      r: ethUtil.bufferToHex(r),\n      s: ethUtil.bufferToHex(s)\n    };\n    return ecSignature;\n  }\n};","map":{"version":3,"sources":["../../src/utils/signature_utils.ts"],"names":[],"mappings":";AAAA;;;;;;AAEA,IAAA,OAAA,GAAA,OAAA,CAAA,iBAAA,CAAA;;AAIa,OAAA,CAAA,cAAA,GAAiB;EAC1B,gBAAgB,EAAhB,UAAiB,IAAjB,EAA+B,SAA/B,EAAuD,aAAvD,EAA4E;IACxE,IAAM,QAAQ,GAAG,OAAO,CAAC,QAAR,CAAiB,IAAjB,CAAjB,CADwE,CAExE;;IACA,IAAM,WAAW,GAAG,QAApB;;IACA,IAAI;MACA,IAAM,MAAM,GAAG,OAAO,CAAC,SAAR,CACX,WADW,EAEX,SAAS,CAAC,CAFC,EAGX,OAAO,CAAC,QAAR,CAAiB,SAAS,CAAC,CAA3B,CAHW,EAIX,OAAO,CAAC,QAAR,CAAiB,SAAS,CAAC,CAA3B,CAJW,CAAf;MAMA,IAAM,gBAAgB,GAAG,OAAO,CAAC,WAAR,CAAoB,OAAO,CAAC,YAAR,CAAqB,MAArB,CAApB,CAAzB;MACA,OAAO,gBAAgB,KAAK,aAA5B;IACH,CATD,CASE,OAAO,GAAP,EAAY;MACV,OAAO,KAAP;IACH;EACJ,CAjByB;EAkB1B,sBAAsB,EAAtB,UAAuB,YAAvB,EAA2C;IACvC,IAAM,eAAe,GAAG,OAAO,CAAC,QAAR,CAAiB,YAAjB,CAAxB;IACA,IAAI,CAAC,GAAG,eAAe,CAAC,CAAD,CAAvB;;IACA,IAAI,CAAC,GAAG,EAAR,EAAY;MACR,CAAC,IAAI,EAAL;IACH;;IACD,IAAM,CAAC,GAAG,eAAe,CAAC,KAAhB,CAAsB,CAAtB,EAAyB,EAAzB,CAAV;IACA,IAAM,CAAC,GAAG,eAAe,CAAC,KAAhB,CAAsB,EAAtB,EAA0B,EAA1B,CAAV;IACA,IAAM,WAAW,GAAgB;MAC7B,CAAC,EAAA,CAD4B;MAE7B,CAAC,EAAE,OAAO,CAAC,WAAR,CAAoB,CAApB,CAF0B;MAG7B,CAAC,EAAE,OAAO,CAAC,WAAR,CAAoB,CAApB;IAH0B,CAAjC;IAKA,OAAO,WAAP;EACH,CAhCyB;EAiC1B,sBAAsB,EAAtB,UAAuB,YAAvB,EAA2C;IACjC,IAAA,EAAA,GAAA,OAAA,CAAA,UAAA,CAAA,YAAA,CAAA;IAAA,IAAE,CAAA,GAAA,EAAA,CAAA,CAAF;IAAA,IAAK,CAAA,GAAA,EAAA,CAAA,CAAL;IAAA,IAAQ,CAAA,GAAA,EAAA,CAAA,CAAR;;IACN,IAAM,WAAW,GAAgB;MAC7B,CAAC,EAAA,CAD4B;MAE7B,CAAC,EAAE,OAAO,CAAC,WAAR,CAAoB,CAApB,CAF0B;MAG7B,CAAC,EAAE,OAAO,CAAC,WAAR,CAAoB,CAApB;IAH0B,CAAjC;IAKA,OAAO,WAAP;EACH;AAzCyB,CAAjB","sourceRoot":"","sourcesContent":["\"use strict\";\r\n/* Sourced from 0x.js */\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar ethUtil = require(\"ethereumjs-util\");\r\nexports.signatureUtils = {\r\n    isValidSignature: function (data, signature, signerAddress) {\r\n        var dataBuff = ethUtil.toBuffer(data);\r\n        // const msgHashBuff = ethUtil.hashPersonalMessage(dataBuff);\r\n        var msgHashBuff = dataBuff;\r\n        try {\r\n            var pubKey = ethUtil.ecrecover(msgHashBuff, signature.v, ethUtil.toBuffer(signature.r), ethUtil.toBuffer(signature.s));\r\n            var retrievedAddress = ethUtil.bufferToHex(ethUtil.pubToAddress(pubKey));\r\n            return retrievedAddress === signerAddress;\r\n        }\r\n        catch (err) {\r\n            return false;\r\n        }\r\n    },\r\n    parseSignatureHexAsVRS: function (signatureHex) {\r\n        var signatureBuffer = ethUtil.toBuffer(signatureHex);\r\n        var v = signatureBuffer[0];\r\n        if (v < 27) {\r\n            v += 27;\r\n        }\r\n        var r = signatureBuffer.slice(1, 33);\r\n        var s = signatureBuffer.slice(33, 65);\r\n        var ecSignature = {\r\n            v: v,\r\n            r: ethUtil.bufferToHex(r),\r\n            s: ethUtil.bufferToHex(s),\r\n        };\r\n        return ecSignature;\r\n    },\r\n    parseSignatureHexAsRSV: function (signatureHex) {\r\n        var _a = ethUtil.fromRpcSig(signatureHex), v = _a.v, r = _a.r, s = _a.s;\r\n        var ecSignature = {\r\n            v: v,\r\n            r: ethUtil.bufferToHex(r),\r\n            s: ethUtil.bufferToHex(s),\r\n        };\r\n        return ecSignature;\r\n    },\r\n};\r\n//# sourceMappingURL=signature_utils.js.map"]},"metadata":{},"sourceType":"script"}