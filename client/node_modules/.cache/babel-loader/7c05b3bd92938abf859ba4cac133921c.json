{"ast":null,"code":"import React, { useEffect, useRef, useMemo, useImperativeHandle } from 'react';\nimport _extends from '@babel/runtime/helpers/esm/extends';\nimport { is, each, toArray, usePrev, useOnce, useForceUpdate, Globals } from '@react-spring/shared';\nexport { Globals, createInterpolator } from '@react-spring/shared';\nimport _objectWithoutPropertiesLoose from '@babel/runtime/helpers/esm/objectWithoutPropertiesLoose';\nimport { useMemoOne, useCallbackOne } from 'use-memo-one';\nimport { now, createStringInterpolator, frameLoop, skipAnimation, colorNames, requestAnimationFrame } from '@react-spring/shared/globals';\nimport { AnimatedArray, AnimatedValue, Animated } from '@react-spring/animated';\nexport { interpolate, isAnimated, to } from '@react-spring/animated';\nimport { createStringInterpolator as createStringInterpolator$1 } from '@react-spring/shared/stringInterpolation';\n/** API\n *  useChain(references, timeSteps, timeFrame)\n */\n\nfunction useChain(refs, timeSteps, timeFrame) {\n  if (timeFrame === void 0) {\n    timeFrame = 1000;\n  }\n\n  useEffect(() => {\n    if (timeSteps) {\n      let prevDelay = 0;\n      refs.forEach((ref, i) => {\n        if (!ref.current) return;\n        const controllers = ref.current.controllers;\n\n        if (controllers.length) {\n          let delay = timeFrame * timeSteps[i]; // Use the previous delay if none exists.\n\n          if (isNaN(delay)) delay = prevDelay;else prevDelay = delay;\n          controllers.forEach(ctrl => {\n            ctrl.queue.forEach(props => props.delay += delay);\n            ctrl.start();\n          });\n        }\n      });\n    } else {\n      let p = Promise.resolve();\n      refs.forEach(ref => {\n        const _ref = ref.current || {},\n              controllers = _ref.controllers,\n              start = _ref.start;\n\n        if (controllers && controllers.length) {\n          // Take the queue of each controller\n          const updates = controllers.map(ctrl => {\n            const q = ctrl.queue;\n            ctrl.queue = [];\n            return q;\n          }); // Apply the queue when the previous ref stops animating\n\n          p = p.then(() => {\n            controllers.forEach((ctrl, i) => ctrl.queue.push(...updates[i]));\n            return start();\n          });\n        } else {\n          console.warn('useChain ref has no animations:', ref);\n        }\n      });\n    }\n  });\n}\n\nfunction fillArray(length, mapIndex) {\n  const arr = [];\n\n  for (let i = 0; i < length; i++) arr.push(mapIndex(i));\n\n  return arr;\n}\n\nfunction withDefault(value, defaultValue) {\n  return value == null ? defaultValue : value;\n}\n\nfunction callProp(obj) {\n  for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n    args[_key - 1] = arguments[_key];\n  }\n\n  return is.fun(obj) ? obj(...args) : obj;\n}\n/**\r\n * Extract any properties whose keys are *not* reserved for customizing your\r\n * animations. All hooks use this function, which means `useTransition` props\r\n * are reserved for `useSpring` calls, etc.\r\n */\n\n\nfunction getForwardProps(props) {\n  const children = props.children,\n        config = props.config,\n        from = props.from,\n        to = props.to,\n        ref = props.ref,\n        reset = props.reset,\n        cancel = props.cancel,\n        reverse = props.reverse,\n        immediate = props.immediate,\n        delay = props.delay,\n        lazy = props.lazy,\n        items = props.items,\n        trail = props.trail,\n        unique = props.unique,\n        initial = props.initial,\n        enter = props.enter,\n        leave = props.leave,\n        update = props.update,\n        onAnimate = props.onAnimate,\n        onStart = props.onStart,\n        onRest = props.onRest,\n        onFrame = props.onFrame,\n        onDestroyed = props.onDestroyed,\n        timestamp = props.timestamp,\n        attach = props.attach,\n        forward = _objectWithoutPropertiesLoose(props, [\"children\", \"config\", \"from\", \"to\", \"ref\", \"reset\", \"cancel\", \"reverse\", \"immediate\", \"delay\", \"lazy\", \"items\", \"trail\", \"unique\", \"initial\", \"enter\", \"leave\", \"update\", \"onAnimate\", \"onStart\", \"onRest\", \"onFrame\", \"onDestroyed\", \"timestamp\", \"attach\"]);\n\n  return forward;\n}\n\nfunction interpolateTo(props) {\n  const to = getForwardProps(props);\n  const out = {\n    to\n  };\n  each(props, (val, key) => key in to || (out[key] = val));\n  return out;\n}\n/**\r\n * This tries to put deleted items back into the given `out` list in correct\r\n * order. Deleted items must have a `left` and `right` property with key of\r\n * their sibling which is used to find the correct placement.\r\n */\n\n\nfunction reconcileDeleted(deleted, current) {\n  // Copy as we will be mutating the arrays\n  deleted = [...deleted];\n  current = [...current]; // Used to detect deadlock (when a pass finds 0 siblings)\n\n  let failedTries = 0; // Track where the current pass start/ends\n\n  let passIndex = 0;\n  let nextPassIndex = deleted.length; // Insert all deleted items into `current`\n\n  for (let i = 0; i < deleted.length; i++) {\n    if (i === nextPassIndex) {\n      // Sanity test: Push to end if somehow no siblings were found\n      if (passIndex + failedTries === nextPassIndex) {\n        for (let j = i; j < deleted.length; j++) {\n          const _deleted$j = deleted[j],\n                left = _deleted$j.left,\n                right = _deleted$j.right,\n                deletedItem = _objectWithoutPropertiesLoose(_deleted$j, [\"left\", \"right\"]);\n\n          current.push(deletedItem);\n        }\n\n        break;\n      } // Update local state at the end of each pass\n\n\n      passIndex = nextPassIndex;\n      nextPassIndex = deleted.length;\n      failedTries = 0;\n    } // The index of the deleted item in `current`\n\n\n    let index = -1; // Look for the left or right sibling in `current`\n\n    const _deleted$i = deleted[i],\n          left = _deleted$i.left,\n          right = _deleted$i.right,\n          deletedItem = _objectWithoutPropertiesLoose(_deleted$i, [\"left\", \"right\"]);\n\n    for (let j = current.length; --j >= 0;) {\n      const key = current[j].originalKey;\n\n      if (key === right) {\n        index = j;\n        break;\n      }\n\n      if (key === left) {\n        index = j + 1;\n        break;\n      }\n    } // Items with no index are revisited in the next pass\n\n\n    if (index < 0) {\n      failedTries++;\n      deleted.push(deleted[i]);\n    } else {\n      current.splice(index, 0, deletedItem);\n    }\n  }\n\n  return current;\n}\n\nfunction freeze(obj) {\n  if (typeof process !== 'undefined' && process.env.NODE_ENV === 'development') {\n    return Object.freeze(obj);\n  }\n\n  return obj;\n}\n\nconst linear = t => t;\n\nconst emptyObj = Object.freeze({});\nlet nextId = 1;\n\nclass Controller {\n  constructor(props) {\n    this.id = nextId++;\n    this.idle = true;\n    this.runCount = 0;\n    this.destroyed = false;\n    this.props = {};\n    this.queue = [];\n    this.timestamps = {};\n    this.values = {};\n    this.merged = {};\n    this.animated = {};\n    this.animations = {};\n    this.configs = [];\n    this.children = [];\n    this.onEndQueue = [];\n    this.cancelledAt = 0;\n    if (props) this.update(props).start();\n  }\n  /**\r\n   * Push props into the update queue. The props are used after `start` is\r\n   * called and any delay is over. The props are intelligently diffed to ensure\r\n   * that later calls to this method properly override any delayed props.\r\n   * The `propsArg` argument is always copied before mutations are made.\r\n   */\n\n\n  update(propsArg) {\n    if (!propsArg || this.destroyed) return this;\n    const props = interpolateTo(propsArg); // For async animations, the `from` prop must be defined for\n    // the Animated nodes to exist before animations have started.\n\n    this._ensureAnimated(props.from, true);\n\n    this._ensureAnimated(props.to);\n\n    props.timestamp = now(); // The `delay` prop of every update must be a number >= 0\n\n    if (is.fun(props.delay) && is.obj(props.to)) {\n      const from = props.from || emptyObj;\n\n      for (const key in props.to) {\n        this.queue.push(_extends({}, props, {\n          to: {\n            [key]: props.to[key]\n          },\n          from: key in from ? {\n            [key]: from[key]\n          } : void 0,\n          delay: Math.max(0, Math.round(props.delay(key)))\n        }));\n      }\n    } else {\n      props.delay = is.num(props.delay) ? Math.max(0, Math.round(props.delay)) : 0; // Coerce falsy values to undefined for these props\n\n      if (!props.to) props.to = void 0;\n      if (!props.from) props.from = void 0;\n      this.queue.push(props);\n    }\n\n    return this;\n  }\n  /**\r\n   * Flush the update queue, and call `onEnd` when they have settled.\r\n   *\r\n   * The `onEnd` callback does **not** wait for unsettled updates from previous `start` calls.\r\n   */\n\n\n  start(onEnd) {\n    if (this.queue.length) this._flush(onEnd);else if (onEnd) onEnd();\n    return this;\n  }\n  /** Stop one animation or all animations */\n\n\n  stop() {\n    for (var _len = arguments.length, keys = new Array(_len), _key = 0; _key < _len; _key++) {\n      keys[_key] = arguments[_key];\n    } // Stop animations by key\n\n\n    if (keys.length) {\n      for (const key of keys) {\n        const index = this.configs.findIndex(config => key === config.key);\n\n        this._stopAnimation(key);\n\n        this.configs[index] = this.animations[key];\n      }\n    } // Stop all animations\n    else if (this.runCount) {\n      this.cancelledAt = now(); // Update the animation configs\n\n      each(this.configs, config => this._stopAnimation(config.key));\n      this.configs = Object.values(this.animations); // Exit the frameloop\n\n      if (!this.idle) {\n        this._stop();\n      }\n    }\n\n    return this;\n  }\n  /** Revert the controller to its initial state */\n\n\n  reset() {\n    // Stop all current animations\n    this.stop(); // Revert the internal state\n\n    this.destroyed = false;\n    this.props = {};\n    this.queue = [];\n    this.timestamps = {};\n    this.values = {};\n    this.merged = {};\n    this.animated = {};\n    this.animations = {};\n    this.configs = [];\n    return this;\n  }\n  /** Prevent all current and future animation */\n\n\n  destroy() {\n    if (!this.destroyed) {\n      this.stop();\n      this.destroyed = true;\n    }\n  }\n  /** @internal Called by the frameloop */\n\n\n  onFrame(_ref) {\n    let id = _ref[0],\n        idle = _ref[1],\n        changes = _ref[2];\n    if (id !== this.id) return;\n\n    if (changes && changes.length) {\n      for (const _ref2 of changes) {\n        const key = _ref2[0];\n        const value = _ref2[1];\n        this.values[key] = value;\n      } // The `onFrame` prop always exists when `changes` exists.\n\n\n      this.props.onFrame(_extends({}, this.values));\n    }\n\n    if (idle) {\n      this._stop();\n    }\n  }\n  /**\r\n   * Set a prop for the next animations where the prop is undefined. The given\r\n   * value is overridden by the next update where the prop is defined.\r\n   *\r\n   * Ongoing animations are not changed.\r\n   */\n\n\n  setProp(key, value) {\n    this.props[key] = value;\n    this.timestamps[key] = now();\n    return this;\n  }\n  /** @internal Get the `AnimatedValue` nodes for the given key */\n\n\n  getPayload(key) {\n    const anim = this.animations[key];\n    return anim && anim.animatedValues;\n  } // Create an Animated node if none exists.\n\n\n  _ensureAnimated(values, shouldUpdate) {\n    if (shouldUpdate === void 0) {\n      shouldUpdate = false;\n    }\n\n    if (!is.obj(values)) return;\n\n    for (const key in values) {\n      const value = values[key];\n      let animated = this.animated[key];\n\n      if (animated && shouldUpdate && this.animations[key].isNew) {\n        // Ensure the initial value is up-to-date.\n        if (animated.setValue) {\n          animated.setValue(computeGoalValue(value));\n        } else {\n          // Derived nodes need to be swapped out.\n          animated = null;\n        }\n      }\n\n      if (!animated) {\n        animated = createAnimated(value);\n\n        if (this.animated[key]) {\n          // Swap out the old node with the new node.\n          moveChildren(this.animated[key], animated);\n        }\n\n        this.animated[key] = animated;\n\n        this._stopAnimation(key, true);\n      }\n    }\n  } // Add this controller to the frameloop.\n\n\n  _start(onEnd) {\n    if (this.idle) {\n      if (this.configs.some(config => !config.idle)) {\n        this.idle = false;\n        frameLoop.start(this);\n      } else if (onEnd) {\n        return onEnd();\n      }\n    }\n\n    if (onEnd) {\n      this.onEndQueue.push(onEnd);\n    }\n  } // Attach our children to the given keys if possible.\n\n\n  _attach(keys, visited) {\n    if (visited === void 0) {\n      visited = {};\n    }\n\n    each(this.children, c => {\n      if (visited[this.id]) return;\n      visited[this.id] = true;\n      const attached = keys.filter(key => {\n        const payload = c.getPayload(key);\n\n        if (payload) {\n          each(payload, node => node.done && node.reset(true));\n          return true;\n        }\n      });\n\n      if (attached.length) {\n        c._attach(attached, visited);\n\n        c._start();\n      }\n    });\n  } // Remove this controller from the frameloop, and notify any listeners.\n\n\n  _stop() {\n    this.idle = true;\n    frameLoop.stop(this);\n    const onRest = this.props.onRest;\n\n    if (is.fun(onRest)) {\n      onRest(this.merged);\n    }\n\n    const onEndQueue = this.onEndQueue;\n\n    if (onEndQueue.length) {\n      this.onEndQueue = [];\n      each(onEndQueue, onEnd => onEnd());\n    }\n  } // Execute the current queue of prop updates.\n\n\n  _flush(onEnd) {\n    const queue = this.queue.reduce(reduceDelays, []);\n    this.queue.length = 0; // Track the number of unsettled updates.\n\n    let runsLeft = Object.keys(queue).length;\n    this.runCount += runsLeft; // Any run can finish last.\n\n    const onRunEnd = () => {\n      this.runCount--;\n\n      if (! --runsLeft && onEnd) {\n        onEnd();\n      }\n    };\n\n    each(queue, (props, delay) => {\n      if (delay) {\n        setTimeout(() => {\n          // Cancelling methods touch the `cancelledAt` property\n          if (props.timestamp < this.cancelledAt) return;\n\n          this._run(props, onRunEnd);\n        }, delay);\n      } else {\n        this._run(props, onRunEnd);\n      }\n    });\n  } // Update the props and animations\n\n\n  _run(props, onEnd) {\n    if (is.arr(props.to) || is.fun(props.to)) {\n      this._runAsync(props, onEnd);\n    } else if (this._diff(props)) {\n      this._animate(props)._start(onEnd);\n    } else {\n      onEnd();\n    }\n  } // Start an async chain or an async script.\n\n\n  _runAsync(_ref3, onEnd) {\n    let to = _ref3.to,\n        props = _objectWithoutPropertiesLoose(_ref3, [\"to\"]); // Merge other props immediately.\n\n\n    if (this._diff(props)) {\n      this._animate(props);\n    } // Async scripts can be declaratively cancelled.\n\n\n    if (props.cancel === true) {\n      this.props.asyncTo = void 0;\n      return onEnd();\n    } // Never run more than one script at a time\n\n\n    const timestamp = props.timestamp;\n\n    if (!this._diff({\n      asyncTo: to,\n      timestamp\n    })) {\n      return onEnd();\n    }\n\n    const isCancelled = () => // Cancelling methods touch the `cancelledAt` property\n    timestamp < this.cancelledAt || // Async scripts are also cancelled when a new chain/script begins\n    is.fun(to) && to !== this.props.asyncTo;\n\n    let last;\n\n    const next = props => {\n      if (isCancelled()) throw this;\n      return (last = new Promise(done => {\n        this.update(props).start(done);\n      })).then(() => {\n        if (isCancelled()) throw this;\n      });\n    };\n\n    let queue = Promise.resolve();\n\n    if (is.arr(to)) {\n      each(to, props => {\n        queue = queue.then(() => next(props));\n      });\n    } else if (is.fun(to)) {\n      queue = queue.then(() => to(next, this.stop.bind(this)) // Always wait for the last update.\n      .then(() => last));\n    }\n\n    queue.catch(err => err !== this && console.error(err)).then(onEnd);\n  } // Merge every fresh prop. Returns true if one or more props changed.\n  // These props cannot trigger an update by themselves:\n  //   [delay, config, immediate, reverse, attach]\n\n\n  _diff(_ref4) {\n    let timestamp = _ref4.timestamp,\n        delay = _ref4.delay,\n        config = _ref4.config,\n        immediate = _ref4.immediate,\n        reverse = _ref4.reverse,\n        attach = _ref4.attach,\n        props = _objectWithoutPropertiesLoose(_ref4, [\"timestamp\", \"delay\", \"config\", \"immediate\", \"reverse\", \"attach\"]);\n\n    let changed = false; // Generalized diffing algorithm\n\n    const diffProp = (keys, value, owner) => {\n      if (is.und(value)) return;\n      const lastKey = keys[keys.length - 1];\n\n      if (is.obj(value)) {\n        if (!is.obj(owner[lastKey])) owner[lastKey] = {};\n\n        for (const key in value) {\n          diffProp(keys.concat(key), value[key], owner[lastKey]);\n        }\n      } else {\n        const keyPath = keys.join('.');\n        const oldTimestamp = this.timestamps[keyPath];\n\n        if (is.und(oldTimestamp) || timestamp >= oldTimestamp) {\n          this.timestamps[keyPath] = timestamp;\n          const oldValue = owner[lastKey];\n\n          if (!isEqual(value, oldValue)) {\n            changed = true;\n            owner[lastKey] = value;\n          }\n        }\n      }\n    };\n\n    if (reverse) {\n      const to = props.to;\n      props.to = props.from;\n      props.from = is.obj(to) ? to : void 0;\n    } // The \"attach\" prop is called on every diff. It overwrites the \"parent\" prop.\n\n\n    props.parent = (attach ? attach(this) : props.parent) || null;\n    const oldParent = this.props.parent || null;\n\n    if (props.parent !== oldParent) {\n      if (oldParent) oldParent.children.splice(oldParent.children.indexOf(this), 1);\n      if (props.parent) props.parent.children.push(this);\n    }\n\n    for (const key in props) {\n      diffProp([key], props[key], this.props);\n    } // These props only affect one update\n\n\n    if ('reset' in props) this.props.reset = false;\n    if ('cancel' in props) this.props.cancel = void 0;\n    return changed;\n  } // Return true if the given prop was changed by this update\n\n\n  _isModified(props, prop) {\n    return this.timestamps[prop] === props.timestamp;\n  } // Update the animation configs. The given props override any default props.\n\n\n  _animate(props) {\n    const _this$props = this.props,\n          _this$props$from = _this$props.from,\n          from = _this$props$from === void 0 ? emptyObj : _this$props$from,\n          _this$props$to = _this$props.to,\n          to = _this$props$to === void 0 ? emptyObj : _this$props$to,\n          parent = _this$props.parent,\n          onAnimate = _this$props.onAnimate,\n          onStart = _this$props.onStart;\n\n    if (is.fun(onAnimate)) {\n      onAnimate(props, this);\n    }\n\n    let isPrevented = _ => false;\n\n    if (props.cancel && this._isModified(props, 'cancel')) {\n      // Stop all animations when `cancel` is true\n      if (props.cancel === true) {\n        this.stop(); // Prevent pending updates from *before* this update only!\n        // (This must come after the `stop` call above)\n\n        this.cancelledAt = props.timestamp;\n        return this;\n      } // Prevent matching properties from animating when\n      // `cancel` is a string or array of strings\n\n\n      const keys = toArray(props.cancel);\n\n      if (is.arr(keys) && keys.length) {\n        isPrevented = key => keys.indexOf(key) >= 0;\n\n        this.stop(...keys);\n      }\n    } // Merge `from` values with `to` values\n\n\n    this.merged = freeze(_extends({}, from, to)); // True if any animation was updated\n\n    let changed = false; // The animations that are starting or restarting\n\n    const started = []; // Attach when a new \"parent\" controller exists.\n\n    const isAttaching = parent && this._isModified(props, 'parent'); // Reduces input { key: value } pairs into animation objects\n\n\n    for (const key in this.merged) {\n      if (isPrevented(key)) continue;\n      const state = this.animations[key];\n\n      if (!state) {\n        console.warn(`Failed to animate key: \"${key}\"\\n` + `Did you forget to define \"from.${key}\" for an async animation?`);\n        continue;\n      } // Reuse the Animated nodes whenever possible\n\n\n      let animated = state.animated,\n          animatedValues = state.animatedValues;\n      const value = this.merged[key];\n      const goalValue = computeGoalValue(value);\n      const currValue = animated.getValue(); // Stop animations with a goal value equal to its current value.\n\n      if (!props.reset && !isAttaching && isEqual(goalValue, currValue)) {\n        // The animation might be stopped already.\n        if (!state.idle) {\n          changed = true;\n\n          this._stopAnimation(key);\n        }\n\n        continue;\n      } // Replace an animation when its goal value is changed (or it's been reset)\n\n\n      if (props.reset || isAttaching || !isEqual(goalValue, state.isNew ? currValue : state.goalValue)) {\n        const immediate = !!callProp((is.und(props.immediate) ? this.props : props).immediate, key);\n        const isActive = animatedValues.some(node => !node.done);\n        const fromValue = !is.und(from[key]) ? computeGoalValue(from[key]) : goalValue; // Animatable strings use interpolation\n\n        const isInterpolated = isAnimatableString(value);\n\n        if (isInterpolated) {\n          const output = [props.reset ? fromValue : currValue, goalValue];\n          let input = animatedValues[0];\n\n          if (input) {\n            input.setValue(0, false);\n            input.reset(isActive);\n          } else {\n            input = new AnimatedValue(0);\n          }\n\n          try {\n            const prev = animated;\n            animated = input.to({\n              output\n            });\n            moveChildren(prev, animated);\n          } catch (err) {\n            console.warn('Failed to interpolate string from \"%s\" to \"%s\"', output[0], output[1]);\n            console.error(err);\n            continue;\n          }\n\n          if (skipAnimation) {\n            input.setValue(1);\n\n            this._stopAnimation(key);\n\n            continue;\n          }\n\n          if (immediate) {\n            input.setValue(1, false);\n          }\n        } else {\n          // Convert values into Animated nodes (reusing nodes whenever possible)\n          if (is.arr(value)) {\n            if (animated instanceof AnimatedArray) {\n              if (props.reset) animated.setValue(fromValue, false);\n              each(animatedValues, node => node.reset(isActive));\n            } else {\n              const prev = animated;\n              animated = createAnimated(fromValue);\n              moveChildren(prev, animated);\n            }\n          } else {\n            if (animated instanceof AnimatedValue) {\n              if (props.reset) animated.setValue(fromValue, false);\n              animated.reset(isActive);\n            } else {\n              const prev = animated;\n              animated = new AnimatedValue(fromValue);\n              moveChildren(prev, animated);\n            }\n          }\n\n          if (skipAnimation) {\n            animated.setValue(goalValue);\n\n            this._stopAnimation(key);\n\n            continue;\n          }\n\n          if (immediate) {\n            animated.setValue(goalValue, false);\n          }\n        } // Only change the \"config\" of updated animations.\n\n\n        const config = callProp(props.config, key) || callProp(this.props.config, key) || emptyObj;\n\n        if (!(immediate || skipAnimation)) {\n          started.push(key);\n        }\n\n        const fromValues = animatedValues.map(v => v.getValue());\n        const toValues = parent && parent.getPayload(key) || toArray(isInterpolated ? 1 : goalValue);\n        changed = true;\n        this.animations[key] = {\n          key,\n          idle: false,\n          goalValue,\n          toValues,\n          fromValues,\n          animated,\n          animatedValues: Array.from(animated.getPayload()),\n          immediate,\n          duration: config.duration,\n          easing: withDefault(config.easing, linear),\n          decay: config.decay,\n          mass: withDefault(config.mass, 1),\n          tension: withDefault(config.tension, 170),\n          friction: withDefault(config.friction, 26),\n          initialVelocity: withDefault(config.velocity, 0),\n          clamp: withDefault(config.clamp, false),\n          precision: withDefault(config.precision, 0.005),\n          config\n        };\n      }\n    }\n\n    if (changed) {\n      if (started.length) {\n        this._attach(started);\n\n        if (is.fun(onStart)) each(started, key => {\n          onStart(this.animations[key]);\n        });\n      } // Make animations available to the frameloop\n\n\n      const keys = Object.keys(this.animations);\n      this.configs.length = keys.length;\n      each(keys, (key, i) => {\n        const config = this.animations[key];\n        this.configs[i] = config;\n        this.values[key] = config.animated.getValue();\n        this.animated[key] = config.animated;\n      });\n    }\n\n    return this;\n  }\n  /**\r\n   * Stop an animation by its key.\r\n   *\r\n   * This mutates the `timestamps.to[key]`, `props.to[key]`, and `animations[key]` properties.\r\n   * Notably, it does *not* mutate the `configs[key]` or `animated[key]` properties.\r\n   */\n\n\n  _stopAnimation(key, isNew) {\n    const animated = this.animated[key];\n\n    if (!animated) {\n      return console.warn(`Cannot stop an animation for a key that isn't animated: \"${key}\"`);\n    } // Prevent any pending updates to this key\n\n\n    this.timestamps['to.' + key] = now(); // Idle animations are skipped unless their Animated node changed\n\n    const state = this.animations[key] || emptyObj;\n    if (state.idle && animated === state.animated) return; // Use the previous `isNew` value if nothing was passed\n\n    if (is.und(isNew)) {\n      isNew = !!state.isNew;\n    } // Tell the frameloop to skip animating these values\n\n\n    const animatedValues = Array.from(animated.getPayload());\n    each(animatedValues, node => {\n      node.done = true;\n    }); // The current value becomes the goal value,\n    // which ensures the integrity of the diffing algorithm.\n\n    const goalValue = animated.getValue();\n\n    if (this.props.to) {\n      this.props.to[key] = goalValue;\n    } // Remove unused data from this key's animation config\n\n\n    this.animations[key] = {\n      key,\n      idle: true,\n      isNew,\n      goalValue,\n      animated,\n      animatedValues\n    };\n  }\n\n}\n/** Wrap any value with an `Animated` node */\n\n\nfunction createAnimated(value) {\n  return is.arr(value) ? new AnimatedArray(value.map(createAnimated)) : isAnimatableString(value) ? // Convert \"red\" into \"rgba(255, 0, 0, 1)\" etc\n  new AnimatedValue(0).to({\n    output: [value, value]\n  }) : // The `AnimatedValue` class supports any type, but only numbers are\n  // interpolated by the frameloop.\n  new AnimatedValue(value);\n}\n/**\r\n * Replace an `Animated` node in the graph.\r\n * This is most useful for async updates, which don't cause a re-render.\r\n */\n\n\nfunction moveChildren(prev, next) {\n  each(Array.from(prev.getChildren()), child => {\n    child.updatePayload(prev, next);\n    prev.removeChild(child);\n    next.addChild(child);\n  });\n} // Merge updates with the same delay.\n// NOTE: Mutation of `props` may occur!\n\n\nfunction reduceDelays(merged, props) {\n  const prev = merged[props.delay];\n\n  if (prev) {\n    props.to = merge(prev.to, props.to);\n    props.from = merge(prev.from, props.from);\n    Object.assign(prev, props);\n  } else {\n    merged[props.delay] = props;\n  }\n\n  return merged;\n}\n\nfunction merge(dest, src) {\n  return is.obj(dest) && is.obj(src) ? _extends({}, dest, src) : src || dest;\n} // Not all strings can be animated (eg: {display: \"none\"})\n\n\nfunction isAnimatableString(value) {\n  if (!is.str(value)) return false;\n  return value.startsWith('#') || /\\d/.test(value) || !!(colorNames && colorNames[value]);\n} // Compute the goal value, converting \"red\" to \"rgba(255, 0, 0, 1)\" in the process\n\n\nfunction computeGoalValue(value) {\n  return is.arr(value) ? value.map(computeGoalValue) : isAnimatableString(value) ? createStringInterpolator({\n    range: [0, 1],\n    output: [value, value]\n  })(1) : value;\n} // Compare animatable values\n\n\nfunction isEqual(a, b) {\n  if (is.arr(a)) {\n    if (!is.arr(b) || a.length !== b.length) return false;\n\n    for (let i = 0; i < a.length; i++) {\n      if (a[i] !== b[i]) return false;\n    }\n\n    return true;\n  }\n\n  return a === b;\n}\n/** API\n * const props = useSprings(number, [{ ... }, { ... }, ...])\n * const [props, set] = useSprings(number, (i, controller) => ({ ... }))\n */\n\n\nconst useSprings = (length, propsArg, deps) => {\n  const hasNewSprings = length !== usePrev(length);\n  const isFn = is.fun(propsArg);\n  const state = useRef({\n    springs: [],\n    ref: null\n  }).current; // The `propsArg` coerced into an array\n\n  const props = isFn ? [] : propsArg; // Recreate the controllers whenever `length` changes\n\n  const springs = useMemoOne(() => fillArray(length, i => {\n    const s = new Controller();\n    const p = props[i] || (props[i] = callProp(propsArg, i, s));\n    return s.update(p);\n  }), [length]);\n\n  const _useMemo = useMemo(() => ({\n    /** Apply any pending updates */\n    start: () => Promise.all(state.springs.map(s => new Promise(done => s.start(done)))),\n\n    /** Update the spring controllers */\n    update: props => {\n      const isFn = is.fun(props);\n      const isArr = is.arr(props);\n      state.springs.forEach((spring, i) => {\n        spring.update(isFn ? callProp(props, i, spring) : isArr ? props[i] : props);\n        if (!state.ref) spring.start();\n      });\n    },\n\n    /** Stop one key or all keys from animating */\n    stop: function stop() {\n      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n        args[_key] = arguments[_key];\n      }\n\n      return state.springs.forEach(s => s.stop(...args));\n    }\n  }), []),\n        start = _useMemo.start,\n        update = _useMemo.update,\n        stop = _useMemo.stop;\n\n  const ref = props[0] ? props[0].ref : isFn ? state.ref : null;\n  useImperativeHandle(ref, () => ({\n    start,\n    stop,\n\n    get controllers() {\n      return state.springs;\n    }\n\n  })); // Once mounted, update the local state and start any animations.\n\n  useEffect(() => {\n    if (!isFn || hasNewSprings) {\n      props.forEach((p, i) => {\n        // Set default props for async updates\n        springs[i].setProp('config', p.config);\n        springs[i].setProp('immediate', p.immediate);\n      });\n    }\n\n    if (hasNewSprings) {\n      state.springs.forEach(s => s.destroy());\n      state.springs = springs;\n      state.ref = ref;\n\n      if (!ref) {\n        springs.forEach(s => s.start());\n      }\n    } else if (!isFn) {\n      update(props);\n    }\n  }, deps); // Destroy the controllers on unmount\n\n  useOnce(() => () => {\n    state.springs.forEach(s => s.destroy());\n  });\n  const values = springs.map(s => _extends({}, s.animated));\n  return isFn ? [values, update, stop] : values;\n};\n/** API\n * const props = useSpring({ ... })\n * const [props, set] = useSpring(() => ({ ... }))\n */\n\n\nconst useSpring = (props, deps) => {\n  const isFn = is.fun(props);\n\n  const _useSprings = useSprings(1, isFn ? props : [props], deps),\n        result = _useSprings[0],\n        set = _useSprings[1],\n        stop = _useSprings[2];\n\n  return isFn ? [result[0], set, stop] : result;\n};\n/** API\n * const trails = useTrail(number, { ... })\n * const [trails, set] = useTrail(number, () => ({ ... }))\n */\n\n\nconst useTrail = (length, propsArg) => {\n  const hasNewSprings = length !== usePrev(length);\n  const isFn = is.fun(propsArg); // The `propsArg` coerced into an object\n\n  let props = isFn ? null : propsArg; // Retain the controllers so we can update them.\n\n  const springsRef = useRef([]);\n  const springs = springsRef.current;\n  if (hasNewSprings) springs.length = length; // The controllers are recreated whenever `length` changes.\n\n  const _useSprings = useSprings(length, (i, spring) => {\n    if (isFn && !props) {\n      props = callProp(propsArg, spring) || {};\n    }\n\n    springs[i] = spring;\n    return _extends({}, props, i > 0 && {\n      attach: () => springs[i - 1],\n      onStart: withArgument(props.onStart, i),\n      onFrame: withArgument(props.onFrame, i),\n      onRest: withArgument(props.onRest, i)\n    }, {\n      config: callProp(props.config, i)\n    });\n  }),\n        values = _useSprings[0],\n        animate = _useSprings[1],\n        stop = _useSprings[2];\n  /** For imperative updates to the props of all springs in the trail */\n\n\n  const update = useCallbackOne(propsArg => animate((i, spring) => {\n    const props = callProp(propsArg, i, spring) || {};\n    const parent = springsRef.current[props.reverse ? i + 1 : i - 1];\n    return _extends({}, props, {\n      attach: () => parent,\n      config: callProp(props.config, i)\n    });\n  }), []); // Update the animations on re-render when `propsArg` is an object\n  // and the controllers were *not* created in the current render.\n\n  useEffect(() => {\n    if (!isFn && !hasNewSprings) {\n      update(propsArg);\n    }\n  }); // Return the update/stop functions when the `propsArg` is a function.\n\n  return isFn ? [values, update, stop] : values;\n};\n\nfunction withArgument(fn, arg) {\n  return is.fun(fn) ? function () {\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    return fn(...args, arg);\n  } : fn;\n}\n/** API\n * const transitions = useTransition(items, itemKeys, { ... })\n * const [transitions, update] = useTransition(items, itemKeys, () => ({ ... }))\n */\n\n\nlet guid = 0;\nconst INITIAL = 'initial';\nconst ENTER = 'enter';\nconst UPDATE = 'update';\nconst LEAVE = 'leave';\n\nconst makeKeys = (items, keys) => (typeof keys === 'function' ? items.map(keys) : toArray(keys)).map(String);\n\nconst makeConfig = props => {\n  let items = props.items,\n      keys = props.keys,\n      rest = _objectWithoutPropertiesLoose(props, [\"items\", \"keys\"]);\n\n  items = toArray(is.und(items) ? null : items);\n  return _extends({\n    items,\n    keys: makeKeys(items, keys)\n  }, rest);\n};\n\nfunction useTransition(input, keyTransform, props) {\n  props = makeConfig(_extends({}, props, {\n    items: input,\n    keys: keyTransform || (i => i)\n  }));\n\n  const _props = props,\n        _props$lazy = _props.lazy,\n        lazy = _props$lazy === void 0 ? false : _props$lazy,\n        _props$unique = _props.unique,\n        from = _props.from,\n        enter = _props.enter,\n        leave = _props.leave,\n        update = _props.update,\n        onDestroyed = _props.onDestroyed,\n        keys = _props.keys,\n        items = _props.items,\n        onFrame = _props.onFrame,\n        _onRest = _props.onRest,\n        onStart = _props.onStart,\n        ref = _props.ref,\n        extra = _objectWithoutPropertiesLoose(_props, [\"lazy\", \"unique\", \"from\", \"enter\", \"leave\", \"update\", \"onDestroyed\", \"keys\", \"items\", \"onFrame\", \"onRest\", \"onStart\", \"ref\"]);\n\n  const forceUpdate = useForceUpdate();\n  const mounted = useRef(false);\n  const state = useRef({\n    mounted: false,\n    first: true,\n    deleted: [],\n    current: {},\n    transitions: [],\n    prevProps: {},\n    paused: !!ref,\n    instances: !mounted.current && new Map(),\n    forceUpdate\n  });\n  useImperativeHandle(ref, () => ({\n    start: () => Promise.all(Array.from(state.current.instances).map(_ref => {\n      let c = _ref[1];\n      return new Promise(r => c.start(r));\n    })),\n    stop: finished => Array.from(state.current.instances).forEach(_ref2 => {\n      let c = _ref2[1];\n      return c.stop(finished);\n    }),\n\n    get controllers() {\n      return Array.from(state.current.instances).map(_ref3 => {\n        let c = _ref3[1];\n        return c;\n      });\n    }\n\n  })); // Update state\n\n  state.current = diffItems(state.current, props);\n\n  if (state.current.changed) {\n    // Update state\n    state.current.transitions.forEach(transition => {\n      const phase = transition.phase,\n            key = transition.key,\n            item = transition.item,\n            props = transition.props;\n      if (!state.current.instances.has(key)) state.current.instances.set(key, new Controller()); // Avoid calling `onStart` more than once per transition.\n\n      let started = false; // update the map object\n\n      const ctrl = state.current.instances.get(key);\n\n      const itemProps = _extends({}, extra, props, {\n        onRest: values => {\n          if (state.current.mounted) {\n            if (transition.destroyed) {\n              // If no ref is given delete destroyed items immediately\n              if (!ref && !lazy) cleanUp(state, key);\n              if (onDestroyed) onDestroyed(item);\n            } // A transition comes to rest once all its springs conclude\n\n\n            const curInstances = Array.from(state.current.instances);\n            const active = curInstances.some(_ref4 => {\n              let c = _ref4[1];\n              return !c.idle;\n            });\n\n            if (!active && (ref || lazy) && state.current.deleted.length > 0) {\n              cleanUp(state);\n            }\n\n            if (is.fun(_onRest)) {\n              _onRest(item, phase, values);\n            }\n          }\n        },\n        onFrame: is.fun(onFrame) && (values => onFrame(item, phase, values)),\n        onStart: is.fun(onStart) && (animation => started || (started = (onStart(item, phase, animation), true))) // Update controller\n\n      });\n\n      ctrl.update(itemProps);\n      if (!state.current.paused) ctrl.start();\n    });\n  }\n\n  useOnce(() => {\n    state.current.mounted = mounted.current = true;\n    return () => {\n      state.current.mounted = mounted.current = false;\n      Array.from(state.current.instances).map(_ref5 => {\n        let c = _ref5[1];\n        return c.destroy();\n      });\n      state.current.instances.clear();\n    };\n  });\n  return state.current.transitions.map(_ref6 => {\n    let item = _ref6.item,\n        phase = _ref6.phase,\n        key = _ref6.key;\n    return {\n      item,\n      key,\n      phase,\n      props: _extends({}, state.current.instances.get(key).animated)\n    };\n  });\n}\n\nfunction cleanUp(_ref7, filterKey) {\n  let state = _ref7.current;\n  const deleted = state.deleted;\n\n  for (let _ref8 of deleted) {\n    let key = _ref8.key;\n\n    const filter = t => t.key !== key;\n\n    if (is.und(filterKey) || filterKey === key) {\n      state.instances.delete(key);\n      state.transitions = state.transitions.filter(filter);\n      state.deleted = state.deleted.filter(filter);\n    }\n  }\n\n  state.forceUpdate();\n}\n\nfunction diffItems(_ref9, props) {\n  let first = _ref9.first,\n      current = _ref9.current,\n      deleted = _ref9.deleted,\n      prevProps = _ref9.prevProps,\n      state = _objectWithoutPropertiesLoose(_ref9, [\"first\", \"current\", \"deleted\", \"prevProps\"]);\n\n  let items = props.items,\n      keys = props.keys,\n      initial = props.initial,\n      from = props.from,\n      enter = props.enter,\n      leave = props.leave,\n      update = props.update,\n      _props$trail = props.trail,\n      trail = _props$trail === void 0 ? 0 : _props$trail,\n      unique = props.unique,\n      config = props.config,\n      _props$order = props.order,\n      order = _props$order === void 0 ? [ENTER, LEAVE, UPDATE] : _props$order;\n\n  let _makeConfig = makeConfig(prevProps),\n      _keys = _makeConfig.keys,\n      _items = _makeConfig.items;\n\n  if (props.reset) {\n    current = {};\n    state.transitions = [];\n  } // Compare next keys with current keys\n\n\n  const currentKeys = Object.keys(current);\n  const currentSet = new Set(currentKeys);\n  const nextSet = new Set(keys);\n  const addedKeys = keys.filter(key => !currentSet.has(key));\n  const updatedKeys = update ? keys.filter(key => currentSet.has(key)) : [];\n  const deletedKeys = state.transitions.filter(t => !t.destroyed && !nextSet.has(t.originalKey)).map(t => t.originalKey);\n  let delay = -trail;\n\n  while (order.length) {\n    let phase = order.shift();\n\n    if (phase === ENTER) {\n      if (first && !is.und(initial)) {\n        phase = INITIAL;\n        from = initial;\n      }\n\n      addedKeys.forEach(key => {\n        // In unique mode, remove fading out transitions if their key comes in again\n        if (unique && deleted.find(d => d.originalKey === key)) {\n          deleted = deleted.filter(t => t.originalKey !== key);\n        }\n\n        const i = keys.indexOf(key);\n        const item = items[i];\n        const enterProps = callProp(enter, item, i);\n        current[key] = {\n          phase,\n          originalKey: key,\n          key: unique ? String(key) : guid++,\n          item,\n          props: _extends({\n            delay: delay += trail,\n            config: callProp(config, item, phase),\n            from: callProp(from, item, i),\n            to: enterProps\n          }, is.obj(enterProps) && interpolateTo(enterProps))\n        };\n      });\n    } else if (phase === LEAVE) {\n      deletedKeys.forEach(key => {\n        const i = _keys.indexOf(key);\n\n        const item = _items[i];\n        const leaveProps = callProp(leave, item, i);\n        deleted.push(_extends({}, current[key], {\n          phase,\n          destroyed: true,\n          left: _keys[i - 1],\n          right: _keys[i + 1],\n          props: _extends({\n            delay: delay += trail,\n            config: callProp(config, item, phase),\n            to: leaveProps\n          }, is.obj(leaveProps) && interpolateTo(leaveProps))\n        }));\n        delete current[key];\n      });\n    } else if (phase === UPDATE) {\n      updatedKeys.forEach(key => {\n        const i = keys.indexOf(key);\n        const item = items[i];\n        const updateProps = callProp(update, item, i);\n        current[key] = _extends({}, current[key], {\n          phase,\n          props: _extends({\n            delay: delay += trail,\n            config: callProp(config, item, phase),\n            to: updateProps\n          }, is.obj(updateProps) && interpolateTo(updateProps))\n        });\n      });\n    }\n  }\n\n  let out = keys.map(key => current[key]);\n  out = reconcileDeleted(deleted, out);\n  return _extends({}, state, {\n    first: first && !addedKeys.length,\n    changed: !!(addedKeys.length || deletedKeys.length || updatedKeys.length),\n    transitions: out,\n    current,\n    deleted,\n    prevProps: props\n  });\n}\n\nfunction Spring(_ref) {\n  let children = _ref.children,\n      props = _objectWithoutPropertiesLoose(_ref, [\"children\"]);\n\n  return children(useSpring(props));\n}\n\nfunction Trail(_ref2) {\n  let items = _ref2.items,\n      children = _ref2.children,\n      props = _objectWithoutPropertiesLoose(_ref2, [\"items\", \"children\"]);\n\n  const trails = useTrail(items.length, props);\n  return items.map((item, index) => {\n    const result = children(item, index);\n    return is.fun(result) ? result(trails[index]) : result;\n  });\n}\n\nfunction Transition(_ref3) {\n  let items = _ref3.items,\n      _ref3$keys = _ref3.keys,\n      keys = _ref3$keys === void 0 ? null : _ref3$keys,\n      children = _ref3.children,\n      props = _objectWithoutPropertiesLoose(_ref3, [\"items\", \"keys\", \"children\"]);\n\n  const transitions = useTransition(items, keys, props);\n  return transitions.map((_ref4, index) => {\n    let item = _ref4.item,\n        key = _ref4.key,\n        props = _ref4.props,\n        phase = _ref4.phase;\n    const result = children(item, phase, index);\n    const element = is.fun(result) ? result(props) : result;\n    return element && element.type ? React.createElement(element.type, _extends({}, element.props, {\n      key: key,\n      ref: element.ref\n    })) : element;\n  });\n}\n\nclass FrameLoop {\n  constructor(_temp) {\n    let _ref = _temp === void 0 ? {} : _temp,\n        update = _ref.update,\n        onFrame = _ref.onFrame,\n        requestFrame = _ref.requestFrame;\n    /**\r\n     * On each frame, these controllers are searched for values to animate.\r\n     */\n\n\n    this.controllers = new Map();\n    /**\r\n     * True when no controllers are animating.\r\n     */\n\n    this.idle = true;\n\n    this.requestFrame = // The global `requestAnimationFrame` must be dereferenced to avoid \"Illegal invocation\" errors\n    requestFrame || (fn => (0, requestAnimationFrame)(fn));\n\n    this.onFrame = onFrame && onFrame.bind(this) || (updates => {\n      updates.forEach(update => {\n        const ctrl = this.controllers.get(update[0]);\n        if (ctrl) ctrl.onFrame(update);\n      });\n    });\n\n    this.update = update && update.bind(this) || (() => {\n      if (this.idle) {\n        return false;\n      } // Update the animations.\n\n\n      const updates = [];\n\n      for (const id of Array.from(this.controllers.keys())) {\n        let idle = true;\n        const ctrl = this.controllers.get(id);\n        const changes = ctrl.props.onFrame ? [] : null;\n\n        for (const config of ctrl.configs) {\n          if (config.idle) continue;\n\n          if (this.advance(config, changes)) {\n            idle = false;\n          }\n        }\n\n        updates.push([id, idle, changes]);\n      } // Notify the controllers!\n\n\n      this.onFrame(updates); // Are we done yet?\n\n      if (!this.controllers.size) {\n        return !(this.idle = true);\n      } // Keep going.\n\n\n      this.requestFrame(this.update);\n      return true;\n    });\n  }\n\n  start(ctrl) {\n    this.controllers.set(ctrl.id, ctrl);\n\n    if (this.idle) {\n      this.idle = false;\n      this.requestFrame(this.update);\n    }\n  }\n\n  stop(ctrl) {\n    this.controllers.delete(ctrl.id);\n  }\n  /** Advance an animation forward one frame. */\n\n\n  advance(config, changes) {\n    const time = now();\n    let active = false;\n    let changed = false;\n\n    for (let i = 0; i < config.animatedValues.length; i++) {\n      const animated = config.animatedValues[i];\n      if (animated.done) continue;\n      changed = true;\n      let to = config.toValues[i];\n      const target = to instanceof Animated ? to : null;\n      if (target) to = target.getValue(); // Jump to end value for immediate animations\n\n      if (config.immediate) {\n        animated.setValue(to);\n        animated.done = true;\n        continue;\n      }\n\n      const from = config.fromValues[i];\n      const startTime = animated.startTime; // Break animation when string values are involved\n\n      if (typeof from === 'string' || typeof to === 'string') {\n        animated.setValue(to);\n        animated.done = true;\n        continue;\n      }\n\n      let finished = false;\n      let position = animated.lastPosition;\n      let velocity = Array.isArray(config.initialVelocity) ? config.initialVelocity[i] : config.initialVelocity; // Duration easing\n\n      if (config.duration !== void 0) {\n        position = from + config.easing((time - startTime) / config.duration) * (to - from);\n        finished = time >= startTime + config.duration;\n      } // Decay easing\n      else if (config.decay) {\n        const decay = config.decay === true ? 0.998 : config.decay;\n        position = from + velocity / (1 - decay) * (1 - Math.exp(-(1 - decay) * (time - startTime)));\n        finished = Math.abs(animated.lastPosition - position) < 0.1;\n        if (finished) to = position;\n      } // Spring easing\n      else {\n        let lastTime = animated.lastTime !== void 0 ? animated.lastTime : time;\n\n        if (animated.lastVelocity !== void 0) {\n          velocity = animated.lastVelocity;\n        } // If we lost a lot of frames just jump to the end.\n\n\n        if (time > lastTime + 64) lastTime = time; // http://gafferongames.com/game-physics/fix-your-timestep/\n\n        const numSteps = Math.floor(time - lastTime);\n\n        for (let n = 0; n < numSteps; ++n) {\n          const force = -config.tension * (position - to);\n          const damping = -config.friction * velocity;\n          const acceleration = (force + damping) / config.mass;\n          velocity = velocity + acceleration * 1 / 1000;\n          position = position + velocity * 1 / 1000;\n        }\n\n        animated.lastTime = time;\n        animated.lastVelocity = velocity; // Conditions for stopping the spring animation\n\n        const isOvershooting = config.clamp && config.tension !== 0 ? from < to ? position > to : position < to : false;\n        const isVelocity = Math.abs(velocity) <= config.precision;\n        const isDisplacement = config.tension !== 0 ? Math.abs(to - position) <= config.precision : true;\n        finished = isOvershooting || isVelocity && isDisplacement;\n      } // Trails aren't done until their parents conclude\n\n\n      if (finished && !(target && !target.done)) {\n        // Ensure that we end up with a round value\n        if (animated.value !== to) position = to;\n        animated.done = true;\n      } else {\n        active = true;\n      }\n\n      animated.setValue(position);\n      animated.lastPosition = position;\n    }\n\n    if (changes && changed) {\n      changes.push([config.key, config.animated.getValue()]);\n    }\n\n    return active;\n  }\n\n}\n\nGlobals.assign({\n  frameLoop: new FrameLoop(),\n  createStringInterpolator: createStringInterpolator$1,\n  applyAnimatedValues: () => false\n});\n/** Advance all animations forward one frame */\n\nconst update = () => Globals.frameLoop.update(); // The `mass` prop defaults to 1\n\n\nconst config = {\n  default: {\n    tension: 170,\n    friction: 26\n  },\n  gentle: {\n    tension: 120,\n    friction: 14\n  },\n  wobbly: {\n    tension: 180,\n    friction: 12\n  },\n  stiff: {\n    tension: 210,\n    friction: 20\n  },\n  slow: {\n    tension: 280,\n    friction: 60\n  },\n  molasses: {\n    tension: 280,\n    friction: 120\n  }\n};\nexport { Controller, FrameLoop, Spring, Trail, Transition, config, update, useChain, useSpring, useSprings, useTrail, useTransition };","map":{"version":3,"sources":["src/useChain.js","src/helpers.ts","src/Controller.ts","src/useSprings.js","src/useSpring.js","src/useTrail.js","src/useTransition.js","src/legacy.js","src/FrameLoop.ts","src/globals.ts","src/constants.ts"],"names":["timeFrame","useEffect","prevDelay","refs","ref","controllers","delay","timeSteps","isNaN","ctrl","props","p","Promise","start","updates","q","console","fillArray","length","mapIndex","arr","i","withDefault","value","defaultValue","callProp","obj","args","is","children","config","from","to","reset","cancel","reverse","immediate","lazy","items","trail","unique","initial","enter","leave","update","onAnimate","onStart","onRest","onFrame","onDestroyed","timestamp","attach","forward","interpolateTo","getForwardProps","out","each","key","reconcileDeleted","deleted","current","failedTries","passIndex","nextPassIndex","j","left","right","deletedItem","index","freeze","process","Object","linear","t","emptyObj","nextId","Controller","constructor","G","Math","onEnd","stop","keys","destroy","id","idle","changes","setProp","getPayload","anim","_ensureAnimated","shouldUpdate","values","animated","computeGoalValue","createAnimated","moveChildren","_start","_attach","visited","c","attached","payload","node","_stop","onEndQueue","_flush","queue","runsLeft","onRunEnd","setTimeout","_run","_runAsync","asyncTo","isCancelled","next","last","done","err","_diff","changed","diffProp","lastKey","owner","keyPath","oldTimestamp","oldValue","isEqual","oldParent","_isModified","_animate","parent","isPrevented","_","toArray","started","isAttaching","state","animatedValues","goalValue","currValue","isActive","fromValue","isInterpolated","isAnimatableString","output","input","prev","fromValues","v","toValues","Array","duration","easing","decay","mass","tension","friction","initialVelocity","clamp","precision","_stopAnimation","isNew","child","merged","merge","src","range","a","b","useSprings","hasNewSprings","usePrev","isFn","springs","useMemoOne","s","useMemo","isArr","spring","useImperativeHandle","useOnce","useSpring","result","set","useTrail","springsRef","useRef","animate","withArgument","useCallbackOne","propsArg","fn","guid","INITIAL","ENTER","UPDATE","LEAVE","makeKeys","makeConfig","rest","keyTransform","extra","forceUpdate","useForceUpdate","mounted","first","transitions","prevProps","paused","instances","r","finished","diffItems","transition","phase","item","itemProps","cleanUp","curInstances","active","animation","filter","filterKey","order","_keys","_items","currentKeys","currentSet","nextSet","addedKeys","updatedKeys","deletedKeys","d","enterProps","originalKey","String","leaveProps","destroyed","updateProps","trails","useTransition","element","FrameLoop","requestFrame","advance","time","target","startTime","position","velocity","lastTime","numSteps","n","force","damping","acceleration","isOvershooting","isVelocity","isDisplacement","Globals","frameLoop","applyAnimatedValues","default","gentle","wobbly","stiff","slow","molasses"],"mappings":"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","sourcesContent":["import React, { useEffect, useRef, useMemo, useImperativeHandle } from 'react';\nimport _extends from '@babel/runtime/helpers/esm/extends';\nimport { is, each, toArray, usePrev, useOnce, useForceUpdate, Globals } from '@react-spring/shared';\nexport { Globals, createInterpolator } from '@react-spring/shared';\nimport _objectWithoutPropertiesLoose from '@babel/runtime/helpers/esm/objectWithoutPropertiesLoose';\nimport { useMemoOne, useCallbackOne } from 'use-memo-one';\nimport { now, createStringInterpolator, frameLoop, skipAnimation, colorNames, requestAnimationFrame } from '@react-spring/shared/globals';\nimport { AnimatedArray, AnimatedValue, Animated } from '@react-spring/animated';\nexport { interpolate, isAnimated, to } from '@react-spring/animated';\nimport { createStringInterpolator as createStringInterpolator$1 } from '@react-spring/shared/stringInterpolation';\n\n/** API\n *  useChain(references, timeSteps, timeFrame)\n */\n\nfunction useChain(refs, timeSteps, timeFrame) {\n  if (timeFrame === void 0) {\n    timeFrame = 1000;\n  }\n\n  useEffect(() => {\n    if (timeSteps) {\n      let prevDelay = 0;\n      refs.forEach((ref, i) => {\n        if (!ref.current) return;\n        const controllers = ref.current.controllers;\n\n        if (controllers.length) {\n          let delay = timeFrame * timeSteps[i]; // Use the previous delay if none exists.\n\n          if (isNaN(delay)) delay = prevDelay;else prevDelay = delay;\n          controllers.forEach(ctrl => {\n            ctrl.queue.forEach(props => props.delay += delay);\n            ctrl.start();\n          });\n        }\n      });\n    } else {\n      let p = Promise.resolve();\n      refs.forEach(ref => {\n        const _ref = ref.current || {},\n              controllers = _ref.controllers,\n              start = _ref.start;\n\n        if (controllers && controllers.length) {\n          // Take the queue of each controller\n          const updates = controllers.map(ctrl => {\n            const q = ctrl.queue;\n            ctrl.queue = [];\n            return q;\n          }); // Apply the queue when the previous ref stops animating\n\n          p = p.then(() => {\n            controllers.forEach((ctrl, i) => ctrl.queue.push(...updates[i]));\n            return start();\n          });\n        } else {\n          console.warn('useChain ref has no animations:', ref);\n        }\n      });\n    }\n  });\n}\n\nfunction fillArray(length, mapIndex) {\n  const arr = [];\n\n  for (let i = 0; i < length; i++) arr.push(mapIndex(i));\n\n  return arr;\n}\nfunction withDefault(value, defaultValue) {\n  return value == null ? defaultValue : value;\n}\nfunction callProp(obj) {\n  for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n    args[_key - 1] = arguments[_key];\n  }\n\n  return is.fun(obj) ? obj(...args) : obj;\n}\n/**\r\n * Extract any properties whose keys are *not* reserved for customizing your\r\n * animations. All hooks use this function, which means `useTransition` props\r\n * are reserved for `useSpring` calls, etc.\r\n */\n\nfunction getForwardProps(props) {\n  const children = props.children,\n        config = props.config,\n        from = props.from,\n        to = props.to,\n        ref = props.ref,\n        reset = props.reset,\n        cancel = props.cancel,\n        reverse = props.reverse,\n        immediate = props.immediate,\n        delay = props.delay,\n        lazy = props.lazy,\n        items = props.items,\n        trail = props.trail,\n        unique = props.unique,\n        initial = props.initial,\n        enter = props.enter,\n        leave = props.leave,\n        update = props.update,\n        onAnimate = props.onAnimate,\n        onStart = props.onStart,\n        onRest = props.onRest,\n        onFrame = props.onFrame,\n        onDestroyed = props.onDestroyed,\n        timestamp = props.timestamp,\n        attach = props.attach,\n        forward = _objectWithoutPropertiesLoose(props, [\"children\", \"config\", \"from\", \"to\", \"ref\", \"reset\", \"cancel\", \"reverse\", \"immediate\", \"delay\", \"lazy\", \"items\", \"trail\", \"unique\", \"initial\", \"enter\", \"leave\", \"update\", \"onAnimate\", \"onStart\", \"onRest\", \"onFrame\", \"onDestroyed\", \"timestamp\", \"attach\"]);\n\n  return forward;\n}\n\nfunction interpolateTo(props) {\n  const to = getForwardProps(props);\n  const out = {\n    to\n  };\n  each(props, (val, key) => key in to || (out[key] = val));\n  return out;\n}\n/**\r\n * This tries to put deleted items back into the given `out` list in correct\r\n * order. Deleted items must have a `left` and `right` property with key of\r\n * their sibling which is used to find the correct placement.\r\n */\n\nfunction reconcileDeleted(deleted, current) {\n  // Copy as we will be mutating the arrays\n  deleted = [...deleted];\n  current = [...current]; // Used to detect deadlock (when a pass finds 0 siblings)\n\n  let failedTries = 0; // Track where the current pass start/ends\n\n  let passIndex = 0;\n  let nextPassIndex = deleted.length; // Insert all deleted items into `current`\n\n  for (let i = 0; i < deleted.length; i++) {\n    if (i === nextPassIndex) {\n      // Sanity test: Push to end if somehow no siblings were found\n      if (passIndex + failedTries === nextPassIndex) {\n        for (let j = i; j < deleted.length; j++) {\n          const _deleted$j = deleted[j],\n                left = _deleted$j.left,\n                right = _deleted$j.right,\n                deletedItem = _objectWithoutPropertiesLoose(_deleted$j, [\"left\", \"right\"]);\n\n          current.push(deletedItem);\n        }\n\n        break;\n      } // Update local state at the end of each pass\n\n\n      passIndex = nextPassIndex;\n      nextPassIndex = deleted.length;\n      failedTries = 0;\n    } // The index of the deleted item in `current`\n\n\n    let index = -1; // Look for the left or right sibling in `current`\n\n    const _deleted$i = deleted[i],\n          left = _deleted$i.left,\n          right = _deleted$i.right,\n          deletedItem = _objectWithoutPropertiesLoose(_deleted$i, [\"left\", \"right\"]);\n\n    for (let j = current.length; --j >= 0;) {\n      const key = current[j].originalKey;\n\n      if (key === right) {\n        index = j;\n        break;\n      }\n\n      if (key === left) {\n        index = j + 1;\n        break;\n      }\n    } // Items with no index are revisited in the next pass\n\n\n    if (index < 0) {\n      failedTries++;\n      deleted.push(deleted[i]);\n    } else {\n      current.splice(index, 0, deletedItem);\n    }\n  }\n\n  return current;\n}\nfunction freeze(obj) {\n  if (typeof process !== 'undefined' && process.env.NODE_ENV === 'development') {\n    return Object.freeze(obj);\n  }\n\n  return obj;\n}\n\nconst linear = t => t;\n\nconst emptyObj = Object.freeze({});\nlet nextId = 1;\nclass Controller {\n  constructor(props) {\n    this.id = nextId++;\n    this.idle = true;\n    this.runCount = 0;\n    this.destroyed = false;\n    this.props = {};\n    this.queue = [];\n    this.timestamps = {};\n    this.values = {};\n    this.merged = {};\n    this.animated = {};\n    this.animations = {};\n    this.configs = [];\n    this.children = [];\n    this.onEndQueue = [];\n    this.cancelledAt = 0;\n    if (props) this.update(props).start();\n  }\n  /**\r\n   * Push props into the update queue. The props are used after `start` is\r\n   * called and any delay is over. The props are intelligently diffed to ensure\r\n   * that later calls to this method properly override any delayed props.\r\n   * The `propsArg` argument is always copied before mutations are made.\r\n   */\n\n\n  update(propsArg) {\n    if (!propsArg || this.destroyed) return this;\n    const props = interpolateTo(propsArg); // For async animations, the `from` prop must be defined for\n    // the Animated nodes to exist before animations have started.\n\n    this._ensureAnimated(props.from, true);\n\n    this._ensureAnimated(props.to);\n\n    props.timestamp = now(); // The `delay` prop of every update must be a number >= 0\n\n    if (is.fun(props.delay) && is.obj(props.to)) {\n      const from = props.from || emptyObj;\n\n      for (const key in props.to) {\n        this.queue.push(_extends({}, props, {\n          to: {\n            [key]: props.to[key]\n          },\n          from: key in from ? {\n            [key]: from[key]\n          } : void 0,\n          delay: Math.max(0, Math.round(props.delay(key)))\n        }));\n      }\n    } else {\n      props.delay = is.num(props.delay) ? Math.max(0, Math.round(props.delay)) : 0; // Coerce falsy values to undefined for these props\n\n      if (!props.to) props.to = void 0;\n      if (!props.from) props.from = void 0;\n      this.queue.push(props);\n    }\n\n    return this;\n  }\n  /**\r\n   * Flush the update queue, and call `onEnd` when they have settled.\r\n   *\r\n   * The `onEnd` callback does **not** wait for unsettled updates from previous `start` calls.\r\n   */\n\n\n  start(onEnd) {\n    if (this.queue.length) this._flush(onEnd);else if (onEnd) onEnd();\n    return this;\n  }\n  /** Stop one animation or all animations */\n\n\n  stop() {\n    for (var _len = arguments.length, keys = new Array(_len), _key = 0; _key < _len; _key++) {\n      keys[_key] = arguments[_key];\n    }\n\n    // Stop animations by key\n    if (keys.length) {\n      for (const key of keys) {\n        const index = this.configs.findIndex(config => key === config.key);\n\n        this._stopAnimation(key);\n\n        this.configs[index] = this.animations[key];\n      }\n    } // Stop all animations\n    else if (this.runCount) {\n        this.cancelledAt = now(); // Update the animation configs\n\n        each(this.configs, config => this._stopAnimation(config.key));\n        this.configs = Object.values(this.animations); // Exit the frameloop\n\n        if (!this.idle) {\n          this._stop();\n        }\n      }\n\n    return this;\n  }\n  /** Revert the controller to its initial state */\n\n\n  reset() {\n    // Stop all current animations\n    this.stop(); // Revert the internal state\n\n    this.destroyed = false;\n    this.props = {};\n    this.queue = [];\n    this.timestamps = {};\n    this.values = {};\n    this.merged = {};\n    this.animated = {};\n    this.animations = {};\n    this.configs = [];\n    return this;\n  }\n  /** Prevent all current and future animation */\n\n\n  destroy() {\n    if (!this.destroyed) {\n      this.stop();\n      this.destroyed = true;\n    }\n  }\n  /** @internal Called by the frameloop */\n\n\n  onFrame(_ref) {\n    let id = _ref[0],\n        idle = _ref[1],\n        changes = _ref[2];\n    if (id !== this.id) return;\n\n    if (changes && changes.length) {\n      for (const _ref2 of changes) {\n        const key = _ref2[0];\n        const value = _ref2[1];\n        this.values[key] = value;\n      } // The `onFrame` prop always exists when `changes` exists.\n\n\n      this.props.onFrame(_extends({}, this.values));\n    }\n\n    if (idle) {\n      this._stop();\n    }\n  }\n  /**\r\n   * Set a prop for the next animations where the prop is undefined. The given\r\n   * value is overridden by the next update where the prop is defined.\r\n   *\r\n   * Ongoing animations are not changed.\r\n   */\n\n\n  setProp(key, value) {\n    this.props[key] = value;\n    this.timestamps[key] = now();\n    return this;\n  }\n  /** @internal Get the `AnimatedValue` nodes for the given key */\n\n\n  getPayload(key) {\n    const anim = this.animations[key];\n    return anim && anim.animatedValues;\n  } // Create an Animated node if none exists.\n\n\n  _ensureAnimated(values, shouldUpdate) {\n    if (shouldUpdate === void 0) {\n      shouldUpdate = false;\n    }\n\n    if (!is.obj(values)) return;\n\n    for (const key in values) {\n      const value = values[key];\n      let animated = this.animated[key];\n\n      if (animated && shouldUpdate && this.animations[key].isNew) {\n        // Ensure the initial value is up-to-date.\n        if (animated.setValue) {\n          animated.setValue(computeGoalValue(value));\n        } else {\n          // Derived nodes need to be swapped out.\n          animated = null;\n        }\n      }\n\n      if (!animated) {\n        animated = createAnimated(value);\n\n        if (this.animated[key]) {\n          // Swap out the old node with the new node.\n          moveChildren(this.animated[key], animated);\n        }\n\n        this.animated[key] = animated;\n\n        this._stopAnimation(key, true);\n      }\n    }\n  } // Add this controller to the frameloop.\n\n\n  _start(onEnd) {\n    if (this.idle) {\n      if (this.configs.some(config => !config.idle)) {\n        this.idle = false;\n        frameLoop.start(this);\n      } else if (onEnd) {\n        return onEnd();\n      }\n    }\n\n    if (onEnd) {\n      this.onEndQueue.push(onEnd);\n    }\n  } // Attach our children to the given keys if possible.\n\n\n  _attach(keys, visited) {\n    if (visited === void 0) {\n      visited = {};\n    }\n\n    each(this.children, c => {\n      if (visited[this.id]) return;\n      visited[this.id] = true;\n      const attached = keys.filter(key => {\n        const payload = c.getPayload(key);\n\n        if (payload) {\n          each(payload, node => node.done && node.reset(true));\n          return true;\n        }\n      });\n\n      if (attached.length) {\n        c._attach(attached, visited);\n\n        c._start();\n      }\n    });\n  } // Remove this controller from the frameloop, and notify any listeners.\n\n\n  _stop() {\n    this.idle = true;\n    frameLoop.stop(this);\n    const onRest = this.props.onRest;\n\n    if (is.fun(onRest)) {\n      onRest(this.merged);\n    }\n\n    const onEndQueue = this.onEndQueue;\n\n    if (onEndQueue.length) {\n      this.onEndQueue = [];\n      each(onEndQueue, onEnd => onEnd());\n    }\n  } // Execute the current queue of prop updates.\n\n\n  _flush(onEnd) {\n    const queue = this.queue.reduce(reduceDelays, []);\n    this.queue.length = 0; // Track the number of unsettled updates.\n\n    let runsLeft = Object.keys(queue).length;\n    this.runCount += runsLeft; // Any run can finish last.\n\n    const onRunEnd = () => {\n      this.runCount--;\n\n      if (! --runsLeft && onEnd) {\n        onEnd();\n      }\n    };\n\n    each(queue, (props, delay) => {\n      if (delay) {\n        setTimeout(() => {\n          // Cancelling methods touch the `cancelledAt` property\n          if (props.timestamp < this.cancelledAt) return;\n\n          this._run(props, onRunEnd);\n        }, delay);\n      } else {\n        this._run(props, onRunEnd);\n      }\n    });\n  } // Update the props and animations\n\n\n  _run(props, onEnd) {\n    if (is.arr(props.to) || is.fun(props.to)) {\n      this._runAsync(props, onEnd);\n    } else if (this._diff(props)) {\n      this._animate(props)._start(onEnd);\n    } else {\n      onEnd();\n    }\n  } // Start an async chain or an async script.\n\n\n  _runAsync(_ref3, onEnd) {\n    let to = _ref3.to,\n        props = _objectWithoutPropertiesLoose(_ref3, [\"to\"]);\n\n    // Merge other props immediately.\n    if (this._diff(props)) {\n      this._animate(props);\n    } // Async scripts can be declaratively cancelled.\n\n\n    if (props.cancel === true) {\n      this.props.asyncTo = void 0;\n      return onEnd();\n    } // Never run more than one script at a time\n\n\n    const timestamp = props.timestamp;\n\n    if (!this._diff({\n      asyncTo: to,\n      timestamp\n    })) {\n      return onEnd();\n    }\n\n    const isCancelled = () => // Cancelling methods touch the `cancelledAt` property\n    timestamp < this.cancelledAt || // Async scripts are also cancelled when a new chain/script begins\n    is.fun(to) && to !== this.props.asyncTo;\n\n    let last;\n\n    const next = props => {\n      if (isCancelled()) throw this;\n      return (last = new Promise(done => {\n        this.update(props).start(done);\n      })).then(() => {\n        if (isCancelled()) throw this;\n      });\n    };\n\n    let queue = Promise.resolve();\n\n    if (is.arr(to)) {\n      each(to, props => {\n        queue = queue.then(() => next(props));\n      });\n    } else if (is.fun(to)) {\n      queue = queue.then(() => to(next, this.stop.bind(this)) // Always wait for the last update.\n      .then(() => last));\n    }\n\n    queue.catch(err => err !== this && console.error(err)).then(onEnd);\n  } // Merge every fresh prop. Returns true if one or more props changed.\n  // These props cannot trigger an update by themselves:\n  //   [delay, config, immediate, reverse, attach]\n\n\n  _diff(_ref4) {\n    let timestamp = _ref4.timestamp,\n        delay = _ref4.delay,\n        config = _ref4.config,\n        immediate = _ref4.immediate,\n        reverse = _ref4.reverse,\n        attach = _ref4.attach,\n        props = _objectWithoutPropertiesLoose(_ref4, [\"timestamp\", \"delay\", \"config\", \"immediate\", \"reverse\", \"attach\"]);\n\n    let changed = false; // Generalized diffing algorithm\n\n    const diffProp = (keys, value, owner) => {\n      if (is.und(value)) return;\n      const lastKey = keys[keys.length - 1];\n\n      if (is.obj(value)) {\n        if (!is.obj(owner[lastKey])) owner[lastKey] = {};\n\n        for (const key in value) {\n          diffProp(keys.concat(key), value[key], owner[lastKey]);\n        }\n      } else {\n        const keyPath = keys.join('.');\n        const oldTimestamp = this.timestamps[keyPath];\n\n        if (is.und(oldTimestamp) || timestamp >= oldTimestamp) {\n          this.timestamps[keyPath] = timestamp;\n          const oldValue = owner[lastKey];\n\n          if (!isEqual(value, oldValue)) {\n            changed = true;\n            owner[lastKey] = value;\n          }\n        }\n      }\n    };\n\n    if (reverse) {\n      const to = props.to;\n      props.to = props.from;\n      props.from = is.obj(to) ? to : void 0;\n    } // The \"attach\" prop is called on every diff. It overwrites the \"parent\" prop.\n\n\n    props.parent = (attach ? attach(this) : props.parent) || null;\n    const oldParent = this.props.parent || null;\n\n    if (props.parent !== oldParent) {\n      if (oldParent) oldParent.children.splice(oldParent.children.indexOf(this), 1);\n      if (props.parent) props.parent.children.push(this);\n    }\n\n    for (const key in props) {\n      diffProp([key], props[key], this.props);\n    } // These props only affect one update\n\n\n    if ('reset' in props) this.props.reset = false;\n    if ('cancel' in props) this.props.cancel = void 0;\n    return changed;\n  } // Return true if the given prop was changed by this update\n\n\n  _isModified(props, prop) {\n    return this.timestamps[prop] === props.timestamp;\n  } // Update the animation configs. The given props override any default props.\n\n\n  _animate(props) {\n    const _this$props = this.props,\n          _this$props$from = _this$props.from,\n          from = _this$props$from === void 0 ? emptyObj : _this$props$from,\n          _this$props$to = _this$props.to,\n          to = _this$props$to === void 0 ? emptyObj : _this$props$to,\n          parent = _this$props.parent,\n          onAnimate = _this$props.onAnimate,\n          onStart = _this$props.onStart;\n\n    if (is.fun(onAnimate)) {\n      onAnimate(props, this);\n    }\n\n    let isPrevented = _ => false;\n\n    if (props.cancel && this._isModified(props, 'cancel')) {\n      // Stop all animations when `cancel` is true\n      if (props.cancel === true) {\n        this.stop(); // Prevent pending updates from *before* this update only!\n        // (This must come after the `stop` call above)\n\n        this.cancelledAt = props.timestamp;\n        return this;\n      } // Prevent matching properties from animating when\n      // `cancel` is a string or array of strings\n\n\n      const keys = toArray(props.cancel);\n\n      if (is.arr(keys) && keys.length) {\n        isPrevented = key => keys.indexOf(key) >= 0;\n\n        this.stop(...keys);\n      }\n    } // Merge `from` values with `to` values\n\n\n    this.merged = freeze(_extends({}, from, to)); // True if any animation was updated\n\n    let changed = false; // The animations that are starting or restarting\n\n    const started = []; // Attach when a new \"parent\" controller exists.\n\n    const isAttaching = parent && this._isModified(props, 'parent'); // Reduces input { key: value } pairs into animation objects\n\n\n    for (const key in this.merged) {\n      if (isPrevented(key)) continue;\n      const state = this.animations[key];\n\n      if (!state) {\n        console.warn(`Failed to animate key: \"${key}\"\\n` + `Did you forget to define \"from.${key}\" for an async animation?`);\n        continue;\n      } // Reuse the Animated nodes whenever possible\n\n\n      let animated = state.animated,\n          animatedValues = state.animatedValues;\n      const value = this.merged[key];\n      const goalValue = computeGoalValue(value);\n      const currValue = animated.getValue(); // Stop animations with a goal value equal to its current value.\n\n      if (!props.reset && !isAttaching && isEqual(goalValue, currValue)) {\n        // The animation might be stopped already.\n        if (!state.idle) {\n          changed = true;\n\n          this._stopAnimation(key);\n        }\n\n        continue;\n      } // Replace an animation when its goal value is changed (or it's been reset)\n\n\n      if (props.reset || isAttaching || !isEqual(goalValue, state.isNew ? currValue : state.goalValue)) {\n        const immediate = !!callProp((is.und(props.immediate) ? this.props : props).immediate, key);\n        const isActive = animatedValues.some(node => !node.done);\n        const fromValue = !is.und(from[key]) ? computeGoalValue(from[key]) : goalValue; // Animatable strings use interpolation\n\n        const isInterpolated = isAnimatableString(value);\n\n        if (isInterpolated) {\n          const output = [props.reset ? fromValue : currValue, goalValue];\n          let input = animatedValues[0];\n\n          if (input) {\n            input.setValue(0, false);\n            input.reset(isActive);\n          } else {\n            input = new AnimatedValue(0);\n          }\n\n          try {\n            const prev = animated;\n            animated = input.to({\n              output\n            });\n            moveChildren(prev, animated);\n          } catch (err) {\n            console.warn('Failed to interpolate string from \"%s\" to \"%s\"', output[0], output[1]);\n            console.error(err);\n            continue;\n          }\n\n          if (skipAnimation) {\n            input.setValue(1);\n\n            this._stopAnimation(key);\n\n            continue;\n          }\n\n          if (immediate) {\n            input.setValue(1, false);\n          }\n        } else {\n          // Convert values into Animated nodes (reusing nodes whenever possible)\n          if (is.arr(value)) {\n            if (animated instanceof AnimatedArray) {\n              if (props.reset) animated.setValue(fromValue, false);\n              each(animatedValues, node => node.reset(isActive));\n            } else {\n              const prev = animated;\n              animated = createAnimated(fromValue);\n              moveChildren(prev, animated);\n            }\n          } else {\n            if (animated instanceof AnimatedValue) {\n              if (props.reset) animated.setValue(fromValue, false);\n              animated.reset(isActive);\n            } else {\n              const prev = animated;\n              animated = new AnimatedValue(fromValue);\n              moveChildren(prev, animated);\n            }\n          }\n\n          if (skipAnimation) {\n            animated.setValue(goalValue);\n\n            this._stopAnimation(key);\n\n            continue;\n          }\n\n          if (immediate) {\n            animated.setValue(goalValue, false);\n          }\n        } // Only change the \"config\" of updated animations.\n\n\n        const config = callProp(props.config, key) || callProp(this.props.config, key) || emptyObj;\n\n        if (!(immediate || skipAnimation)) {\n          started.push(key);\n        }\n\n        const fromValues = animatedValues.map(v => v.getValue());\n        const toValues = parent && parent.getPayload(key) || toArray(isInterpolated ? 1 : goalValue);\n        changed = true;\n        this.animations[key] = {\n          key,\n          idle: false,\n          goalValue,\n          toValues,\n          fromValues,\n          animated,\n          animatedValues: Array.from(animated.getPayload()),\n          immediate,\n          duration: config.duration,\n          easing: withDefault(config.easing, linear),\n          decay: config.decay,\n          mass: withDefault(config.mass, 1),\n          tension: withDefault(config.tension, 170),\n          friction: withDefault(config.friction, 26),\n          initialVelocity: withDefault(config.velocity, 0),\n          clamp: withDefault(config.clamp, false),\n          precision: withDefault(config.precision, 0.005),\n          config\n        };\n      }\n    }\n\n    if (changed) {\n      if (started.length) {\n        this._attach(started);\n\n        if (is.fun(onStart)) each(started, key => {\n          onStart(this.animations[key]);\n        });\n      } // Make animations available to the frameloop\n\n\n      const keys = Object.keys(this.animations);\n      this.configs.length = keys.length;\n      each(keys, (key, i) => {\n        const config = this.animations[key];\n        this.configs[i] = config;\n        this.values[key] = config.animated.getValue();\n        this.animated[key] = config.animated;\n      });\n    }\n\n    return this;\n  }\n  /**\r\n   * Stop an animation by its key.\r\n   *\r\n   * This mutates the `timestamps.to[key]`, `props.to[key]`, and `animations[key]` properties.\r\n   * Notably, it does *not* mutate the `configs[key]` or `animated[key]` properties.\r\n   */\n\n\n  _stopAnimation(key, isNew) {\n    const animated = this.animated[key];\n\n    if (!animated) {\n      return console.warn(`Cannot stop an animation for a key that isn't animated: \"${key}\"`);\n    } // Prevent any pending updates to this key\n\n\n    this.timestamps['to.' + key] = now(); // Idle animations are skipped unless their Animated node changed\n\n    const state = this.animations[key] || emptyObj;\n    if (state.idle && animated === state.animated) return; // Use the previous `isNew` value if nothing was passed\n\n    if (is.und(isNew)) {\n      isNew = !!state.isNew;\n    } // Tell the frameloop to skip animating these values\n\n\n    const animatedValues = Array.from(animated.getPayload());\n    each(animatedValues, node => {\n      node.done = true;\n    }); // The current value becomes the goal value,\n    // which ensures the integrity of the diffing algorithm.\n\n    const goalValue = animated.getValue();\n\n    if (this.props.to) {\n      this.props.to[key] = goalValue;\n    } // Remove unused data from this key's animation config\n\n\n    this.animations[key] = {\n      key,\n      idle: true,\n      isNew,\n      goalValue,\n      animated,\n      animatedValues\n    };\n  }\n\n}\n/** Wrap any value with an `Animated` node */\n\nfunction createAnimated(value) {\n  return is.arr(value) ? new AnimatedArray(value.map(createAnimated)) : isAnimatableString(value) ? // Convert \"red\" into \"rgba(255, 0, 0, 1)\" etc\n  new AnimatedValue(0).to({\n    output: [value, value]\n  }) : // The `AnimatedValue` class supports any type, but only numbers are\n  // interpolated by the frameloop.\n  new AnimatedValue(value);\n}\n/**\r\n * Replace an `Animated` node in the graph.\r\n * This is most useful for async updates, which don't cause a re-render.\r\n */\n\n\nfunction moveChildren(prev, next) {\n  each(Array.from(prev.getChildren()), child => {\n    child.updatePayload(prev, next);\n    prev.removeChild(child);\n    next.addChild(child);\n  });\n} // Merge updates with the same delay.\n// NOTE: Mutation of `props` may occur!\n\n\nfunction reduceDelays(merged, props) {\n  const prev = merged[props.delay];\n\n  if (prev) {\n    props.to = merge(prev.to, props.to);\n    props.from = merge(prev.from, props.from);\n    Object.assign(prev, props);\n  } else {\n    merged[props.delay] = props;\n  }\n\n  return merged;\n}\n\nfunction merge(dest, src) {\n  return is.obj(dest) && is.obj(src) ? _extends({}, dest, src) : src || dest;\n} // Not all strings can be animated (eg: {display: \"none\"})\n\n\nfunction isAnimatableString(value) {\n  if (!is.str(value)) return false;\n  return value.startsWith('#') || /\\d/.test(value) || !!(colorNames && colorNames[value]);\n} // Compute the goal value, converting \"red\" to \"rgba(255, 0, 0, 1)\" in the process\n\n\nfunction computeGoalValue(value) {\n  return is.arr(value) ? value.map(computeGoalValue) : isAnimatableString(value) ? createStringInterpolator({\n    range: [0, 1],\n    output: [value, value]\n  })(1) : value;\n} // Compare animatable values\n\n\nfunction isEqual(a, b) {\n  if (is.arr(a)) {\n    if (!is.arr(b) || a.length !== b.length) return false;\n\n    for (let i = 0; i < a.length; i++) {\n      if (a[i] !== b[i]) return false;\n    }\n\n    return true;\n  }\n\n  return a === b;\n}\n\n/** API\n * const props = useSprings(number, [{ ... }, { ... }, ...])\n * const [props, set] = useSprings(number, (i, controller) => ({ ... }))\n */\n\nconst useSprings = (length, propsArg, deps) => {\n  const hasNewSprings = length !== usePrev(length);\n  const isFn = is.fun(propsArg);\n  const state = useRef({\n    springs: [],\n    ref: null\n  }).current; // The `propsArg` coerced into an array\n\n  const props = isFn ? [] : propsArg; // Recreate the controllers whenever `length` changes\n\n  const springs = useMemoOne(() => fillArray(length, i => {\n    const s = new Controller();\n    const p = props[i] || (props[i] = callProp(propsArg, i, s));\n    return s.update(p);\n  }), [length]);\n\n  const _useMemo = useMemo(() => ({\n    /** Apply any pending updates */\n    start: () => Promise.all(state.springs.map(s => new Promise(done => s.start(done)))),\n\n    /** Update the spring controllers */\n    update: props => {\n      const isFn = is.fun(props);\n      const isArr = is.arr(props);\n      state.springs.forEach((spring, i) => {\n        spring.update(isFn ? callProp(props, i, spring) : isArr ? props[i] : props);\n        if (!state.ref) spring.start();\n      });\n    },\n\n    /** Stop one key or all keys from animating */\n    stop: function stop() {\n      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n        args[_key] = arguments[_key];\n      }\n\n      return state.springs.forEach(s => s.stop(...args));\n    }\n  }), []),\n        start = _useMemo.start,\n        update = _useMemo.update,\n        stop = _useMemo.stop;\n\n  const ref = props[0] ? props[0].ref : isFn ? state.ref : null;\n  useImperativeHandle(ref, () => ({\n    start,\n    stop,\n\n    get controllers() {\n      return state.springs;\n    }\n\n  })); // Once mounted, update the local state and start any animations.\n\n  useEffect(() => {\n    if (!isFn || hasNewSprings) {\n      props.forEach((p, i) => {\n        // Set default props for async updates\n        springs[i].setProp('config', p.config);\n        springs[i].setProp('immediate', p.immediate);\n      });\n    }\n\n    if (hasNewSprings) {\n      state.springs.forEach(s => s.destroy());\n      state.springs = springs;\n      state.ref = ref;\n\n      if (!ref) {\n        springs.forEach(s => s.start());\n      }\n    } else if (!isFn) {\n      update(props);\n    }\n  }, deps); // Destroy the controllers on unmount\n\n  useOnce(() => () => {\n    state.springs.forEach(s => s.destroy());\n  });\n  const values = springs.map(s => _extends({}, s.animated));\n  return isFn ? [values, update, stop] : values;\n};\n\n/** API\n * const props = useSpring({ ... })\n * const [props, set] = useSpring(() => ({ ... }))\n */\n\nconst useSpring = (props, deps) => {\n  const isFn = is.fun(props);\n\n  const _useSprings = useSprings(1, isFn ? props : [props], deps),\n        result = _useSprings[0],\n        set = _useSprings[1],\n        stop = _useSprings[2];\n\n  return isFn ? [result[0], set, stop] : result;\n};\n\n/** API\n * const trails = useTrail(number, { ... })\n * const [trails, set] = useTrail(number, () => ({ ... }))\n */\n\nconst useTrail = (length, propsArg) => {\n  const hasNewSprings = length !== usePrev(length);\n  const isFn = is.fun(propsArg); // The `propsArg` coerced into an object\n\n  let props = isFn ? null : propsArg; // Retain the controllers so we can update them.\n\n  const springsRef = useRef([]);\n  const springs = springsRef.current;\n  if (hasNewSprings) springs.length = length; // The controllers are recreated whenever `length` changes.\n\n  const _useSprings = useSprings(length, (i, spring) => {\n    if (isFn && !props) {\n      props = callProp(propsArg, spring) || {};\n    }\n\n    springs[i] = spring;\n    return _extends({}, props, i > 0 && {\n      attach: () => springs[i - 1],\n      onStart: withArgument(props.onStart, i),\n      onFrame: withArgument(props.onFrame, i),\n      onRest: withArgument(props.onRest, i)\n    }, {\n      config: callProp(props.config, i)\n    });\n  }),\n        values = _useSprings[0],\n        animate = _useSprings[1],\n        stop = _useSprings[2];\n  /** For imperative updates to the props of all springs in the trail */\n\n\n  const update = useCallbackOne(propsArg => animate((i, spring) => {\n    const props = callProp(propsArg, i, spring) || {};\n    const parent = springsRef.current[props.reverse ? i + 1 : i - 1];\n    return _extends({}, props, {\n      attach: () => parent,\n      config: callProp(props.config, i)\n    });\n  }), []); // Update the animations on re-render when `propsArg` is an object\n  // and the controllers were *not* created in the current render.\n\n  useEffect(() => {\n    if (!isFn && !hasNewSprings) {\n      update(propsArg);\n    }\n  }); // Return the update/stop functions when the `propsArg` is a function.\n\n  return isFn ? [values, update, stop] : values;\n};\n\nfunction withArgument(fn, arg) {\n  return is.fun(fn) ? function () {\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    return fn(...args, arg);\n  } : fn;\n}\n\n/** API\n * const transitions = useTransition(items, itemKeys, { ... })\n * const [transitions, update] = useTransition(items, itemKeys, () => ({ ... }))\n */\n\nlet guid = 0;\nconst INITIAL = 'initial';\nconst ENTER = 'enter';\nconst UPDATE = 'update';\nconst LEAVE = 'leave';\n\nconst makeKeys = (items, keys) => (typeof keys === 'function' ? items.map(keys) : toArray(keys)).map(String);\n\nconst makeConfig = props => {\n  let items = props.items,\n      keys = props.keys,\n      rest = _objectWithoutPropertiesLoose(props, [\"items\", \"keys\"]);\n\n  items = toArray(is.und(items) ? null : items);\n  return _extends({\n    items,\n    keys: makeKeys(items, keys)\n  }, rest);\n};\n\nfunction useTransition(input, keyTransform, props) {\n  props = makeConfig(_extends({}, props, {\n    items: input,\n    keys: keyTransform || (i => i)\n  }));\n\n  const _props = props,\n        _props$lazy = _props.lazy,\n        lazy = _props$lazy === void 0 ? false : _props$lazy,\n        _props$unique = _props.unique,\n        from = _props.from,\n        enter = _props.enter,\n        leave = _props.leave,\n        update = _props.update,\n        onDestroyed = _props.onDestroyed,\n        keys = _props.keys,\n        items = _props.items,\n        onFrame = _props.onFrame,\n        _onRest = _props.onRest,\n        onStart = _props.onStart,\n        ref = _props.ref,\n        extra = _objectWithoutPropertiesLoose(_props, [\"lazy\", \"unique\", \"from\", \"enter\", \"leave\", \"update\", \"onDestroyed\", \"keys\", \"items\", \"onFrame\", \"onRest\", \"onStart\", \"ref\"]);\n\n  const forceUpdate = useForceUpdate();\n  const mounted = useRef(false);\n  const state = useRef({\n    mounted: false,\n    first: true,\n    deleted: [],\n    current: {},\n    transitions: [],\n    prevProps: {},\n    paused: !!ref,\n    instances: !mounted.current && new Map(),\n    forceUpdate\n  });\n  useImperativeHandle(ref, () => ({\n    start: () => Promise.all(Array.from(state.current.instances).map((_ref) => {\n      let c = _ref[1];\n      return new Promise(r => c.start(r));\n    })),\n    stop: finished => Array.from(state.current.instances).forEach((_ref2) => {\n      let c = _ref2[1];\n      return c.stop(finished);\n    }),\n\n    get controllers() {\n      return Array.from(state.current.instances).map((_ref3) => {\n        let c = _ref3[1];\n        return c;\n      });\n    }\n\n  })); // Update state\n\n  state.current = diffItems(state.current, props);\n\n  if (state.current.changed) {\n    // Update state\n    state.current.transitions.forEach(transition => {\n      const phase = transition.phase,\n            key = transition.key,\n            item = transition.item,\n            props = transition.props;\n      if (!state.current.instances.has(key)) state.current.instances.set(key, new Controller()); // Avoid calling `onStart` more than once per transition.\n\n      let started = false; // update the map object\n\n      const ctrl = state.current.instances.get(key);\n\n      const itemProps = _extends({}, extra, props, {\n        onRest: values => {\n          if (state.current.mounted) {\n            if (transition.destroyed) {\n              // If no ref is given delete destroyed items immediately\n              if (!ref && !lazy) cleanUp(state, key);\n              if (onDestroyed) onDestroyed(item);\n            } // A transition comes to rest once all its springs conclude\n\n\n            const curInstances = Array.from(state.current.instances);\n            const active = curInstances.some((_ref4) => {\n              let c = _ref4[1];\n              return !c.idle;\n            });\n\n            if (!active && (ref || lazy) && state.current.deleted.length > 0) {\n              cleanUp(state);\n            }\n\n            if (is.fun(_onRest)) {\n              _onRest(item, phase, values);\n            }\n          }\n        },\n        onFrame: is.fun(onFrame) && (values => onFrame(item, phase, values)),\n        onStart: is.fun(onStart) && (animation => started || (started = (onStart(item, phase, animation), true))) // Update controller\n\n      });\n\n      ctrl.update(itemProps);\n      if (!state.current.paused) ctrl.start();\n    });\n  }\n\n  useOnce(() => {\n    state.current.mounted = mounted.current = true;\n    return () => {\n      state.current.mounted = mounted.current = false;\n      Array.from(state.current.instances).map((_ref5) => {\n        let c = _ref5[1];\n        return c.destroy();\n      });\n      state.current.instances.clear();\n    };\n  });\n  return state.current.transitions.map((_ref6) => {\n    let item = _ref6.item,\n        phase = _ref6.phase,\n        key = _ref6.key;\n    return {\n      item,\n      key,\n      phase,\n      props: _extends({}, state.current.instances.get(key).animated)\n    };\n  });\n}\n\nfunction cleanUp(_ref7, filterKey) {\n  let state = _ref7.current;\n  const deleted = state.deleted;\n\n  for (let _ref8 of deleted) {\n    let key = _ref8.key;\n\n    const filter = t => t.key !== key;\n\n    if (is.und(filterKey) || filterKey === key) {\n      state.instances.delete(key);\n      state.transitions = state.transitions.filter(filter);\n      state.deleted = state.deleted.filter(filter);\n    }\n  }\n\n  state.forceUpdate();\n}\n\nfunction diffItems(_ref9, props) {\n  let first = _ref9.first,\n      current = _ref9.current,\n      deleted = _ref9.deleted,\n      prevProps = _ref9.prevProps,\n      state = _objectWithoutPropertiesLoose(_ref9, [\"first\", \"current\", \"deleted\", \"prevProps\"]);\n\n  let items = props.items,\n      keys = props.keys,\n      initial = props.initial,\n      from = props.from,\n      enter = props.enter,\n      leave = props.leave,\n      update = props.update,\n      _props$trail = props.trail,\n      trail = _props$trail === void 0 ? 0 : _props$trail,\n      unique = props.unique,\n      config = props.config,\n      _props$order = props.order,\n      order = _props$order === void 0 ? [ENTER, LEAVE, UPDATE] : _props$order;\n\n  let _makeConfig = makeConfig(prevProps),\n      _keys = _makeConfig.keys,\n      _items = _makeConfig.items;\n\n  if (props.reset) {\n    current = {};\n    state.transitions = [];\n  } // Compare next keys with current keys\n\n\n  const currentKeys = Object.keys(current);\n  const currentSet = new Set(currentKeys);\n  const nextSet = new Set(keys);\n  const addedKeys = keys.filter(key => !currentSet.has(key));\n  const updatedKeys = update ? keys.filter(key => currentSet.has(key)) : [];\n  const deletedKeys = state.transitions.filter(t => !t.destroyed && !nextSet.has(t.originalKey)).map(t => t.originalKey);\n  let delay = -trail;\n\n  while (order.length) {\n    let phase = order.shift();\n\n    if (phase === ENTER) {\n      if (first && !is.und(initial)) {\n        phase = INITIAL;\n        from = initial;\n      }\n\n      addedKeys.forEach(key => {\n        // In unique mode, remove fading out transitions if their key comes in again\n        if (unique && deleted.find(d => d.originalKey === key)) {\n          deleted = deleted.filter(t => t.originalKey !== key);\n        }\n\n        const i = keys.indexOf(key);\n        const item = items[i];\n        const enterProps = callProp(enter, item, i);\n        current[key] = {\n          phase,\n          originalKey: key,\n          key: unique ? String(key) : guid++,\n          item,\n          props: _extends({\n            delay: delay += trail,\n            config: callProp(config, item, phase),\n            from: callProp(from, item, i),\n            to: enterProps\n          }, is.obj(enterProps) && interpolateTo(enterProps))\n        };\n      });\n    } else if (phase === LEAVE) {\n      deletedKeys.forEach(key => {\n        const i = _keys.indexOf(key);\n\n        const item = _items[i];\n        const leaveProps = callProp(leave, item, i);\n        deleted.push(_extends({}, current[key], {\n          phase,\n          destroyed: true,\n          left: _keys[i - 1],\n          right: _keys[i + 1],\n          props: _extends({\n            delay: delay += trail,\n            config: callProp(config, item, phase),\n            to: leaveProps\n          }, is.obj(leaveProps) && interpolateTo(leaveProps))\n        }));\n        delete current[key];\n      });\n    } else if (phase === UPDATE) {\n      updatedKeys.forEach(key => {\n        const i = keys.indexOf(key);\n        const item = items[i];\n        const updateProps = callProp(update, item, i);\n        current[key] = _extends({}, current[key], {\n          phase,\n          props: _extends({\n            delay: delay += trail,\n            config: callProp(config, item, phase),\n            to: updateProps\n          }, is.obj(updateProps) && interpolateTo(updateProps))\n        });\n      });\n    }\n  }\n\n  let out = keys.map(key => current[key]);\n  out = reconcileDeleted(deleted, out);\n  return _extends({}, state, {\n    first: first && !addedKeys.length,\n    changed: !!(addedKeys.length || deletedKeys.length || updatedKeys.length),\n    transitions: out,\n    current,\n    deleted,\n    prevProps: props\n  });\n}\n\nfunction Spring(_ref) {\n  let children = _ref.children,\n      props = _objectWithoutPropertiesLoose(_ref, [\"children\"]);\n\n  return children(useSpring(props));\n}\nfunction Trail(_ref2) {\n  let items = _ref2.items,\n      children = _ref2.children,\n      props = _objectWithoutPropertiesLoose(_ref2, [\"items\", \"children\"]);\n\n  const trails = useTrail(items.length, props);\n  return items.map((item, index) => {\n    const result = children(item, index);\n    return is.fun(result) ? result(trails[index]) : result;\n  });\n}\nfunction Transition(_ref3) {\n  let items = _ref3.items,\n      _ref3$keys = _ref3.keys,\n      keys = _ref3$keys === void 0 ? null : _ref3$keys,\n      children = _ref3.children,\n      props = _objectWithoutPropertiesLoose(_ref3, [\"items\", \"keys\", \"children\"]);\n\n  const transitions = useTransition(items, keys, props);\n  return transitions.map((_ref4, index) => {\n    let item = _ref4.item,\n        key = _ref4.key,\n        props = _ref4.props,\n        phase = _ref4.phase;\n    const result = children(item, phase, index);\n    const element = is.fun(result) ? result(props) : result;\n    return element && element.type ? React.createElement(element.type, _extends({}, element.props, {\n      key: key,\n      ref: element.ref\n    })) : element;\n  });\n}\n\nclass FrameLoop {\n  constructor(_temp) {\n    let _ref = _temp === void 0 ? {} : _temp,\n        update = _ref.update,\n        onFrame = _ref.onFrame,\n        requestFrame = _ref.requestFrame;\n\n    /**\r\n     * On each frame, these controllers are searched for values to animate.\r\n     */\n    this.controllers = new Map();\n    /**\r\n     * True when no controllers are animating.\r\n     */\n\n    this.idle = true;\n\n    this.requestFrame = // The global `requestAnimationFrame` must be dereferenced to avoid \"Illegal invocation\" errors\n    requestFrame || (fn => (0, requestAnimationFrame)(fn));\n\n    this.onFrame = onFrame && onFrame.bind(this) || (updates => {\n      updates.forEach(update => {\n        const ctrl = this.controllers.get(update[0]);\n        if (ctrl) ctrl.onFrame(update);\n      });\n    });\n\n    this.update = update && update.bind(this) || (() => {\n      if (this.idle) {\n        return false;\n      } // Update the animations.\n\n\n      const updates = [];\n\n      for (const id of Array.from(this.controllers.keys())) {\n        let idle = true;\n        const ctrl = this.controllers.get(id);\n        const changes = ctrl.props.onFrame ? [] : null;\n\n        for (const config of ctrl.configs) {\n          if (config.idle) continue;\n\n          if (this.advance(config, changes)) {\n            idle = false;\n          }\n        }\n\n        updates.push([id, idle, changes]);\n      } // Notify the controllers!\n\n\n      this.onFrame(updates); // Are we done yet?\n\n      if (!this.controllers.size) {\n        return !(this.idle = true);\n      } // Keep going.\n\n\n      this.requestFrame(this.update);\n      return true;\n    });\n  }\n\n  start(ctrl) {\n    this.controllers.set(ctrl.id, ctrl);\n\n    if (this.idle) {\n      this.idle = false;\n      this.requestFrame(this.update);\n    }\n  }\n\n  stop(ctrl) {\n    this.controllers.delete(ctrl.id);\n  }\n  /** Advance an animation forward one frame. */\n\n\n  advance(config, changes) {\n    const time = now();\n    let active = false;\n    let changed = false;\n\n    for (let i = 0; i < config.animatedValues.length; i++) {\n      const animated = config.animatedValues[i];\n      if (animated.done) continue;\n      changed = true;\n      let to = config.toValues[i];\n      const target = to instanceof Animated ? to : null;\n      if (target) to = target.getValue(); // Jump to end value for immediate animations\n\n      if (config.immediate) {\n        animated.setValue(to);\n        animated.done = true;\n        continue;\n      }\n\n      const from = config.fromValues[i];\n      const startTime = animated.startTime; // Break animation when string values are involved\n\n      if (typeof from === 'string' || typeof to === 'string') {\n        animated.setValue(to);\n        animated.done = true;\n        continue;\n      }\n\n      let finished = false;\n      let position = animated.lastPosition;\n      let velocity = Array.isArray(config.initialVelocity) ? config.initialVelocity[i] : config.initialVelocity; // Duration easing\n\n      if (config.duration !== void 0) {\n        position = from + config.easing((time - startTime) / config.duration) * (to - from);\n        finished = time >= startTime + config.duration;\n      } // Decay easing\n      else if (config.decay) {\n          const decay = config.decay === true ? 0.998 : config.decay;\n          position = from + velocity / (1 - decay) * (1 - Math.exp(-(1 - decay) * (time - startTime)));\n          finished = Math.abs(animated.lastPosition - position) < 0.1;\n          if (finished) to = position;\n        } // Spring easing\n        else {\n            let lastTime = animated.lastTime !== void 0 ? animated.lastTime : time;\n\n            if (animated.lastVelocity !== void 0) {\n              velocity = animated.lastVelocity;\n            } // If we lost a lot of frames just jump to the end.\n\n\n            if (time > lastTime + 64) lastTime = time; // http://gafferongames.com/game-physics/fix-your-timestep/\n\n            const numSteps = Math.floor(time - lastTime);\n\n            for (let n = 0; n < numSteps; ++n) {\n              const force = -config.tension * (position - to);\n              const damping = -config.friction * velocity;\n              const acceleration = (force + damping) / config.mass;\n              velocity = velocity + acceleration * 1 / 1000;\n              position = position + velocity * 1 / 1000;\n            }\n\n            animated.lastTime = time;\n            animated.lastVelocity = velocity; // Conditions for stopping the spring animation\n\n            const isOvershooting = config.clamp && config.tension !== 0 ? from < to ? position > to : position < to : false;\n            const isVelocity = Math.abs(velocity) <= config.precision;\n            const isDisplacement = config.tension !== 0 ? Math.abs(to - position) <= config.precision : true;\n            finished = isOvershooting || isVelocity && isDisplacement;\n          } // Trails aren't done until their parents conclude\n\n\n      if (finished && !(target && !target.done)) {\n        // Ensure that we end up with a round value\n        if (animated.value !== to) position = to;\n        animated.done = true;\n      } else {\n        active = true;\n      }\n\n      animated.setValue(position);\n      animated.lastPosition = position;\n    }\n\n    if (changes && changed) {\n      changes.push([config.key, config.animated.getValue()]);\n    }\n\n    return active;\n  }\n\n}\n\nGlobals.assign({\n  frameLoop: new FrameLoop(),\n  createStringInterpolator: createStringInterpolator$1,\n  applyAnimatedValues: () => false\n});\n/** Advance all animations forward one frame */\n\nconst update = () => Globals.frameLoop.update();\n\n// The `mass` prop defaults to 1\nconst config = {\n  default: {\n    tension: 170,\n    friction: 26\n  },\n  gentle: {\n    tension: 120,\n    friction: 14\n  },\n  wobbly: {\n    tension: 180,\n    friction: 12\n  },\n  stiff: {\n    tension: 210,\n    friction: 20\n  },\n  slow: {\n    tension: 280,\n    friction: 60\n  },\n  molasses: {\n    tension: 280,\n    friction: 120\n  }\n};\n\nexport { Controller, FrameLoop, Spring, Trail, Transition, config, update, useChain, useSpring, useSprings, useTrail, useTransition };\n//# sourceMappingURL=index.js.map\n"]},"metadata":{},"sourceType":"module"}