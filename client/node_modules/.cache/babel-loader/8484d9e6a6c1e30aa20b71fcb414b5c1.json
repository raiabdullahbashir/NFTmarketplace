{"ast":null,"code":"/*\n    This file is part of web3.js.\n\n    web3.js is free software: you can redistribute it and/or modify\n    it under the terms of the GNU Lesser General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    web3.js is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU Lesser General Public License for more details.\n\n    You should have received a copy of the GNU Lesser General Public License\n    along with web3.js.  If not, see <http://www.gnu.org/licenses/>.\n*/\n\n/**\n * @file formatters.js\n * @author Marek Kotewicz <marek@ethdev.com>\n * @date 2015\n */\nvar BigNumber = require('bignumber.js');\n\nvar utils = require('../utils/utils');\n\nvar c = require('../utils/config');\n\nvar SolidityParam = require('./param');\n/**\n * Formats input value to byte representation of int\n * If value is negative, return it's two's complement\n * If the value is floating point, round it down\n *\n * @method formatInputInt\n * @param {String|Number|BigNumber} value that needs to be formatted\n * @returns {SolidityParam}\n */\n\n\nvar formatInputInt = function (value) {\n  BigNumber.config(c.ETH_BIGNUMBER_ROUNDING_MODE);\n  var result = utils.padLeft(utils.toTwosComplement(value).toString(16), 64);\n  return new SolidityParam(result);\n};\n/**\n * Formats input bytes\n *\n * @method formatInputBytes\n * @param {String}\n * @returns {SolidityParam}\n */\n\n\nvar formatInputBytes = function (value) {\n  var result = utils.toHex(value).substr(2);\n  var l = Math.floor((result.length + 63) / 64);\n  result = utils.padRight(result, l * 64);\n  return new SolidityParam(result);\n};\n/**\n * Formats input bytes\n *\n * @method formatDynamicInputBytes\n * @param {String}\n * @returns {SolidityParam}\n */\n\n\nvar formatInputDynamicBytes = function (value) {\n  var result = utils.toHex(value).substr(2);\n  var length = result.length / 2;\n  var l = Math.floor((result.length + 63) / 64);\n  result = utils.padRight(result, l * 64);\n  return new SolidityParam(formatInputInt(length).value + result);\n};\n/**\n * Formats input value to byte representation of string\n *\n * @method formatInputString\n * @param {String}\n * @returns {SolidityParam}\n */\n\n\nvar formatInputString = function (value) {\n  var result = utils.fromUtf8(value).substr(2);\n  var length = result.length / 2;\n  var l = Math.floor((result.length + 63) / 64);\n  result = utils.padRight(result, l * 64);\n  return new SolidityParam(formatInputInt(length).value + result);\n};\n/**\n * Formats input value to byte representation of bool\n *\n * @method formatInputBool\n * @param {Boolean}\n * @returns {SolidityParam}\n */\n\n\nvar formatInputBool = function (value) {\n  var result = '000000000000000000000000000000000000000000000000000000000000000' + (value ? '1' : '0');\n  return new SolidityParam(result);\n};\n/**\n * Formats input value to byte representation of real\n * Values are multiplied by 2^m and encoded as integers\n *\n * @method formatInputReal\n * @param {String|Number|BigNumber}\n * @returns {SolidityParam}\n */\n\n\nvar formatInputReal = function (value) {\n  return formatInputInt(new BigNumber(value).times(new BigNumber(2).pow(128)));\n};\n/**\n * Check if input value is negative\n *\n * @method signedIsNegative\n * @param {String} value is hex format\n * @returns {Boolean} true if it is negative, otherwise false\n */\n\n\nvar signedIsNegative = function (value) {\n  return new BigNumber(value.substr(0, 1), 16).toString(2).substr(0, 1) === '1';\n};\n/**\n * Formats right-aligned output bytes to int\n *\n * @method formatOutputInt\n * @param {SolidityParam} param\n * @returns {BigNumber} right-aligned output bytes formatted to big number\n */\n\n\nvar formatOutputInt = function (param) {\n  var value = param.staticPart() || \"0\"; // check if it's negative number\n  // it it is, return two's complement\n\n  if (signedIsNegative(value)) {\n    return new BigNumber(value, 16).minus(new BigNumber('ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff', 16)).minus(1);\n  }\n\n  return new BigNumber(value, 16);\n};\n/**\n * Formats right-aligned output bytes to uint\n *\n * @method formatOutputUInt\n * @param {SolidityParam}\n * @returns {BigNumeber} right-aligned output bytes formatted to uint\n */\n\n\nvar formatOutputUInt = function (param) {\n  var value = param.staticPart() || \"0\";\n  return new BigNumber(value, 16);\n};\n/**\n * Formats right-aligned output bytes to real\n *\n * @method formatOutputReal\n * @param {SolidityParam}\n * @returns {BigNumber} input bytes formatted to real\n */\n\n\nvar formatOutputReal = function (param) {\n  return formatOutputInt(param).dividedBy(new BigNumber(2).pow(128));\n};\n/**\n * Formats right-aligned output bytes to ureal\n *\n * @method formatOutputUReal\n * @param {SolidityParam}\n * @returns {BigNumber} input bytes formatted to ureal\n */\n\n\nvar formatOutputUReal = function (param) {\n  return formatOutputUInt(param).dividedBy(new BigNumber(2).pow(128));\n};\n/**\n * Should be used to format output bool\n *\n * @method formatOutputBool\n * @param {SolidityParam}\n * @returns {Boolean} right-aligned input bytes formatted to bool\n */\n\n\nvar formatOutputBool = function (param) {\n  return param.staticPart() === '0000000000000000000000000000000000000000000000000000000000000001' ? true : false;\n};\n/**\n * Should be used to format output bytes\n *\n * @method formatOutputBytes\n * @param {SolidityParam} left-aligned hex representation of string\n * @param {String} name type name\n * @returns {String} hex string\n */\n\n\nvar formatOutputBytes = function (param, name) {\n  var matches = name.match(/^bytes([0-9]*)/);\n  var size = parseInt(matches[1]);\n  return '0x' + param.staticPart().slice(0, 2 * size);\n};\n/**\n * Should be used to format output bytes\n *\n * @method formatOutputDynamicBytes\n * @param {SolidityParam} left-aligned hex representation of string\n * @returns {String} hex string\n */\n\n\nvar formatOutputDynamicBytes = function (param) {\n  var length = new BigNumber(param.dynamicPart().slice(0, 64), 16).toNumber() * 2;\n  return '0x' + param.dynamicPart().substr(64, length);\n};\n/**\n * Should be used to format output string\n *\n * @method formatOutputString\n * @param {SolidityParam} left-aligned hex representation of string\n * @returns {String} ascii string\n */\n\n\nvar formatOutputString = function (param) {\n  var length = new BigNumber(param.dynamicPart().slice(0, 64), 16).toNumber() * 2;\n  return utils.toUtf8(param.dynamicPart().substr(64, length));\n};\n/**\n * Should be used to format output address\n *\n * @method formatOutputAddress\n * @param {SolidityParam} right-aligned input bytes\n * @returns {String} address\n */\n\n\nvar formatOutputAddress = function (param) {\n  var value = param.staticPart();\n  return \"0x\" + value.slice(value.length - 40, value.length);\n};\n\nmodule.exports = {\n  formatInputInt: formatInputInt,\n  formatInputBytes: formatInputBytes,\n  formatInputDynamicBytes: formatInputDynamicBytes,\n  formatInputString: formatInputString,\n  formatInputBool: formatInputBool,\n  formatInputReal: formatInputReal,\n  formatOutputInt: formatOutputInt,\n  formatOutputUInt: formatOutputUInt,\n  formatOutputReal: formatOutputReal,\n  formatOutputUReal: formatOutputUReal,\n  formatOutputBool: formatOutputBool,\n  formatOutputBytes: formatOutputBytes,\n  formatOutputDynamicBytes: formatOutputDynamicBytes,\n  formatOutputString: formatOutputString,\n  formatOutputAddress: formatOutputAddress\n};","map":{"version":3,"names":["BigNumber","require","utils","c","SolidityParam","formatInputInt","value","config","ETH_BIGNUMBER_ROUNDING_MODE","result","padLeft","toTwosComplement","toString","formatInputBytes","toHex","substr","l","Math","floor","length","padRight","formatInputDynamicBytes","formatInputString","fromUtf8","formatInputBool","formatInputReal","times","pow","signedIsNegative","formatOutputInt","param","staticPart","minus","formatOutputUInt","formatOutputReal","dividedBy","formatOutputUReal","formatOutputBool","formatOutputBytes","name","matches","match","size","parseInt","slice","formatOutputDynamicBytes","dynamicPart","toNumber","formatOutputString","toUtf8","formatOutputAddress","module","exports"],"sources":["C:/Users/raiab/Documents/Logics Yard/NFT code daniyal/NFT code/node_modules/@0xproject/assert/node_modules/web3/lib/solidity/formatters.js"],"sourcesContent":["/*\n    This file is part of web3.js.\n\n    web3.js is free software: you can redistribute it and/or modify\n    it under the terms of the GNU Lesser General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    web3.js is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU Lesser General Public License for more details.\n\n    You should have received a copy of the GNU Lesser General Public License\n    along with web3.js.  If not, see <http://www.gnu.org/licenses/>.\n*/\n/**\n * @file formatters.js\n * @author Marek Kotewicz <marek@ethdev.com>\n * @date 2015\n */\n\nvar BigNumber = require('bignumber.js');\nvar utils = require('../utils/utils');\nvar c = require('../utils/config');\nvar SolidityParam = require('./param');\n\n\n/**\n * Formats input value to byte representation of int\n * If value is negative, return it's two's complement\n * If the value is floating point, round it down\n *\n * @method formatInputInt\n * @param {String|Number|BigNumber} value that needs to be formatted\n * @returns {SolidityParam}\n */\nvar formatInputInt = function (value) {\n    BigNumber.config(c.ETH_BIGNUMBER_ROUNDING_MODE);\n    var result = utils.padLeft(utils.toTwosComplement(value).toString(16), 64);\n    return new SolidityParam(result);\n};\n\n/**\n * Formats input bytes\n *\n * @method formatInputBytes\n * @param {String}\n * @returns {SolidityParam}\n */\nvar formatInputBytes = function (value) {\n    var result = utils.toHex(value).substr(2);\n    var l = Math.floor((result.length + 63) / 64);\n    result = utils.padRight(result, l * 64);\n    return new SolidityParam(result);\n};\n\n/**\n * Formats input bytes\n *\n * @method formatDynamicInputBytes\n * @param {String}\n * @returns {SolidityParam}\n */\nvar formatInputDynamicBytes = function (value) {\n    var result = utils.toHex(value).substr(2);\n    var length = result.length / 2;\n    var l = Math.floor((result.length + 63) / 64);\n    result = utils.padRight(result, l * 64);\n    return new SolidityParam(formatInputInt(length).value + result);\n};\n\n/**\n * Formats input value to byte representation of string\n *\n * @method formatInputString\n * @param {String}\n * @returns {SolidityParam}\n */\nvar formatInputString = function (value) {\n    var result = utils.fromUtf8(value).substr(2);\n    var length = result.length / 2;\n    var l = Math.floor((result.length + 63) / 64);\n    result = utils.padRight(result, l * 64);\n    return new SolidityParam(formatInputInt(length).value + result);\n};\n\n/**\n * Formats input value to byte representation of bool\n *\n * @method formatInputBool\n * @param {Boolean}\n * @returns {SolidityParam}\n */\nvar formatInputBool = function (value) {\n    var result = '000000000000000000000000000000000000000000000000000000000000000' + (value ?  '1' : '0');\n    return new SolidityParam(result);\n};\n\n/**\n * Formats input value to byte representation of real\n * Values are multiplied by 2^m and encoded as integers\n *\n * @method formatInputReal\n * @param {String|Number|BigNumber}\n * @returns {SolidityParam}\n */\nvar formatInputReal = function (value) {\n    return formatInputInt(new BigNumber(value).times(new BigNumber(2).pow(128)));\n};\n\n/**\n * Check if input value is negative\n *\n * @method signedIsNegative\n * @param {String} value is hex format\n * @returns {Boolean} true if it is negative, otherwise false\n */\nvar signedIsNegative = function (value) {\n    return (new BigNumber(value.substr(0, 1), 16).toString(2).substr(0, 1)) === '1';\n};\n\n/**\n * Formats right-aligned output bytes to int\n *\n * @method formatOutputInt\n * @param {SolidityParam} param\n * @returns {BigNumber} right-aligned output bytes formatted to big number\n */\nvar formatOutputInt = function (param) {\n    var value = param.staticPart() || \"0\";\n\n    // check if it's negative number\n    // it it is, return two's complement\n    if (signedIsNegative(value)) {\n        return new BigNumber(value, 16).minus(new BigNumber('ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff', 16)).minus(1);\n    }\n    return new BigNumber(value, 16);\n};\n\n/**\n * Formats right-aligned output bytes to uint\n *\n * @method formatOutputUInt\n * @param {SolidityParam}\n * @returns {BigNumeber} right-aligned output bytes formatted to uint\n */\nvar formatOutputUInt = function (param) {\n    var value = param.staticPart() || \"0\";\n    return new BigNumber(value, 16);\n};\n\n/**\n * Formats right-aligned output bytes to real\n *\n * @method formatOutputReal\n * @param {SolidityParam}\n * @returns {BigNumber} input bytes formatted to real\n */\nvar formatOutputReal = function (param) {\n    return formatOutputInt(param).dividedBy(new BigNumber(2).pow(128));\n};\n\n/**\n * Formats right-aligned output bytes to ureal\n *\n * @method formatOutputUReal\n * @param {SolidityParam}\n * @returns {BigNumber} input bytes formatted to ureal\n */\nvar formatOutputUReal = function (param) {\n    return formatOutputUInt(param).dividedBy(new BigNumber(2).pow(128));\n};\n\n/**\n * Should be used to format output bool\n *\n * @method formatOutputBool\n * @param {SolidityParam}\n * @returns {Boolean} right-aligned input bytes formatted to bool\n */\nvar formatOutputBool = function (param) {\n    return param.staticPart() === '0000000000000000000000000000000000000000000000000000000000000001' ? true : false;\n};\n\n/**\n * Should be used to format output bytes\n *\n * @method formatOutputBytes\n * @param {SolidityParam} left-aligned hex representation of string\n * @param {String} name type name\n * @returns {String} hex string\n */\nvar formatOutputBytes = function (param, name) {\n    var matches = name.match(/^bytes([0-9]*)/);\n    var size = parseInt(matches[1]);\n    return '0x' + param.staticPart().slice(0, 2 * size);\n};\n\n/**\n * Should be used to format output bytes\n *\n * @method formatOutputDynamicBytes\n * @param {SolidityParam} left-aligned hex representation of string\n * @returns {String} hex string\n */\nvar formatOutputDynamicBytes = function (param) {\n    var length = (new BigNumber(param.dynamicPart().slice(0, 64), 16)).toNumber() * 2;\n    return '0x' + param.dynamicPart().substr(64, length);\n};\n\n/**\n * Should be used to format output string\n *\n * @method formatOutputString\n * @param {SolidityParam} left-aligned hex representation of string\n * @returns {String} ascii string\n */\nvar formatOutputString = function (param) {\n    var length = (new BigNumber(param.dynamicPart().slice(0, 64), 16)).toNumber() * 2;\n    return utils.toUtf8(param.dynamicPart().substr(64, length));\n};\n\n/**\n * Should be used to format output address\n *\n * @method formatOutputAddress\n * @param {SolidityParam} right-aligned input bytes\n * @returns {String} address\n */\nvar formatOutputAddress = function (param) {\n    var value = param.staticPart();\n    return \"0x\" + value.slice(value.length - 40, value.length);\n};\n\nmodule.exports = {\n    formatInputInt: formatInputInt,\n    formatInputBytes: formatInputBytes,\n    formatInputDynamicBytes: formatInputDynamicBytes,\n    formatInputString: formatInputString,\n    formatInputBool: formatInputBool,\n    formatInputReal: formatInputReal,\n    formatOutputInt: formatOutputInt,\n    formatOutputUInt: formatOutputUInt,\n    formatOutputReal: formatOutputReal,\n    formatOutputUReal: formatOutputUReal,\n    formatOutputBool: formatOutputBool,\n    formatOutputBytes: formatOutputBytes,\n    formatOutputDynamicBytes: formatOutputDynamicBytes,\n    formatOutputString: formatOutputString,\n    formatOutputAddress: formatOutputAddress\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}