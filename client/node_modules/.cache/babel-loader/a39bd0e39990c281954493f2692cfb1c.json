{"ast":null,"code":"const utils = require('ethereumjs-util');\n\nconst BN = require('bn.js');\n\nvar ABI = function () {}; // Convert from short to canonical names\n// FIXME: optimise or make this nicer?\n\n\nfunction elementaryName(name) {\n  if (name.startsWith('int[')) {\n    return 'int256' + name.slice(3);\n  } else if (name === 'int') {\n    return 'int256';\n  } else if (name.startsWith('uint[')) {\n    return 'uint256' + name.slice(4);\n  } else if (name === 'uint') {\n    return 'uint256';\n  } else if (name.startsWith('fixed[')) {\n    return 'fixed128x128' + name.slice(5);\n  } else if (name === 'fixed') {\n    return 'fixed128x128';\n  } else if (name.startsWith('ufixed[')) {\n    return 'ufixed128x128' + name.slice(6);\n  } else if (name === 'ufixed') {\n    return 'ufixed128x128';\n  }\n\n  return name;\n}\n\nABI.eventID = function (name, types) {\n  // FIXME: use node.js util.format?\n  var sig = name + '(' + types.map(elementaryName).join(',') + ')';\n  return utils.sha3(new Buffer(sig));\n};\n\nABI.methodID = function (name, types) {\n  return ABI.eventID(name, types).slice(0, 4);\n}; // Parse N from type<N>\n\n\nfunction parseTypeN(type) {\n  return parseInt(/^\\D+(\\d+)$/.exec(type)[1], 10);\n} // Parse N,M from type<N>x<M>\n\n\nfunction parseTypeNxM(type) {\n  var tmp = /^\\D+(\\d+)x(\\d+)$/.exec(type);\n  return [parseInt(tmp[1], 10), parseInt(tmp[2], 10)];\n} // Parse N in type[<N>] where \"type\" can itself be an array type.\n\n\nfunction parseTypeArray(type) {\n  var tmp = type.match(/(.*)\\[(.*?)\\]$/);\n\n  if (tmp) {\n    return tmp[2] === '' ? 'dynamic' : parseInt(tmp[2], 10);\n  }\n\n  return null;\n}\n\nfunction parseNumber(arg) {\n  var type = typeof arg;\n\n  if (type === 'string') {\n    if (utils.isHexPrefixed(arg)) {\n      return new BN(utils.stripHexPrefix(arg), 16);\n    } else {\n      return new BN(arg, 10);\n    }\n  } else if (type === 'number') {\n    return new BN(arg);\n  } else if (arg.toArray) {\n    // assume this is a BN for the moment, replace with BN.isBN soon\n    return arg;\n  } else {\n    throw new Error('Argument is not a number');\n  }\n} // someMethod(bytes,uint)\n// someMethod(bytes,uint):(boolean)\n\n\nfunction parseSignature(sig) {\n  var tmp = /^(\\w+)\\((.+)\\)$/.exec(sig);\n\n  if (tmp.length !== 3) {\n    throw new Error('Invalid method signature');\n  }\n\n  var args = /^(.+)\\):\\((.+)$/.exec(tmp[2]);\n\n  if (args !== null && args.length === 3) {\n    return {\n      method: tmp[1],\n      args: args[1].split(','),\n      retargs: args[2].split(',')\n    };\n  } else {\n    return {\n      method: tmp[1],\n      args: tmp[2].split(',')\n    };\n  }\n} // Encodes a single item (can be dynamic array)\n// @returns: Buffer\n\n\nfunction encodeSingle(type, arg) {\n  var size, num, ret, i;\n\n  if (type === 'address') {\n    return encodeSingle('uint160', parseNumber(arg));\n  } else if (type === 'bool') {\n    return encodeSingle('uint8', arg ? 1 : 0);\n  } else if (type === 'string') {\n    return encodeSingle('bytes', new Buffer(arg, 'utf8'));\n  } else if (isArray(type)) {\n    // this part handles fixed-length ([2]) and variable length ([]) arrays\n    // NOTE: we catch here all calls to arrays, that simplifies the rest\n    if (typeof arg.length === 'undefined') {\n      throw new Error('Not an array?');\n    }\n\n    size = parseTypeArray(type);\n\n    if (size !== 'dynamic' && size !== 0 && arg.length > size) {\n      throw new Error('Elements exceed array size: ' + size);\n    }\n\n    ret = [];\n    type = type.slice(0, type.lastIndexOf('['));\n\n    if (typeof arg === 'string') {\n      arg = JSON.parse(arg);\n    }\n\n    for (i in arg) {\n      ret.push(encodeSingle(type, arg[i]));\n    }\n\n    if (size === 'dynamic') {\n      var length = encodeSingle('uint256', arg.length);\n      ret.unshift(length);\n    }\n\n    return Buffer.concat(ret);\n  } else if (type === 'bytes') {\n    arg = new Buffer(arg);\n    ret = Buffer.concat([encodeSingle('uint256', arg.length), arg]);\n\n    if (arg.length % 32 !== 0) {\n      ret = Buffer.concat([ret, utils.zeros(32 - arg.length % 32)]);\n    }\n\n    return ret;\n  } else if (type.startsWith('bytes')) {\n    size = parseTypeN(type);\n\n    if (size < 1 || size > 32) {\n      throw new Error('Invalid bytes<N> width: ' + size);\n    }\n\n    return utils.setLengthRight(arg, 32);\n  } else if (type.startsWith('uint')) {\n    size = parseTypeN(type);\n\n    if (size % 8 || size < 8 || size > 256) {\n      throw new Error('Invalid uint<N> width: ' + size);\n    }\n\n    num = parseNumber(arg);\n\n    if (num.bitLength() > size) {\n      throw new Error('Supplied uint exceeds width: ' + size + ' vs ' + num.bitLength());\n    }\n\n    if (num < 0) {\n      throw new Error('Supplied uint is negative');\n    }\n\n    return num.toArrayLike(Buffer, 'be', 32);\n  } else if (type.startsWith('int')) {\n    size = parseTypeN(type);\n\n    if (size % 8 || size < 8 || size > 256) {\n      throw new Error('Invalid int<N> width: ' + size);\n    }\n\n    num = parseNumber(arg);\n\n    if (num.bitLength() > size) {\n      throw new Error('Supplied int exceeds width: ' + size + ' vs ' + num.bitLength());\n    }\n\n    return num.toTwos(256).toArrayLike(Buffer, 'be', 32);\n  } else if (type.startsWith('ufixed')) {\n    size = parseTypeNxM(type);\n    num = parseNumber(arg);\n\n    if (num < 0) {\n      throw new Error('Supplied ufixed is negative');\n    }\n\n    return encodeSingle('uint256', num.mul(new BN(2).pow(new BN(size[1]))));\n  } else if (type.startsWith('fixed')) {\n    size = parseTypeNxM(type);\n    return encodeSingle('int256', parseNumber(arg).mul(new BN(2).pow(new BN(size[1]))));\n  }\n\n  throw new Error('Unsupported or invalid type: ' + type);\n} // Decodes a single item (can be dynamic array)\n// @returns: array\n// FIXME: this method will need a lot of attention at checking limits and validation\n\n\nfunction decodeSingle(parsedType, data, offset) {\n  if (typeof parsedType === 'string') {\n    parsedType = parseType(parsedType);\n  }\n\n  var size, num, ret, i;\n\n  if (parsedType.name === 'address') {\n    return decodeSingle(parsedType.rawType, data, offset).toArrayLike(Buffer, 'be', 20).toString('hex');\n  } else if (parsedType.name === 'bool') {\n    return decodeSingle(parsedType.rawType, data, offset).toString() === new BN(1).toString();\n  } else if (parsedType.name === 'string') {\n    var bytes = decodeSingle(parsedType.rawType, data, offset);\n    return new Buffer(bytes, 'utf8').toString();\n  } else if (parsedType.isArray) {\n    // this part handles fixed-length arrays ([2]) and variable length ([]) arrays\n    // NOTE: we catch here all calls to arrays, that simplifies the rest\n    ret = [];\n    size = parsedType.size;\n\n    if (parsedType.size === 'dynamic') {\n      offset = decodeSingle('uint256', data, offset).toNumber();\n      size = decodeSingle('uint256', data, offset).toNumber();\n      offset = offset + 32;\n    }\n\n    for (i = 0; i < size; i++) {\n      var decoded = decodeSingle(parsedType.subArray, data, offset);\n      ret.push(decoded);\n      offset += parsedType.subArray.memoryUsage;\n    }\n\n    return ret;\n  } else if (parsedType.name === 'bytes') {\n    offset = decodeSingle('uint256', data, offset).toNumber();\n    size = decodeSingle('uint256', data, offset).toNumber();\n    return data.slice(offset + 32, offset + 32 + size);\n  } else if (parsedType.name.startsWith('bytes')) {\n    return data.slice(offset, offset + parsedType.size);\n  } else if (parsedType.name.startsWith('uint')) {\n    num = new BN(data.slice(offset, offset + 32), 16, 'be');\n\n    if (num.bitLength() > parsedType.size) {\n      throw new Error('Decoded int exceeds width: ' + parsedType.size + ' vs ' + num.bitLength());\n    }\n\n    return num;\n  } else if (parsedType.name.startsWith('int')) {\n    num = new BN(data.slice(offset, offset + 32), 16, 'be').fromTwos(256);\n\n    if (num.bitLength() > parsedType.size) {\n      throw new Error('Decoded uint exceeds width: ' + parsedType.size + ' vs ' + num.bitLength());\n    }\n\n    return num;\n  } else if (parsedType.name.startsWith('ufixed')) {\n    size = new BN(2).pow(new BN(parsedType.size[1]));\n    num = decodeSingle('uint256', data, offset);\n\n    if (!num.mod(size).isZero()) {\n      throw new Error('Decimals not supported yet');\n    }\n\n    return num.div(size);\n  } else if (parsedType.name.startsWith('fixed')) {\n    size = new BN(2).pow(new BN(parsedType.size[1]));\n    num = decodeSingle('int256', data, offset);\n\n    if (!num.mod(size).isZero()) {\n      throw new Error('Decimals not supported yet');\n    }\n\n    return num.div(size);\n  }\n\n  throw new Error('Unsupported or invalid type: ' + parsedType.name);\n} // Parse the given type\n// @returns: {} containing the type itself, memory usage and (including size and subArray if applicable)\n\n\nfunction parseType(type) {\n  var size;\n  var ret;\n\n  if (isArray(type)) {\n    size = parseTypeArray(type);\n    var subArray = type.slice(0, type.lastIndexOf('['));\n    subArray = parseType(subArray);\n    ret = {\n      isArray: true,\n      name: type,\n      size: size,\n      memoryUsage: size === 'dynamic' ? 32 : subArray.memoryUsage * size,\n      subArray: subArray\n    };\n    return ret;\n  } else {\n    var rawType;\n\n    switch (type) {\n      case 'address':\n        rawType = 'uint160';\n        break;\n\n      case 'bool':\n        rawType = 'uint8';\n        break;\n\n      case 'string':\n        rawType = 'bytes';\n        break;\n    }\n\n    ret = {\n      rawType: rawType,\n      name: type,\n      memoryUsage: 32\n    };\n\n    if (type.startsWith('bytes') && type !== 'bytes' || type.startsWith('uint') || type.startsWith('int')) {\n      ret.size = parseTypeN(type);\n    } else if (type.startsWith('ufixed') || type.startsWith('fixed')) {\n      ret.size = parseTypeNxM(type);\n    }\n\n    if (type.startsWith('bytes') && type !== 'bytes' && (ret.size < 1 || ret.size > 32)) {\n      throw new Error('Invalid bytes<N> width: ' + ret.size);\n    }\n\n    if ((type.startsWith('uint') || type.startsWith('int')) && (ret.size % 8 || ret.size < 8 || ret.size > 256)) {\n      throw new Error('Invalid int/uint<N> width: ' + ret.size);\n    }\n\n    return ret;\n  }\n} // Is a type dynamic?\n\n\nfunction isDynamic(type) {\n  // FIXME: handle all types? I don't think anything is missing now\n  return type === 'string' || type === 'bytes' || parseTypeArray(type) === 'dynamic';\n} // Is a type an array?\n\n\nfunction isArray(type) {\n  return type.lastIndexOf(']') === type.length - 1;\n}\n\nABI.elementaryName = elementaryName;\nABI.encodeSingle = encodeSingle;\nABI.isDynamic = isDynamic; // Encode a method/event with arguments\n// @types an array of string type names\n// @args  an array of the appropriate values\n\nABI.rawEncode = function (types, values) {\n  var output = [];\n  var data = [];\n  var headLength = 32 * types.length;\n\n  for (var i in types) {\n    var type = elementaryName(types[i]);\n    var value = values[i];\n    var cur = encodeSingle(type, value); // Use the head/tail method for storing dynamic data\n\n    if (isDynamic(type)) {\n      output.push(encodeSingle('uint256', headLength));\n      data.push(cur);\n      headLength += cur.length;\n    } else {\n      output.push(cur);\n    }\n  }\n\n  return Buffer.concat(output.concat(data));\n};\n\nABI.rawDecode = function (types, data) {\n  var ret = [];\n  data = new Buffer(data);\n  var offset = 0;\n\n  for (var i in types) {\n    var type = elementaryName(types[i]);\n    var parsed = parseType(type, data, offset);\n    var decoded = decodeSingle(parsed, data, offset);\n    offset += parsed.memoryUsage;\n    ret.push(decoded);\n  }\n\n  return ret;\n};\n\nABI.simpleEncode = function (method) {\n  var args = Array.prototype.slice.call(arguments).slice(1);\n  var sig = parseSignature(method); // FIXME: validate/convert arguments\n\n  if (args.length !== sig.args.length) {\n    throw new Error('Argument count mismatch');\n  }\n\n  return Buffer.concat([ABI.methodID(sig.method, sig.args), ABI.rawEncode(sig.args, args)]);\n};\n\nABI.simpleDecode = function (method, data) {\n  var sig = parseSignature(method); // FIXME: validate/convert arguments\n\n  if (!sig.retargs) {\n    throw new Error('No return values in method');\n  }\n\n  return ABI.rawDecode(sig.retargs, data);\n};\n\nfunction stringify(type, value) {\n  if (type.startsWith('address') || type.startsWith('bytes')) {\n    return '0x' + value.toString('hex');\n  } else {\n    return value.toString();\n  }\n}\n\nABI.stringify = function (types, values) {\n  var ret = [];\n\n  for (var i in types) {\n    var type = types[i];\n    var value = values[i]; // if it is an array type, concat the items\n\n    if (/^[^\\[]+\\[.*\\]$/.test(type)) {\n      value = value.map(function (item) {\n        return stringify(type, item);\n      }).join(', ');\n    } else {\n      value = stringify(type, value);\n    }\n\n    ret.push(value);\n  }\n\n  return ret;\n};\n\nABI.solidityPack = function (types, values) {\n  if (types.length !== values.length) {\n    throw new Error('Number of types are not matching the values');\n  }\n\n  var size, num;\n  var ret = [];\n\n  for (var i = 0; i < types.length; i++) {\n    var type = elementaryName(types[i]);\n    var value = values[i];\n\n    if (type === 'bytes') {\n      ret.push(value);\n    } else if (type === 'string') {\n      ret.push(new Buffer(value, 'utf8'));\n    } else if (type === 'bool') {\n      ret.push(new Buffer(value ? '01' : '00', 'hex'));\n    } else if (type === 'address') {\n      ret.push(utils.setLengthLeft(value, 20));\n    } else if (type.startsWith('bytes')) {\n      size = parseTypeN(type);\n\n      if (size < 1 || size > 32) {\n        throw new Error('Invalid bytes<N> width: ' + size);\n      }\n\n      ret.push(utils.setLengthRight(value, size));\n    } else if (type.startsWith('uint')) {\n      size = parseTypeN(type);\n\n      if (size % 8 || size < 8 || size > 256) {\n        throw new Error('Invalid uint<N> width: ' + size);\n      }\n\n      num = parseNumber(value);\n\n      if (num.bitLength() > size) {\n        throw new Error('Supplied uint exceeds width: ' + size + ' vs ' + num.bitLength());\n      }\n\n      ret.push(num.toArrayLike(Buffer, 'be', size / 8));\n    } else if (type.startsWith('int')) {\n      size = parseTypeN(type);\n\n      if (size % 8 || size < 8 || size > 256) {\n        throw new Error('Invalid int<N> width: ' + size);\n      }\n\n      num = parseNumber(value);\n\n      if (num.bitLength() > size) {\n        throw new Error('Supplied int exceeds width: ' + size + ' vs ' + num.bitLength());\n      }\n\n      ret.push(num.toTwos(size).toArrayLike(Buffer, 'be', size / 8));\n    } else {\n      // FIXME: support all other types\n      throw new Error('Unsupported or invalid type: ' + type);\n    }\n  }\n\n  return Buffer.concat(ret);\n};\n\nABI.soliditySHA3 = function (types, values) {\n  return utils.sha3(ABI.solidityPack(types, values));\n};\n\nABI.soliditySHA256 = function (types, values) {\n  return utils.sha256(ABI.solidityPack(types, values));\n};\n\nABI.solidityRIPEMD160 = function (types, values) {\n  return utils.ripemd160(ABI.solidityPack(types, values), true);\n}; // Serpent's users are familiar with this encoding\n// - s: string\n// - b: bytes\n// - b<N>: bytes<N>\n// - i: int256\n// - a: int256[]\n\n\nfunction isNumeric(c) {\n  // FIXME: is this correct? Seems to work\n  return c >= '0' && c <= '9';\n} // For a \"documentation\" refer to https://github.com/ethereum/serpent/blob/develop/preprocess.cpp\n\n\nABI.fromSerpent = function (sig) {\n  var ret = [];\n\n  for (var i = 0; i < sig.length; i++) {\n    var type = sig[i];\n\n    if (type === 's') {\n      ret.push('bytes');\n    } else if (type === 'b') {\n      var tmp = 'bytes';\n      var j = i + 1;\n\n      while (j < sig.length && isNumeric(sig[j])) {\n        tmp += sig[j] - '0';\n        j++;\n      }\n\n      i = j - 1;\n      ret.push(tmp);\n    } else if (type === 'i') {\n      ret.push('int256');\n    } else if (type === 'a') {\n      ret.push('int256[]');\n    } else {\n      throw new Error('Unsupported or invalid type: ' + type);\n    }\n  }\n\n  return ret;\n};\n\nABI.toSerpent = function (types) {\n  var ret = [];\n\n  for (var i = 0; i < types.length; i++) {\n    var type = types[i];\n\n    if (type === 'bytes') {\n      ret.push('s');\n    } else if (type.startsWith('bytes')) {\n      ret.push('b' + parseTypeN(type));\n    } else if (type === 'int256') {\n      ret.push('i');\n    } else if (type === 'int256[]') {\n      ret.push('a');\n    } else {\n      throw new Error('Unsupported or invalid type: ' + type);\n    }\n  }\n\n  return ret.join('');\n};\n\nmodule.exports = ABI;","map":{"version":3,"names":["utils","require","BN","ABI","elementaryName","name","startsWith","slice","eventID","types","sig","map","join","sha3","Buffer","methodID","parseTypeN","type","parseInt","exec","parseTypeNxM","tmp","parseTypeArray","match","parseNumber","arg","isHexPrefixed","stripHexPrefix","toArray","Error","parseSignature","length","args","method","split","retargs","encodeSingle","size","num","ret","i","isArray","lastIndexOf","JSON","parse","push","unshift","concat","zeros","setLengthRight","bitLength","toArrayLike","toTwos","mul","pow","decodeSingle","parsedType","data","offset","parseType","rawType","toString","bytes","toNumber","decoded","subArray","memoryUsage","fromTwos","mod","isZero","div","isDynamic","rawEncode","values","output","headLength","value","cur","rawDecode","parsed","simpleEncode","Array","prototype","call","arguments","simpleDecode","stringify","test","item","solidityPack","setLengthLeft","soliditySHA3","soliditySHA256","sha256","solidityRIPEMD160","ripemd160","isNumeric","c","fromSerpent","j","toSerpent","module","exports"],"sources":["C:/Users/raiab/Documents/Logics Yard/NFT code daniyal/NFT code/client/node_modules/ethereumjs-abi/lib/index.js"],"sourcesContent":["const utils = require('ethereumjs-util')\r\nconst BN = require('bn.js')\r\n\r\nvar ABI = function () {\r\n}\r\n\r\n// Convert from short to canonical names\r\n// FIXME: optimise or make this nicer?\r\nfunction elementaryName (name) {\r\n  if (name.startsWith('int[')) {\r\n    return 'int256' + name.slice(3)\r\n  } else if (name === 'int') {\r\n    return 'int256'\r\n  } else if (name.startsWith('uint[')) {\r\n    return 'uint256' + name.slice(4)\r\n  } else if (name === 'uint') {\r\n    return 'uint256'\r\n  } else if (name.startsWith('fixed[')) {\r\n    return 'fixed128x128' + name.slice(5)\r\n  } else if (name === 'fixed') {\r\n    return 'fixed128x128'\r\n  } else if (name.startsWith('ufixed[')) {\r\n    return 'ufixed128x128' + name.slice(6)\r\n  } else if (name === 'ufixed') {\r\n    return 'ufixed128x128'\r\n  }\r\n  return name\r\n}\r\n\r\nABI.eventID = function (name, types) {\r\n  // FIXME: use node.js util.format?\r\n  var sig = name + '(' + types.map(elementaryName).join(',') + ')'\r\n  return utils.sha3(new Buffer(sig))\r\n}\r\n\r\nABI.methodID = function (name, types) {\r\n  return ABI.eventID(name, types).slice(0, 4)\r\n}\r\n\r\n// Parse N from type<N>\r\nfunction parseTypeN (type) {\r\n  return parseInt(/^\\D+(\\d+)$/.exec(type)[1], 10)\r\n}\r\n\r\n// Parse N,M from type<N>x<M>\r\nfunction parseTypeNxM (type) {\r\n  var tmp = /^\\D+(\\d+)x(\\d+)$/.exec(type)\r\n  return [ parseInt(tmp[1], 10), parseInt(tmp[2], 10) ]\r\n}\r\n\r\n// Parse N in type[<N>] where \"type\" can itself be an array type.\r\nfunction parseTypeArray (type) {\r\n  var tmp = type.match(/(.*)\\[(.*?)\\]$/)\r\n  if (tmp) {\r\n    return tmp[2] === '' ? 'dynamic' : parseInt(tmp[2], 10)\r\n  }\r\n  return null\r\n}\r\n\r\nfunction parseNumber (arg) {\r\n  var type = typeof arg\r\n  if (type === 'string') {\r\n    if (utils.isHexPrefixed(arg)) {\r\n      return new BN(utils.stripHexPrefix(arg), 16)\r\n    } else {\r\n      return new BN(arg, 10)\r\n    }\r\n  } else if (type === 'number') {\r\n    return new BN(arg)\r\n  } else if (arg.toArray) {\r\n    // assume this is a BN for the moment, replace with BN.isBN soon\r\n    return arg\r\n  } else {\r\n    throw new Error('Argument is not a number')\r\n  }\r\n}\r\n\r\n// someMethod(bytes,uint)\r\n// someMethod(bytes,uint):(boolean)\r\nfunction parseSignature (sig) {\r\n  var tmp = /^(\\w+)\\((.+)\\)$/.exec(sig)\r\n  if (tmp.length !== 3) {\r\n    throw new Error('Invalid method signature')\r\n  }\r\n\r\n  var args = /^(.+)\\):\\((.+)$/.exec(tmp[2])\r\n\r\n  if (args !== null && args.length === 3) {\r\n    return {\r\n      method: tmp[1],\r\n      args: args[1].split(','),\r\n      retargs: args[2].split(',')\r\n    }\r\n  } else {\r\n    return {\r\n      method: tmp[1],\r\n      args: tmp[2].split(',')\r\n    }\r\n  }\r\n}\r\n\r\n// Encodes a single item (can be dynamic array)\r\n// @returns: Buffer\r\nfunction encodeSingle (type, arg) {\r\n  var size, num, ret, i\r\n\r\n  if (type === 'address') {\r\n    return encodeSingle('uint160', parseNumber(arg))\r\n  } else if (type === 'bool') {\r\n    return encodeSingle('uint8', arg ? 1 : 0)\r\n  } else if (type === 'string') {\r\n    return encodeSingle('bytes', new Buffer(arg, 'utf8'))\r\n  } else if (isArray(type)) {\r\n    // this part handles fixed-length ([2]) and variable length ([]) arrays\r\n    // NOTE: we catch here all calls to arrays, that simplifies the rest\r\n    if (typeof arg.length === 'undefined') {\r\n      throw new Error('Not an array?')\r\n    }\r\n    size = parseTypeArray(type)\r\n    if (size !== 'dynamic' && size !== 0 && arg.length > size) {\r\n      throw new Error('Elements exceed array size: ' + size)\r\n    }\r\n    ret = []\r\n    type = type.slice(0, type.lastIndexOf('['))\r\n    if (typeof arg === 'string') {\r\n      arg = JSON.parse(arg)\r\n    }\r\n    for (i in arg) {\r\n      ret.push(encodeSingle(type, arg[i]))\r\n    }\r\n    if (size === 'dynamic') {\r\n      var length = encodeSingle('uint256', arg.length)\r\n      ret.unshift(length)\r\n    }\r\n    return Buffer.concat(ret)\r\n  } else if (type === 'bytes') {\r\n    arg = new Buffer(arg)\r\n\r\n    ret = Buffer.concat([ encodeSingle('uint256', arg.length), arg ])\r\n\r\n    if ((arg.length % 32) !== 0) {\r\n      ret = Buffer.concat([ ret, utils.zeros(32 - (arg.length % 32)) ])\r\n    }\r\n\r\n    return ret\r\n  } else if (type.startsWith('bytes')) {\r\n    size = parseTypeN(type)\r\n    if (size < 1 || size > 32) {\r\n      throw new Error('Invalid bytes<N> width: ' + size)\r\n    }\r\n\r\n    return utils.setLengthRight(arg, 32)\r\n  } else if (type.startsWith('uint')) {\r\n    size = parseTypeN(type)\r\n    if ((size % 8) || (size < 8) || (size > 256)) {\r\n      throw new Error('Invalid uint<N> width: ' + size)\r\n    }\r\n\r\n    num = parseNumber(arg)\r\n    if (num.bitLength() > size) {\r\n      throw new Error('Supplied uint exceeds width: ' + size + ' vs ' + num.bitLength())\r\n    }\r\n\r\n    if (num < 0) {\r\n      throw new Error('Supplied uint is negative')\r\n    }\r\n\r\n    return num.toArrayLike(Buffer, 'be', 32)\r\n  } else if (type.startsWith('int')) {\r\n    size = parseTypeN(type)\r\n    if ((size % 8) || (size < 8) || (size > 256)) {\r\n      throw new Error('Invalid int<N> width: ' + size)\r\n    }\r\n\r\n    num = parseNumber(arg)\r\n    if (num.bitLength() > size) {\r\n      throw new Error('Supplied int exceeds width: ' + size + ' vs ' + num.bitLength())\r\n    }\r\n\r\n    return num.toTwos(256).toArrayLike(Buffer, 'be', 32)\r\n  } else if (type.startsWith('ufixed')) {\r\n    size = parseTypeNxM(type)\r\n\r\n    num = parseNumber(arg)\r\n\r\n    if (num < 0) {\r\n      throw new Error('Supplied ufixed is negative')\r\n    }\r\n\r\n    return encodeSingle('uint256', num.mul(new BN(2).pow(new BN(size[1]))))\r\n  } else if (type.startsWith('fixed')) {\r\n    size = parseTypeNxM(type)\r\n\r\n    return encodeSingle('int256', parseNumber(arg).mul(new BN(2).pow(new BN(size[1]))))\r\n  }\r\n\r\n  throw new Error('Unsupported or invalid type: ' + type)\r\n}\r\n\r\n// Decodes a single item (can be dynamic array)\r\n// @returns: array\r\n// FIXME: this method will need a lot of attention at checking limits and validation\r\nfunction decodeSingle (parsedType, data, offset) {\r\n  if (typeof parsedType === 'string') {\r\n    parsedType = parseType(parsedType)\r\n  }\r\n  var size, num, ret, i\r\n\r\n  if (parsedType.name === 'address') {\r\n    return decodeSingle(parsedType.rawType, data, offset).toArrayLike(Buffer, 'be', 20).toString('hex')\r\n  } else if (parsedType.name === 'bool') {\r\n    return decodeSingle(parsedType.rawType, data, offset).toString() === new BN(1).toString()\r\n  } else if (parsedType.name === 'string') {\r\n    var bytes = decodeSingle(parsedType.rawType, data, offset)\r\n    return new Buffer(bytes, 'utf8').toString()\r\n  } else if (parsedType.isArray) {\r\n    // this part handles fixed-length arrays ([2]) and variable length ([]) arrays\r\n    // NOTE: we catch here all calls to arrays, that simplifies the rest\r\n    ret = []\r\n    size = parsedType.size\r\n\r\n    if (parsedType.size === 'dynamic') {\r\n      offset = decodeSingle('uint256', data, offset).toNumber()\r\n      size = decodeSingle('uint256', data, offset).toNumber()\r\n      offset = offset + 32\r\n    }\r\n    for (i = 0; i < size; i++) {\r\n      var decoded = decodeSingle(parsedType.subArray, data, offset)\r\n      ret.push(decoded)\r\n      offset += parsedType.subArray.memoryUsage\r\n    }\r\n    return ret\r\n  } else if (parsedType.name === 'bytes') {\r\n    offset = decodeSingle('uint256', data, offset).toNumber()\r\n    size = decodeSingle('uint256', data, offset).toNumber()\r\n    return data.slice(offset + 32, offset + 32 + size)\r\n  } else if (parsedType.name.startsWith('bytes')) {\r\n    return data.slice(offset, offset + parsedType.size)\r\n  } else if (parsedType.name.startsWith('uint')) {\r\n    num = new BN(data.slice(offset, offset + 32), 16, 'be')\r\n    if (num.bitLength() > parsedType.size) {\r\n      throw new Error('Decoded int exceeds width: ' + parsedType.size + ' vs ' + num.bitLength())\r\n    }\r\n    return num\r\n  } else if (parsedType.name.startsWith('int')) {\r\n    num = new BN(data.slice(offset, offset + 32), 16, 'be').fromTwos(256)\r\n    if (num.bitLength() > parsedType.size) {\r\n      throw new Error('Decoded uint exceeds width: ' + parsedType.size + ' vs ' + num.bitLength())\r\n    }\r\n\r\n    return num\r\n  } else if (parsedType.name.startsWith('ufixed')) {\r\n    size = new BN(2).pow(new BN(parsedType.size[1]))\r\n    num = decodeSingle('uint256', data, offset)\r\n    if (!num.mod(size).isZero()) {\r\n      throw new Error('Decimals not supported yet')\r\n    }\r\n    return num.div(size)\r\n  } else if (parsedType.name.startsWith('fixed')) {\r\n    size = new BN(2).pow(new BN(parsedType.size[1]))\r\n    num = decodeSingle('int256', data, offset)\r\n    if (!num.mod(size).isZero()) {\r\n      throw new Error('Decimals not supported yet')\r\n    }\r\n    return num.div(size)\r\n  }\r\n  throw new Error('Unsupported or invalid type: ' + parsedType.name)\r\n}\r\n\r\n// Parse the given type\r\n// @returns: {} containing the type itself, memory usage and (including size and subArray if applicable)\r\nfunction parseType (type) {\r\n  var size\r\n  var ret\r\n  if (isArray(type)) {\r\n    size = parseTypeArray(type)\r\n    var subArray = type.slice(0, type.lastIndexOf('['))\r\n    subArray = parseType(subArray)\r\n    ret = {\r\n      isArray: true,\r\n      name: type,\r\n      size: size,\r\n      memoryUsage: size === 'dynamic' ? 32 : subArray.memoryUsage * size,\r\n      subArray: subArray\r\n    }\r\n    return ret\r\n  } else {\r\n    var rawType\r\n    switch (type) {\r\n      case 'address':\r\n        rawType = 'uint160'\r\n        break\r\n      case 'bool':\r\n        rawType = 'uint8'\r\n        break\r\n      case 'string':\r\n        rawType = 'bytes'\r\n        break\r\n    }\r\n    ret = {\r\n      rawType: rawType,\r\n      name: type,\r\n      memoryUsage: 32\r\n    }\r\n\r\n    if (type.startsWith('bytes') && type !== 'bytes' || type.startsWith('uint') || type.startsWith('int')) {\r\n      ret.size = parseTypeN(type)\r\n    } else if (type.startsWith('ufixed') || type.startsWith('fixed')) {\r\n      ret.size = parseTypeNxM(type)\r\n    }\r\n\r\n    if (type.startsWith('bytes') && type !== 'bytes' && (ret.size < 1 || ret.size > 32)) {\r\n      throw new Error('Invalid bytes<N> width: ' + ret.size)\r\n    }\r\n    if ((type.startsWith('uint') || type.startsWith('int')) && (ret.size % 8 || ret.size < 8 || ret.size > 256)) {\r\n      throw new Error('Invalid int/uint<N> width: ' + ret.size)\r\n    }\r\n    return ret\r\n  }\r\n}\r\n\r\n// Is a type dynamic?\r\nfunction isDynamic (type) {\r\n  // FIXME: handle all types? I don't think anything is missing now\r\n  return (type === 'string') || (type === 'bytes') || (parseTypeArray(type) === 'dynamic')\r\n}\r\n\r\n// Is a type an array?\r\nfunction isArray (type) {\r\n  return type.lastIndexOf(']') === type.length - 1\r\n}\r\n\r\nABI.elementaryName = elementaryName\r\nABI.encodeSingle = encodeSingle\r\nABI.isDynamic = isDynamic\r\n\r\n// Encode a method/event with arguments\r\n// @types an array of string type names\r\n// @args  an array of the appropriate values\r\nABI.rawEncode = function (types, values) {\r\n  var output = []\r\n  var data = []\r\n\r\n  var headLength = 32 * types.length\r\n\r\n  for (var i in types) {\r\n    var type = elementaryName(types[i])\r\n    var value = values[i]\r\n    var cur = encodeSingle(type, value)\r\n\r\n    // Use the head/tail method for storing dynamic data\r\n    if (isDynamic(type)) {\r\n      output.push(encodeSingle('uint256', headLength))\r\n      data.push(cur)\r\n      headLength += cur.length\r\n    } else {\r\n      output.push(cur)\r\n    }\r\n  }\r\n\r\n  return Buffer.concat(output.concat(data))\r\n}\r\n\r\nABI.rawDecode = function (types, data) {\r\n  var ret = []\r\n  data = new Buffer(data)\r\n  var offset = 0\r\n  for (var i in types) {\r\n    var type = elementaryName(types[i])\r\n    var parsed = parseType(type, data, offset)\r\n    var decoded = decodeSingle(parsed, data, offset)\r\n    offset += parsed.memoryUsage\r\n    ret.push(decoded)\r\n  }\r\n  return ret\r\n}\r\n\r\nABI.simpleEncode = function (method) {\r\n  var args = Array.prototype.slice.call(arguments).slice(1)\r\n  var sig = parseSignature(method)\r\n\r\n  // FIXME: validate/convert arguments\r\n  if (args.length !== sig.args.length) {\r\n    throw new Error('Argument count mismatch')\r\n  }\r\n\r\n  return Buffer.concat([ ABI.methodID(sig.method, sig.args), ABI.rawEncode(sig.args, args) ])\r\n}\r\n\r\nABI.simpleDecode = function (method, data) {\r\n  var sig = parseSignature(method)\r\n\r\n  // FIXME: validate/convert arguments\r\n  if (!sig.retargs) {\r\n    throw new Error('No return values in method')\r\n  }\r\n\r\n  return ABI.rawDecode(sig.retargs, data)\r\n}\r\n\r\nfunction stringify (type, value) {\r\n  if (type.startsWith('address') || type.startsWith('bytes')) {\r\n    return '0x' + value.toString('hex')\r\n  } else {\r\n    return value.toString()\r\n  }\r\n}\r\n\r\nABI.stringify = function (types, values) {\r\n  var ret = []\r\n\r\n  for (var i in types) {\r\n    var type = types[i]\r\n    var value = values[i]\r\n\r\n    // if it is an array type, concat the items\r\n    if (/^[^\\[]+\\[.*\\]$/.test(type)) {\r\n      value = value.map(function (item) {\r\n        return stringify(type, item)\r\n      }).join(', ')\r\n    } else {\r\n      value = stringify(type, value)\r\n    }\r\n\r\n    ret.push(value)\r\n  }\r\n\r\n  return ret\r\n}\r\n\r\nABI.solidityPack = function (types, values) {\r\n  if (types.length !== values.length) {\r\n    throw new Error('Number of types are not matching the values')\r\n  }\r\n\r\n  var size, num\r\n  var ret = []\r\n\r\n  for (var i = 0; i < types.length; i++) {\r\n    var type = elementaryName(types[i])\r\n    var value = values[i]\r\n\r\n    if (type === 'bytes') {\r\n      ret.push(value)\r\n    } else if (type === 'string') {\r\n      ret.push(new Buffer(value, 'utf8'))\r\n    } else if (type === 'bool') {\r\n      ret.push(new Buffer(value ? '01' : '00', 'hex'))\r\n    } else if (type === 'address') {\r\n      ret.push(utils.setLengthLeft(value, 20))\r\n    } else if (type.startsWith('bytes')) {\r\n      size = parseTypeN(type)\r\n      if (size < 1 || size > 32) {\r\n        throw new Error('Invalid bytes<N> width: ' + size)\r\n      }\r\n\r\n      ret.push(utils.setLengthRight(value, size))\r\n    } else if (type.startsWith('uint')) {\r\n      size = parseTypeN(type)\r\n      if ((size % 8) || (size < 8) || (size > 256)) {\r\n        throw new Error('Invalid uint<N> width: ' + size)\r\n      }\r\n\r\n      num = parseNumber(value)\r\n      if (num.bitLength() > size) {\r\n        throw new Error('Supplied uint exceeds width: ' + size + ' vs ' + num.bitLength())\r\n      }\r\n\r\n      ret.push(num.toArrayLike(Buffer, 'be', size / 8))\r\n    } else if (type.startsWith('int')) {\r\n      size = parseTypeN(type)\r\n      if ((size % 8) || (size < 8) || (size > 256)) {\r\n        throw new Error('Invalid int<N> width: ' + size)\r\n      }\r\n\r\n      num = parseNumber(value)\r\n      if (num.bitLength() > size) {\r\n        throw new Error('Supplied int exceeds width: ' + size + ' vs ' + num.bitLength())\r\n      }\r\n\r\n      ret.push(num.toTwos(size).toArrayLike(Buffer, 'be', size / 8))\r\n    } else {\r\n      // FIXME: support all other types\r\n      throw new Error('Unsupported or invalid type: ' + type)\r\n    }\r\n  }\r\n\r\n  return Buffer.concat(ret)\r\n}\r\n\r\nABI.soliditySHA3 = function (types, values) {\r\n  return utils.sha3(ABI.solidityPack(types, values))\r\n}\r\n\r\nABI.soliditySHA256 = function (types, values) {\r\n  return utils.sha256(ABI.solidityPack(types, values))\r\n}\r\n\r\nABI.solidityRIPEMD160 = function (types, values) {\r\n  return utils.ripemd160(ABI.solidityPack(types, values), true)\r\n}\r\n\r\n// Serpent's users are familiar with this encoding\r\n// - s: string\r\n// - b: bytes\r\n// - b<N>: bytes<N>\r\n// - i: int256\r\n// - a: int256[]\r\n\r\nfunction isNumeric (c) {\r\n  // FIXME: is this correct? Seems to work\r\n  return (c >= '0') && (c <= '9')\r\n}\r\n\r\n// For a \"documentation\" refer to https://github.com/ethereum/serpent/blob/develop/preprocess.cpp\r\nABI.fromSerpent = function (sig) {\r\n  var ret = []\r\n  for (var i = 0; i < sig.length; i++) {\r\n    var type = sig[i]\r\n    if (type === 's') {\r\n      ret.push('bytes')\r\n    } else if (type === 'b') {\r\n      var tmp = 'bytes'\r\n      var j = i + 1\r\n      while ((j < sig.length) && isNumeric(sig[j])) {\r\n        tmp += sig[j] - '0'\r\n        j++\r\n      }\r\n      i = j - 1\r\n      ret.push(tmp)\r\n    } else if (type === 'i') {\r\n      ret.push('int256')\r\n    } else if (type === 'a') {\r\n      ret.push('int256[]')\r\n    } else {\r\n      throw new Error('Unsupported or invalid type: ' + type)\r\n    }\r\n  }\r\n  return ret\r\n}\r\n\r\nABI.toSerpent = function (types) {\r\n  var ret = []\r\n  for (var i = 0; i < types.length; i++) {\r\n    var type = types[i]\r\n    if (type === 'bytes') {\r\n      ret.push('s')\r\n    } else if (type.startsWith('bytes')) {\r\n      ret.push('b' + parseTypeN(type))\r\n    } else if (type === 'int256') {\r\n      ret.push('i')\r\n    } else if (type === 'int256[]') {\r\n      ret.push('a')\r\n    } else {\r\n      throw new Error('Unsupported or invalid type: ' + type)\r\n    }\r\n  }\r\n  return ret.join('')\r\n}\r\n\r\nmodule.exports = ABI\r\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}