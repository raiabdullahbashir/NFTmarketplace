{"ast":null,"code":"\"use strict\";\n\nvar __assign = this && this.__assign || Object.assign || function (t) {\n  for (var s, i = 1, n = arguments.length; i < n; i++) {\n    s = arguments[i];\n\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n  }\n\n  return t;\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar types_1 = require(\"@0xproject/types\");\n\nvar _ = require(\"lodash\");\n\nvar Web3 = require(\"web3\");\n\nvar SolidityCoder = require(\"web3/lib/solidity/coder\");\n\nvar configured_bignumber_1 = require(\"./configured_bignumber\");\n\nvar AbiDecoder =\n/** @class */\nfunction () {\n  function AbiDecoder(abiArrays) {\n    this._savedABIs = [];\n    this._methodIds = {};\n\n    _.forEach(abiArrays, this._addABI.bind(this));\n  }\n\n  AbiDecoder._padZeros = function (address) {\n    var formatted = address;\n\n    if (_.startsWith(formatted, '0x')) {\n      formatted = formatted.slice(2);\n    }\n\n    formatted = _.padStart(formatted, 40, '0');\n    return \"0x\" + formatted;\n  }; // This method can only decode logs from the 0x & ERC20 smart contracts\n\n\n  AbiDecoder.prototype.tryToDecodeLogOrNoop = function (log) {\n    var methodId = log.topics[0];\n    var event = this._methodIds[methodId];\n\n    if (_.isUndefined(event)) {\n      return log;\n    }\n\n    var logData = log.data;\n    var decodedParams = {};\n    var dataIndex = 0;\n    var topicsIndex = 1;\n\n    var nonIndexedInputs = _.filter(event.inputs, function (input) {\n      return !input.indexed;\n    });\n\n    var dataTypes = _.map(nonIndexedInputs, function (input) {\n      return input.type;\n    });\n\n    var decodedData = SolidityCoder.decodeParams(dataTypes, logData.slice('0x'.length));\n    var failedToDecode = false;\n\n    _.forEach(event.inputs, function (param) {\n      // Indexed parameters are stored in topics. Non-indexed ones in decodedData\n      var value = param.indexed ? log.topics[topicsIndex++] : decodedData[dataIndex++];\n\n      if (_.isUndefined(value)) {\n        failedToDecode = true;\n        return;\n      }\n\n      if (param.type === types_1.SolidityTypes.Address) {\n        value = AbiDecoder._padZeros(new configured_bignumber_1.BigNumber(value).toString(16));\n      } else if (param.type === types_1.SolidityTypes.Uint256 || param.type === types_1.SolidityTypes.Uint8 || param.type === types_1.SolidityTypes.Uint) {\n        value = new configured_bignumber_1.BigNumber(value);\n      }\n\n      decodedParams[param.name] = value;\n    });\n\n    if (failedToDecode) {\n      return log;\n    } else {\n      return __assign({}, log, {\n        event: event.name,\n        args: decodedParams\n      });\n    }\n  };\n\n  AbiDecoder.prototype._addABI = function (abiArray) {\n    var _this = this;\n\n    _.map(abiArray, function (abi) {\n      if (abi.type === types_1.AbiType.Event) {\n        var signature = abi.name + \"(\" + _.map(abi.inputs, function (input) {\n          return input.type;\n        }).join(',') + \")\";\n        var signatureHash = new Web3().sha3(signature);\n        _this._methodIds[signatureHash] = abi;\n      }\n    });\n\n    this._savedABIs = this._savedABIs.concat(abiArray);\n  };\n\n  return AbiDecoder;\n}();\n\nexports.AbiDecoder = AbiDecoder;","map":{"version":3,"sources":["../src/abi_decoder.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nvar __assign = (this && this.__assign) || Object.assign || function(t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n        s = arguments[i];\n        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n            t[p] = s[p];\n    }\n    return t;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar types_1 = require(\"@0xproject/types\");\nvar _ = require(\"lodash\");\nvar Web3 = require(\"web3\");\nvar SolidityCoder = require(\"web3/lib/solidity/coder\");\nvar configured_bignumber_1 = require(\"./configured_bignumber\");\nvar AbiDecoder = /** @class */ (function () {\n    function AbiDecoder(abiArrays) {\n        this._savedABIs = [];\n        this._methodIds = {};\n        _.forEach(abiArrays, this._addABI.bind(this));\n    }\n    AbiDecoder._padZeros = function (address) {\n        var formatted = address;\n        if (_.startsWith(formatted, '0x')) {\n            formatted = formatted.slice(2);\n        }\n        formatted = _.padStart(formatted, 40, '0');\n        return \"0x\" + formatted;\n    };\n    // This method can only decode logs from the 0x & ERC20 smart contracts\n    AbiDecoder.prototype.tryToDecodeLogOrNoop = function (log) {\n        var methodId = log.topics[0];\n        var event = this._methodIds[methodId];\n        if (_.isUndefined(event)) {\n            return log;\n        }\n        var logData = log.data;\n        var decodedParams = {};\n        var dataIndex = 0;\n        var topicsIndex = 1;\n        var nonIndexedInputs = _.filter(event.inputs, function (input) { return !input.indexed; });\n        var dataTypes = _.map(nonIndexedInputs, function (input) { return input.type; });\n        var decodedData = SolidityCoder.decodeParams(dataTypes, logData.slice('0x'.length));\n        var failedToDecode = false;\n        _.forEach(event.inputs, function (param) {\n            // Indexed parameters are stored in topics. Non-indexed ones in decodedData\n            var value = param.indexed ? log.topics[topicsIndex++] : decodedData[dataIndex++];\n            if (_.isUndefined(value)) {\n                failedToDecode = true;\n                return;\n            }\n            if (param.type === types_1.SolidityTypes.Address) {\n                value = AbiDecoder._padZeros(new configured_bignumber_1.BigNumber(value).toString(16));\n            }\n            else if (param.type === types_1.SolidityTypes.Uint256 ||\n                param.type === types_1.SolidityTypes.Uint8 ||\n                param.type === types_1.SolidityTypes.Uint) {\n                value = new configured_bignumber_1.BigNumber(value);\n            }\n            decodedParams[param.name] = value;\n        });\n        if (failedToDecode) {\n            return log;\n        }\n        else {\n            return __assign({}, log, { event: event.name, args: decodedParams });\n        }\n    };\n    AbiDecoder.prototype._addABI = function (abiArray) {\n        var _this = this;\n        _.map(abiArray, function (abi) {\n            if (abi.type === types_1.AbiType.Event) {\n                var signature = abi.name + \"(\" + _.map(abi.inputs, function (input) { return input.type; }).join(',') + \")\";\n                var signatureHash = new Web3().sha3(signature);\n                _this._methodIds[signatureHash] = abi;\n            }\n        });\n        this._savedABIs = this._savedABIs.concat(abiArray);\n    };\n    return AbiDecoder;\n}());\nexports.AbiDecoder = AbiDecoder;\n//# sourceMappingURL=abi_decoder.js.map"]},"metadata":{},"sourceType":"script"}