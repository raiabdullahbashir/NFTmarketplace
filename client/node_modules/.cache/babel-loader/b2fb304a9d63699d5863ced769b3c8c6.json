{"ast":null,"code":"import { each, createInterpolator, is, toArray, Globals, useForceUpdate, useOnce } from '@react-spring/shared';\nimport _extends from '@babel/runtime/helpers/esm/extends';\nimport { createAnimatedTransform, createAnimatedInterpolation, now, createAnimatedStyle, applyAnimatedValues, getComponentProps } from '@react-spring/shared/globals';\nexport { createAnimatedInterpolation as to } from '@react-spring/shared/globals';\nimport { deprecateInterpolate } from '@react-spring/shared/deprecations';\nimport invariant from 'tiny-invariant';\nimport React, { forwardRef, useRef, useEffect } from 'react';\n\nvar _a;\n\nconst animatedTag = Symbol.for('isAnimated');\n\nconst isAnimated = val => !!(val && val[animatedTag]);\n\nclass Animated {\n  constructor() {\n    this[_a] = true;\n    this.children = new Set();\n  }\n  /** Returns the set of `AnimatedValue` nodes contained by this node. */\n\n\n  getPayload() {\n    return this.payload;\n  }\n  /** Returns the set of animated nodes that depend on this node. */\n\n\n  getChildren() {\n    return this.children;\n  }\n\n  addChild(child) {\n    this.children.size || this._attach();\n    this.children.add(child);\n  }\n\n  removeChild(child) {\n    this.children.delete(child);\n    this.children.size || this._detach();\n  }\n\n}\n\n_a = animatedTag;\n\nclass AnimatedObject extends Animated {\n  constructor(source) {\n    super();\n    this.source = source;\n    this.payload = toPayload(source);\n  }\n\n  getValue(animated) {\n    const obj = {};\n    each(this.source, (val, key) => {\n      if (isAnimated(val)) {\n        obj[key] = val.getValue(animated);\n      } else if (!animated) {\n        obj[key] = val;\n      }\n    });\n    return obj;\n  }\n\n  updatePayload(prev, next) {\n    const source = _extends({}, this.source);\n\n    each(source, (val, key) => {\n      if (val === prev) source[key] = next;\n    });\n    this.source = source;\n    this.payload = toPayload(source);\n  }\n\n  _attach() {\n    each(this.source, addChild, this);\n  }\n\n  _detach() {\n    each(this.source, removeChild, this);\n  }\n\n}\n/** Convert an array or object to a flat payload */\n\n\nfunction toPayload(source) {\n  const payload = new Set();\n  each(source, val => {\n    if (isAnimated(val)) {\n      each(val.getPayload(), node => payload.add(node));\n    }\n  });\n  return payload;\n}\n\nfunction addChild(parent) {\n  if (isAnimated(parent)) parent.addChild(this);\n}\n\nfunction removeChild(parent) {\n  if (isAnimated(parent)) parent.removeChild(this);\n}\n\nclass AnimatedStyle extends AnimatedObject {\n  constructor(style) {\n    if (style === void 0) {\n      style = {};\n    }\n\n    super(style.transform && createAnimatedTransform ? _extends({}, style, {\n      transform: createAnimatedTransform(style.transform)\n    }) : style);\n  }\n\n}\n\nclass AnimatedInterpolation extends Animated {\n  constructor(source, args) {\n    super();\n    this.source = source;\n    this.calc = createInterpolator(...args);\n  }\n\n  getValue(animated) {\n    const args = is.arr(this.source) ? this.source.map(node => node.getValue(animated)) : toArray(this.source.getValue(animated));\n    return this.calc(...args);\n  }\n\n  to() {\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    return new AnimatedInterpolation(this, args);\n  }\n\n  interpolate() {\n    deprecateInterpolate();\n    return this.to(...arguments);\n  }\n\n  getPayload() {\n    return is.arr(this.source) ? this.payload || (this.payload = toPayload(this.source)) : this.source.getPayload();\n  }\n\n  updatePayload(prev, next) {\n    this.payload = void 0;\n\n    if (is.arr(this.source)) {\n      const source = [...this.source];\n      each(source, (val, index) => {\n        if (val === prev) source[index] = next;\n      });\n      this.source = source;\n    } else {\n      this.source = next;\n    }\n  }\n\n  _attach() {\n    each(toArray(this.source), addChild, this);\n  }\n\n  _detach() {\n    each(toArray(this.source), removeChild, this);\n  }\n\n}\n\nGlobals.assign({\n  createAnimatedStyle: style => new AnimatedStyle(style),\n  createAnimatedInterpolation: function createAnimatedInterpolation(parents) {\n    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n      args[_key - 1] = arguments[_key];\n    }\n\n    return new AnimatedInterpolation(parents, args);\n  }\n});\n\nconst interpolate = function interpolate() {\n  deprecateInterpolate();\n  return createAnimatedInterpolation(...arguments);\n};\n/** An animated number or a native attribute value */\n\n\nclass AnimatedValue extends Animated {\n  constructor(value) {\n    super();\n    this.views = new Set();\n    this.done = false;\n    this.value = value;\n    this.payload = new Set([this]);\n\n    if (is.num(value)) {\n      this.startPosition = value;\n      this.lastPosition = value;\n    }\n  }\n\n  getValue() {\n    return this.value;\n  }\n\n  setValue(value, flush) {\n    this.value = value;\n\n    if (flush !== false) {\n      if (!this.views.size) {\n        collectViews(this, this.views);\n      }\n\n      each(this.views, view => view.update());\n    }\n  }\n\n  to() {\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    return createAnimatedInterpolation(this, ...args);\n  }\n\n  interpolate() {\n    deprecateInterpolate();\n    return this.to(...arguments);\n  }\n\n  reset(isActive) {\n    if (is.num(this.value)) {\n      this.startPosition = this.value;\n      this.lastPosition = this.value;\n      this.lastVelocity = isActive ? this.lastVelocity : undefined;\n      this.lastTime = isActive ? this.lastTime : undefined;\n      this.startTime = now();\n    }\n\n    this.done = false;\n    this.views.clear();\n  } // Do nothing for either of these.\n\n\n  _attach() {}\n\n  _detach() {}\n\n}\n/**\r\n * This library works by building a directed acyclic graph of dependencies\r\n * transparently whenever you render your Animated components.\r\n *\r\n *               new Animated.Value(0)\r\n *     .interpolate()        .interpolate()    new Animated.Value(1)\r\n *         opacity               translateY      scale\r\n *          style                         transform\r\n *         View#234                         style\r\n *                                         View#123\r\n *\r\n * A) Top Down phase\r\n * When an AnimatedValue is updated, we recursively go down through this\r\n * graph in order to find leaf nodes: the components that depend on our value.\r\n *\r\n * B) Bottom Up phase\r\n * When a view is flagged as needing an update, we recursively go back up\r\n * in order to build the new props that it needs. This two-phase process is\r\n * necessary because some props (eg: \"transform\") can have multiple parents.\r\n */\n\n\nfunction collectViews(node, views) {\n  if ('update' in node) {\n    views.add(node);\n  } else {\n    each(node.getChildren(), child => collectViews(child, views));\n  }\n}\n/** An array of animated nodes */\n\n\nclass AnimatedArray extends AnimatedObject {\n  constructor(source) {\n    super(source);\n  }\n\n  getValue(animated) {\n    return this.source.map(node => node.getValue(animated));\n  }\n\n  setValue(value, flush) {\n    const nodes = this.payload;\n\n    if (is.arr(value)) {\n      invariant(value.length == nodes.size);\n      let i = 0;\n      each(nodes, node => node.setValue(value[i++], flush));\n    } else {\n      each(nodes, node => node.setValue(value, flush));\n    }\n  }\n\n  to() {\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    return createAnimatedInterpolation(this, ...args);\n  }\n\n  interpolate() {\n    deprecateInterpolate();\n    return this.to(...arguments);\n  }\n\n  updatePayload(prev, next) {\n    const source = [...this.source];\n    each(source, (val, index) => {\n      if (val === prev) source[index] = next;\n    });\n    this.source = source;\n    this.payload = toPayload(source);\n  }\n\n}\n\nclass AnimatedProps extends AnimatedObject {\n  constructor(props, update) {\n    super(props.style && createAnimatedStyle ? _extends({}, props, {\n      style: createAnimatedStyle(props.style)\n    }) : props);\n    this.update = update;\n  }\n\n}\n\nconst cacheKey = Symbol.for('AnimatedComponent');\n\nconst withAnimated = Component => is.str(Component) ? createAnimatedComponent(Component) : Component[cacheKey] || (Component[cacheKey] = createAnimatedComponent(Component));\n\nconst createAnimatedComponent = Component => forwardRef((rawProps, ref) => {\n  const node = useRef(null);\n  const props = useRef(null);\n  const forceUpdate = useForceUpdate();\n  const nextProps = new AnimatedProps(rawProps, () => {\n    if (!node.current) return;\n    const didUpdate = applyAnimatedValues(node.current, nextProps.getValue(true)); // Re-render the component when native updates fail.\n\n    if (didUpdate === false) {\n      forceUpdate();\n    }\n  });\n  useEffect(() => {\n    const prevProps = props.current;\n    props.current = nextProps; // To avoid causing a cascade of detachment, we must detach\n    // the old props only *after* the new props are attached.\n\n    nextProps._attach();\n\n    if (prevProps) {\n      prevProps._detach();\n    }\n  }); // Ensure the latest props are detached on unmount.\n\n  useOnce(() => () => {\n    props.current._detach();\n  }); // Functions cannot have refs (see #569)\n\n  const refFn = !is.fun(Component) || Component.prototype.isReactComponent ? value => node.current = updateRef(ref, value) : void 0;\n  rawProps = getComponentProps(nextProps.getValue());\n  return React.createElement(Component, Object.assign({}, rawProps, {\n    ref: refFn\n  }));\n});\n\nfunction updateRef(ref, value) {\n  if (ref) {\n    if (is.fun(ref)) ref(value);else ref.current = value;\n  }\n\n  return value;\n}\n/**\r\n * Pass the given components to `withAnimated` and add the newly animated\r\n * components to `withAnimated` as properties.\r\n */\n\n\nconst extendAnimated = (withAnimated, components, lowercase) => {\n  components.forEach(Component => {\n    let key = getDisplayName(Component);\n\n    if (lowercase) {\n      key = key[0].toLowerCase() + key.slice(1);\n    }\n\n    withAnimated[key] = withAnimated(Component);\n  });\n  return withAnimated;\n};\n\nconst getDisplayName = arg => is.str(arg) ? arg : arg && is.str(arg.displayName) ? arg.displayName : is.fun(arg) && arg.name || null;\n\nexport { Animated, AnimatedArray, AnimatedInterpolation, AnimatedObject, AnimatedProps, AnimatedStyle, AnimatedValue, addChild, animatedTag, extendAnimated, interpolate, isAnimated, removeChild, toPayload, withAnimated };","map":{"version":3,"sources":["src/Animated.ts","src/AnimatedObject.ts","src/AnimatedStyle.ts","src/AnimatedInterpolation.ts","src/globals.ts","src/interpolate.ts","src/AnimatedValue.ts","src/AnimatedArray.ts","src/AnimatedProps.ts","src/withAnimated.tsx"],"names":["animatedTag","Symbol","isAnimated","val","Animated","getPayload","getChildren","addChild","removeChild","AnimatedObject","constructor","source","toPayload","getValue","obj","each","updatePayload","_attach","_detach","payload","node","parent","AnimatedStyle","style","transform","G","AnimatedInterpolation","args","createInterpolator","is","toArray","to","interpolate","deprecateInterpolate","Globals","createAnimatedStyle","createAnimatedInterpolation","AnimatedValue","value","setValue","flush","collectViews","view","reset","isActive","views","child","AnimatedArray","nodes","invariant","i","AnimatedProps","props","cacheKey","withAnimated","Component","createAnimatedComponent","forwardRef","useRef","forceUpdate","useForceUpdate","nextProps","didUpdate","useEffect","prevProps","useOnce","refFn","updateRef","rawProps","ref","extendAnimated","components","key","getDisplayName","arg"],"mappings":"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","sourcesContent":["import { each, createInterpolator, is, toArray, Globals, useForceUpdate, useOnce } from '@react-spring/shared';\nimport _extends from '@babel/runtime/helpers/esm/extends';\nimport { createAnimatedTransform, createAnimatedInterpolation, now, createAnimatedStyle, applyAnimatedValues, getComponentProps } from '@react-spring/shared/globals';\nexport { createAnimatedInterpolation as to } from '@react-spring/shared/globals';\nimport { deprecateInterpolate } from '@react-spring/shared/deprecations';\nimport invariant from 'tiny-invariant';\nimport React, { forwardRef, useRef, useEffect } from 'react';\n\nvar _a;\n\nconst animatedTag = Symbol.for('isAnimated');\nconst isAnimated = val => !!(val && val[animatedTag]);\nclass Animated {\n  constructor() {\n    this[_a] = true;\n    this.children = new Set();\n  }\n  /** Returns the set of `AnimatedValue` nodes contained by this node. */\n\n\n  getPayload() {\n    return this.payload;\n  }\n  /** Returns the set of animated nodes that depend on this node. */\n\n\n  getChildren() {\n    return this.children;\n  }\n\n  addChild(child) {\n    this.children.size || this._attach();\n    this.children.add(child);\n  }\n\n  removeChild(child) {\n    this.children.delete(child);\n    this.children.size || this._detach();\n  }\n\n}\n_a = animatedTag;\n\nclass AnimatedObject extends Animated {\n  constructor(source) {\n    super();\n    this.source = source;\n    this.payload = toPayload(source);\n  }\n\n  getValue(animated) {\n    const obj = {};\n    each(this.source, (val, key) => {\n      if (isAnimated(val)) {\n        obj[key] = val.getValue(animated);\n      } else if (!animated) {\n        obj[key] = val;\n      }\n    });\n    return obj;\n  }\n\n  updatePayload(prev, next) {\n    const source = _extends({}, this.source);\n\n    each(source, (val, key) => {\n      if (val === prev) source[key] = next;\n    });\n    this.source = source;\n    this.payload = toPayload(source);\n  }\n\n  _attach() {\n    each(this.source, addChild, this);\n  }\n\n  _detach() {\n    each(this.source, removeChild, this);\n  }\n\n}\n/** Convert an array or object to a flat payload */\n\nfunction toPayload(source) {\n  const payload = new Set();\n  each(source, val => {\n    if (isAnimated(val)) {\n      each(val.getPayload(), node => payload.add(node));\n    }\n  });\n  return payload;\n}\nfunction addChild(parent) {\n  if (isAnimated(parent)) parent.addChild(this);\n}\nfunction removeChild(parent) {\n  if (isAnimated(parent)) parent.removeChild(this);\n}\n\nclass AnimatedStyle extends AnimatedObject {\n  constructor(style) {\n    if (style === void 0) {\n      style = {};\n    }\n\n    super(style.transform && createAnimatedTransform ? _extends({}, style, {\n      transform: createAnimatedTransform(style.transform)\n    }) : style);\n  }\n\n}\n\nclass AnimatedInterpolation extends Animated {\n  constructor(source, args) {\n    super();\n    this.source = source;\n    this.calc = createInterpolator(...args);\n  }\n\n  getValue(animated) {\n    const args = is.arr(this.source) ? this.source.map(node => node.getValue(animated)) : toArray(this.source.getValue(animated));\n    return this.calc(...args);\n  }\n\n  to() {\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    return new AnimatedInterpolation(this, args);\n  }\n\n  interpolate() {\n    deprecateInterpolate();\n    return this.to(...arguments);\n  }\n\n  getPayload() {\n    return is.arr(this.source) ? this.payload || (this.payload = toPayload(this.source)) : this.source.getPayload();\n  }\n\n  updatePayload(prev, next) {\n    this.payload = void 0;\n\n    if (is.arr(this.source)) {\n      const source = [...this.source];\n      each(source, (val, index) => {\n        if (val === prev) source[index] = next;\n      });\n      this.source = source;\n    } else {\n      this.source = next;\n    }\n  }\n\n  _attach() {\n    each(toArray(this.source), addChild, this);\n  }\n\n  _detach() {\n    each(toArray(this.source), removeChild, this);\n  }\n\n}\n\nGlobals.assign({\n  createAnimatedStyle: style => new AnimatedStyle(style),\n  createAnimatedInterpolation: function createAnimatedInterpolation(parents) {\n    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n      args[_key - 1] = arguments[_key];\n    }\n\n    return new AnimatedInterpolation(parents, args);\n  }\n});\n\nconst interpolate = function interpolate() {\n  deprecateInterpolate();\n  return createAnimatedInterpolation(...arguments);\n};\n\n/** An animated number or a native attribute value */\n\nclass AnimatedValue extends Animated {\n  constructor(value) {\n    super();\n    this.views = new Set();\n    this.done = false;\n    this.value = value;\n    this.payload = new Set([this]);\n\n    if (is.num(value)) {\n      this.startPosition = value;\n      this.lastPosition = value;\n    }\n  }\n\n  getValue() {\n    return this.value;\n  }\n\n  setValue(value, flush) {\n    this.value = value;\n\n    if (flush !== false) {\n      if (!this.views.size) {\n        collectViews(this, this.views);\n      }\n\n      each(this.views, view => view.update());\n    }\n  }\n\n  to() {\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    return createAnimatedInterpolation(this, ...args);\n  }\n\n  interpolate() {\n    deprecateInterpolate();\n    return this.to(...arguments);\n  }\n\n  reset(isActive) {\n    if (is.num(this.value)) {\n      this.startPosition = this.value;\n      this.lastPosition = this.value;\n      this.lastVelocity = isActive ? this.lastVelocity : undefined;\n      this.lastTime = isActive ? this.lastTime : undefined;\n      this.startTime = now();\n    }\n\n    this.done = false;\n    this.views.clear();\n  } // Do nothing for either of these.\n\n\n  _attach() {}\n\n  _detach() {}\n\n}\n/**\r\n * This library works by building a directed acyclic graph of dependencies\r\n * transparently whenever you render your Animated components.\r\n *\r\n *               new Animated.Value(0)\r\n *     .interpolate()        .interpolate()    new Animated.Value(1)\r\n *         opacity               translateY      scale\r\n *          style                         transform\r\n *         View#234                         style\r\n *                                         View#123\r\n *\r\n * A) Top Down phase\r\n * When an AnimatedValue is updated, we recursively go down through this\r\n * graph in order to find leaf nodes: the components that depend on our value.\r\n *\r\n * B) Bottom Up phase\r\n * When a view is flagged as needing an update, we recursively go back up\r\n * in order to build the new props that it needs. This two-phase process is\r\n * necessary because some props (eg: \"transform\") can have multiple parents.\r\n */\n\nfunction collectViews(node, views) {\n  if ('update' in node) {\n    views.add(node);\n  } else {\n    each(node.getChildren(), child => collectViews(child, views));\n  }\n}\n\n/** An array of animated nodes */\n\nclass AnimatedArray extends AnimatedObject {\n  constructor(source) {\n    super(source);\n  }\n\n  getValue(animated) {\n    return this.source.map(node => node.getValue(animated));\n  }\n\n  setValue(value, flush) {\n    const nodes = this.payload;\n\n    if (is.arr(value)) {\n      invariant(value.length == nodes.size);\n      let i = 0;\n      each(nodes, node => node.setValue(value[i++], flush));\n    } else {\n      each(nodes, node => node.setValue(value, flush));\n    }\n  }\n\n  to() {\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    return createAnimatedInterpolation(this, ...args);\n  }\n\n  interpolate() {\n    deprecateInterpolate();\n    return this.to(...arguments);\n  }\n\n  updatePayload(prev, next) {\n    const source = [...this.source];\n    each(source, (val, index) => {\n      if (val === prev) source[index] = next;\n    });\n    this.source = source;\n    this.payload = toPayload(source);\n  }\n\n}\n\nclass AnimatedProps extends AnimatedObject {\n  constructor(props, update) {\n    super(props.style && createAnimatedStyle ? _extends({}, props, {\n      style: createAnimatedStyle(props.style)\n    }) : props);\n    this.update = update;\n  }\n\n}\n\nconst cacheKey = Symbol.for('AnimatedComponent');\nconst withAnimated = Component => is.str(Component) ? createAnimatedComponent(Component) : Component[cacheKey] || (Component[cacheKey] = createAnimatedComponent(Component));\n\nconst createAnimatedComponent = Component => forwardRef((rawProps, ref) => {\n  const node = useRef(null);\n  const props = useRef(null);\n  const forceUpdate = useForceUpdate();\n  const nextProps = new AnimatedProps(rawProps, () => {\n    if (!node.current) return;\n    const didUpdate = applyAnimatedValues(node.current, nextProps.getValue(true)); // Re-render the component when native updates fail.\n\n    if (didUpdate === false) {\n      forceUpdate();\n    }\n  });\n  useEffect(() => {\n    const prevProps = props.current;\n    props.current = nextProps; // To avoid causing a cascade of detachment, we must detach\n    // the old props only *after* the new props are attached.\n\n    nextProps._attach();\n\n    if (prevProps) {\n      prevProps._detach();\n    }\n  }); // Ensure the latest props are detached on unmount.\n\n  useOnce(() => () => {\n    props.current._detach();\n  }); // Functions cannot have refs (see #569)\n\n  const refFn = !is.fun(Component) || Component.prototype.isReactComponent ? value => node.current = updateRef(ref, value) : void 0;\n  rawProps = getComponentProps(nextProps.getValue());\n  return React.createElement(Component, Object.assign({}, rawProps, {\n    ref: refFn\n  }));\n});\n\nfunction updateRef(ref, value) {\n  if (ref) {\n    if (is.fun(ref)) ref(value);else ref.current = value;\n  }\n\n  return value;\n}\n/**\r\n * Pass the given components to `withAnimated` and add the newly animated\r\n * components to `withAnimated` as properties.\r\n */\n\n\nconst extendAnimated = (withAnimated, components, lowercase) => {\n  components.forEach(Component => {\n    let key = getDisplayName(Component);\n\n    if (lowercase) {\n      key = key[0].toLowerCase() + key.slice(1);\n    }\n\n    withAnimated[key] = withAnimated(Component);\n  });\n  return withAnimated;\n};\n\nconst getDisplayName = arg => is.str(arg) ? arg : arg && is.str(arg.displayName) ? arg.displayName : is.fun(arg) && arg.name || null;\n\nexport { Animated, AnimatedArray, AnimatedInterpolation, AnimatedObject, AnimatedProps, AnimatedStyle, AnimatedValue, addChild, animatedTag, extendAnimated, interpolate, isAnimated, removeChild, toPayload, withAnimated };\n//# sourceMappingURL=index.js.map\n"]},"metadata":{},"sourceType":"module"}