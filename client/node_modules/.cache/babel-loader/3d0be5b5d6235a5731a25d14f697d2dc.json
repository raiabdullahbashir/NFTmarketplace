{"ast":null,"code":"import _objectWithoutPropertiesLoose from '@babel/runtime/helpers/esm/objectWithoutPropertiesLoose';\nimport { Globals } from '@react-spring/core';\nexport * from '@react-spring/core';\nimport { createStringInterpolator } from '@react-spring/shared/stringInterpolation';\nimport { is, each } from '@react-spring/shared';\nimport { AnimatedObject, isAnimated, AnimatedArray, AnimatedValue, to, extendAnimated, withAnimated } from '@react-spring/animated';\nimport colorNames from '@react-spring/shared/colors';\nlet isUnitlessNumber = {\n  animationIterationCount: true,\n  borderImageOutset: true,\n  borderImageSlice: true,\n  borderImageWidth: true,\n  boxFlex: true,\n  boxFlexGroup: true,\n  boxOrdinalGroup: true,\n  columnCount: true,\n  columns: true,\n  flex: true,\n  flexGrow: true,\n  flexPositive: true,\n  flexShrink: true,\n  flexNegative: true,\n  flexOrder: true,\n  gridRow: true,\n  gridRowEnd: true,\n  gridRowSpan: true,\n  gridRowStart: true,\n  gridColumn: true,\n  gridColumnEnd: true,\n  gridColumnSpan: true,\n  gridColumnStart: true,\n  fontWeight: true,\n  lineClamp: true,\n  lineHeight: true,\n  opacity: true,\n  order: true,\n  orphans: true,\n  tabSize: true,\n  widows: true,\n  zIndex: true,\n  zoom: true,\n  // SVG-related properties\n  fillOpacity: true,\n  floodOpacity: true,\n  stopOpacity: true,\n  strokeDasharray: true,\n  strokeDashoffset: true,\n  strokeMiterlimit: true,\n  strokeOpacity: true,\n  strokeWidth: true\n};\n\nconst prefixKey = (prefix, key) => prefix + key.charAt(0).toUpperCase() + key.substring(1);\n\nconst prefixes = ['Webkit', 'Ms', 'Moz', 'O'];\nisUnitlessNumber = Object.keys(isUnitlessNumber).reduce((acc, prop) => {\n  prefixes.forEach(prefix => acc[prefixKey(prefix, prop)] = acc[prop]);\n  return acc;\n}, isUnitlessNumber);\n\nfunction dangerousStyleValue(name, value, isCustomProperty) {\n  if (value == null || typeof value === 'boolean' || value === '') return '';\n  if (!isCustomProperty && typeof value === 'number' && value !== 0 && !(isUnitlessNumber.hasOwnProperty(name) && isUnitlessNumber[name])) return value + 'px'; // Presumes implicit 'px' suffix for unitless numbers\n\n  return ('' + value).trim();\n}\n\nconst attributeCache = {};\n\nfunction applyAnimatedValues(instance, props) {\n  if (!instance.nodeType || !instance.setAttribute) {\n    return false;\n  }\n\n  const style = props.style,\n        children = props.children,\n        scrollTop = props.scrollTop,\n        scrollLeft = props.scrollLeft,\n        attributes = _objectWithoutPropertiesLoose(props, [\"style\", \"children\", \"scrollTop\", \"scrollLeft\"]);\n\n  if (scrollTop !== void 0) instance.scrollTop = scrollTop;\n  if (scrollLeft !== void 0) instance.scrollLeft = scrollLeft; // Set textContent, if children is an animatable value\n\n  if (children !== void 0) instance.textContent = children; // Apply CSS styles\n\n  for (let styleName in style) {\n    if (!style.hasOwnProperty(styleName)) continue;\n    var isCustomProperty = styleName.indexOf('--') === 0;\n    var styleValue = dangerousStyleValue(styleName, style[styleName], isCustomProperty);\n    if (styleName === 'float') styleName = 'cssFloat';\n    if (isCustomProperty) instance.style.setProperty(styleName, styleValue);else instance.style[styleName] = styleValue;\n  }\n\n  const isFilterElement = instance.nodeName === 'filter' || instance.parentNode && instance.parentNode.nodeName === 'filter'; // Apply DOM attributes\n\n  for (let name in attributes) {\n    // Attributes are written in dash case\n    const attributeName = isFilterElement || instance.hasAttribute(name) ? name : attributeCache[name] || (attributeCache[name] = name.replace(/([A-Z])/g, n => '-' + n.toLowerCase()));\n    instance.setAttribute(attributeName, attributes[name]);\n  }\n}\n/** The transform-functions\r\n * (https://developer.mozilla.org/fr/docs/Web/CSS/transform-function)\r\n * that you can pass as keys to your animated component style and that will be\r\n * animated. Perspective has been left out as it would conflict with the\r\n * non-transform perspective style.\r\n */\n\n\nconst domTransforms = ['matrix', 'translate', 'scale', 'rotate', 'skew']; // x, y, z and translate will get 'px' as unit default\n\nconst pxDefaults = ['x', 'y', 'z', 'translate']; // rotate and skew will get 'deg' as unit default\n\nconst dgDefaults = ['rotate', 'skew']; // adds a unit to the value when the value is unit-less (ie a number)\n\nconst mergeUnit = (value, unit) => is.num(value) && value !== 0 ? value + unit : value; // gets the default unit for a key\n\n\nconst getUnit = key => pxDefaults.some(name => key.startsWith(name)) ? 'px' : dgDefaults.some(name => key.startsWith(name)) ? 'deg' : '';\n/**\r\n * Returns the right Animated object based on the value type.\r\n *\r\n * x: AnimatedValue         --> x\r\n * 40px                     --> AnimatedValue(40px)\r\n * [40, 30]                 --> AnimatedValue([40,30])\r\n * [40, y: AnimatedValue]   --> AnimatedArray([AnimatedValue(40), y])\r\n *\r\n * @param value\r\n */\n\n\nconst ensureAnimated = function ensureAnimated(value) {\n  if (value === void 0) {\n    value = 0;\n  }\n\n  return is.arr(value) && value.some(isAnimated) ? new AnimatedArray(value.map(ensureAnimated)) : isAnimated(value) ? value : new AnimatedValue(value);\n};\n/**\r\n * Checks if the input value matches the identity value.\r\n *\r\n * isValueIdentity(0, 0)              --> true\r\n * isValueIdentity('0px', 0)          --> true\r\n * isValueIdentity([0, '0px', 0], 0)  --> true\r\n *\r\n * @param styleValue\r\n * @param id\r\n */\n\n\nconst isValueIdentity = (styleValue, id) => is.arr(styleValue) ? styleValue.every(v => isValueIdentity(v, id)) : is.num(styleValue) ? styleValue === id : parseFloat(styleValue) === id;\n/**\r\n * Checks if the style value is the identity for a given key.\r\n *\r\n * isTransformIdentity('scale', 1)               --> true\r\n * isTransformIdentity('scale', [1,1])\r\n * isTransformIdentity('rotate3d', [1,1,1,0])    --> true\r\n * isTransformIdentity('x', 0)                   --> true\r\n *\r\n * @param key\r\n * @param styleValue\r\n */\n\n\nconst isTransformIdentity = (key, styleValue) => key === 'rotate3d' ? isValueIdentity(is.arr(styleValue) ? styleValue[3] : styleValue, 0) : key.startsWith('scale') ? isValueIdentity(styleValue, 1) : isValueIdentity(styleValue, 0);\n/**\r\n * This AnimatedStyle will simplify animated components transforms by\r\n * interpolating all transform function passed as keys in the style object\r\n * including shortcuts such as x, y and z for translateX/Y/Z\r\n */\n\n\nclass AnimatedStyle extends AnimatedObject {\n  constructor(_ref) {\n    if (_ref === void 0) {\n      _ref = {};\n    }\n\n    let _ref2 = _ref,\n        x = _ref2.x,\n        y = _ref2.y,\n        z = _ref2.z,\n        style = _objectWithoutPropertiesLoose(_ref2, [\"x\", \"y\", \"z\"]);\n\n    const props = []; // transforms will be an array of functions applied to the props. Each function\n    // will return the interpolated transformed string, and a flag indicating if the\n    // interpolation result is an identity transform of its own\n\n    const transforms = []; // first we deal with x, y, z to group them into a single translate3d\n\n    if (x || y || z) {\n      // xyz should be an AnimatedValue or AnimatedArray\n      const xyz = ensureAnimated([x || 0, y || 0, z || 0]); // we add it to the array of Animated objects that will be interpolated\n\n      props.push(xyz); // we add the interpolation function to our transform array\n\n      transforms.push(_ref3 => {\n        let vx = _ref3[0],\n            vy = _ref3[1],\n            vz = _ref3[2];\n        return [`translate3d(${mergeUnit(vx, getUnit('x'))},${mergeUnit(vy, getUnit('y'))},${mergeUnit(vz, getUnit('z'))})`, isValueIdentity([vx, vy, vz], 0)];\n      });\n    } // then for each style key that matches the supported transform functions,\n    // we add the input value to the props and the interpolation transform\n    // function\n\n\n    each(style, (value, key) => {\n      if (key === 'transform') {\n        props.push(ensureAnimated(value));\n        transforms.push(transform => [transform, transform === '']);\n      } else if (domTransforms.some(transform => key.startsWith(transform))) {\n        const unit = getUnit(key);\n        props.push(ensureAnimated(value));\n        transforms.push(key === 'rotate3d' ? _ref4 => {\n          let x = _ref4[0],\n              y = _ref4[1],\n              z = _ref4[2],\n              deg = _ref4[3];\n          return [`rotate3d(${x},${y},${z},${mergeUnit(deg, unit)})`, isTransformIdentity(key, deg)];\n        } : arg => [is.arr(arg) ? `${key}(${arg.map(v => mergeUnit(v, unit)).join(',')})` : `${key}(${mergeUnit(arg, unit)})`, isTransformIdentity(key, arg)]);\n        delete style[key];\n      }\n    }); // finally, we set the transform key of the animated style to the\n    // interpolation of all the props, using the transform functions we defined\n    // above\n\n    if (props.length > 0) {\n      style.transform = to(props, function () {\n        let transform = '';\n        let identity = true;\n\n        for (let i = 0; i < arguments.length; i++) {\n          const _transforms$i = transforms[i](i < 0 || arguments.length <= i ? undefined : arguments[i]),\n                t = _transforms$i[0],\n                id = _transforms$i[1];\n\n          transform += ' ' + t;\n          identity = identity && id;\n        } // if the identity flag was true for all transforms, we set the transform\n        // to none, otherwise we return the concatenated transform string\n\n\n        return identity ? 'none' : transform;\n      });\n    }\n\n    super(style);\n  }\n\n}\n\nconst elements = ['a', 'abbr', 'address', 'area', 'article', 'aside', 'audio', 'b', 'base', 'bdi', 'bdo', 'big', 'blockquote', 'body', 'br', 'button', 'canvas', 'caption', 'cite', 'code', 'col', 'colgroup', 'data', 'datalist', 'dd', 'del', 'details', 'dfn', 'dialog', 'div', 'dl', 'dt', 'em', 'embed', 'fieldset', 'figcaption', 'figure', 'footer', 'form', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'head', 'header', 'hgroup', 'hr', 'html', 'i', 'iframe', 'img', 'input', 'ins', 'kbd', 'keygen', 'label', 'legend', 'li', 'link', 'main', 'map', 'mark', 'menu', 'menuitem', 'meta', 'meter', 'nav', 'noscript', 'object', 'ol', 'optgroup', 'option', 'output', 'p', 'param', 'picture', 'pre', 'progress', 'q', 'rp', 'rt', 'ruby', 's', 'samp', 'script', 'section', 'select', 'small', 'source', 'span', 'strong', 'style', 'sub', 'summary', 'sup', 'table', 'tbody', 'td', 'textarea', 'tfoot', 'th', 'thead', 'time', 'title', 'tr', 'track', 'u', 'ul', 'var', 'video', 'wbr', // SVG\n'circle', 'clipPath', 'defs', 'ellipse', 'foreignObject', 'g', 'image', 'line', 'linearGradient', 'mask', 'path', 'pattern', 'polygon', 'polyline', 'radialGradient', 'rect', 'stop', 'svg', 'text', 'tspan'];\nconst animated = extendAnimated(withAnimated, elements);\nGlobals.assign({\n  defaultElement: 'div',\n  colorNames,\n  applyAnimatedValues,\n  createStringInterpolator,\n  createAnimatedStyle: style => new AnimatedStyle(style),\n  getComponentProps: _ref => {\n    let scrollTop = _ref.scrollTop,\n        scrollLeft = _ref.scrollLeft,\n        props = _objectWithoutPropertiesLoose(_ref, [\"scrollTop\", \"scrollLeft\"]);\n\n    return props;\n  }\n});\nexport { animated as a, animated };","map":{"version":3,"sources":["src/applyAnimatedValues.ts","src/AnimatedStyle.ts","src/elements.ts","src/animated.ts","src/index.ts"],"names":["isUnitlessNumber","animationIterationCount","borderImageOutset","borderImageSlice","borderImageWidth","boxFlex","boxFlexGroup","boxOrdinalGroup","columnCount","columns","flex","flexGrow","flexPositive","flexShrink","flexNegative","flexOrder","gridRow","gridRowEnd","gridRowSpan","gridRowStart","gridColumn","gridColumnEnd","gridColumnSpan","gridColumnStart","fontWeight","lineClamp","lineHeight","opacity","order","orphans","tabSize","widows","zIndex","zoom","fillOpacity","floodOpacity","stopOpacity","strokeDasharray","strokeDashoffset","strokeMiterlimit","strokeOpacity","strokeWidth","prefixKey","prefix","key","prefixes","acc","value","attributeCache","applyAnimatedValues","instance","props","style","children","scrollTop","scrollLeft","attributes","isCustomProperty","styleName","styleValue","dangerousStyleValue","isFilterElement","attributeName","name","n","domTransforms","pxDefaults","dgDefaults","mergeUnit","is","getUnit","ensureAnimated","isAnimated","isValueIdentity","v","parseFloat","isTransformIdentity","AnimatedStyle","AnimatedObject","constructor","x","y","z","transforms","xyz","vx","vy","vz","each","transform","unit","deg","arg","to","identity","i","t","id","elements","animated","extendAnimated","Globals","defaultElement","createAnimatedStyle","getComponentProps"],"mappings":"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","sourcesContent":["import _objectWithoutPropertiesLoose from '@babel/runtime/helpers/esm/objectWithoutPropertiesLoose';\nimport { Globals } from '@react-spring/core';\nexport * from '@react-spring/core';\nimport { createStringInterpolator } from '@react-spring/shared/stringInterpolation';\nimport { is, each } from '@react-spring/shared';\nimport { AnimatedObject, isAnimated, AnimatedArray, AnimatedValue, to, extendAnimated, withAnimated } from '@react-spring/animated';\nimport colorNames from '@react-spring/shared/colors';\n\nlet isUnitlessNumber = {\n  animationIterationCount: true,\n  borderImageOutset: true,\n  borderImageSlice: true,\n  borderImageWidth: true,\n  boxFlex: true,\n  boxFlexGroup: true,\n  boxOrdinalGroup: true,\n  columnCount: true,\n  columns: true,\n  flex: true,\n  flexGrow: true,\n  flexPositive: true,\n  flexShrink: true,\n  flexNegative: true,\n  flexOrder: true,\n  gridRow: true,\n  gridRowEnd: true,\n  gridRowSpan: true,\n  gridRowStart: true,\n  gridColumn: true,\n  gridColumnEnd: true,\n  gridColumnSpan: true,\n  gridColumnStart: true,\n  fontWeight: true,\n  lineClamp: true,\n  lineHeight: true,\n  opacity: true,\n  order: true,\n  orphans: true,\n  tabSize: true,\n  widows: true,\n  zIndex: true,\n  zoom: true,\n  // SVG-related properties\n  fillOpacity: true,\n  floodOpacity: true,\n  stopOpacity: true,\n  strokeDasharray: true,\n  strokeDashoffset: true,\n  strokeMiterlimit: true,\n  strokeOpacity: true,\n  strokeWidth: true\n};\n\nconst prefixKey = (prefix, key) => prefix + key.charAt(0).toUpperCase() + key.substring(1);\n\nconst prefixes = ['Webkit', 'Ms', 'Moz', 'O'];\nisUnitlessNumber = Object.keys(isUnitlessNumber).reduce((acc, prop) => {\n  prefixes.forEach(prefix => acc[prefixKey(prefix, prop)] = acc[prop]);\n  return acc;\n}, isUnitlessNumber);\n\nfunction dangerousStyleValue(name, value, isCustomProperty) {\n  if (value == null || typeof value === 'boolean' || value === '') return '';\n  if (!isCustomProperty && typeof value === 'number' && value !== 0 && !(isUnitlessNumber.hasOwnProperty(name) && isUnitlessNumber[name])) return value + 'px'; // Presumes implicit 'px' suffix for unitless numbers\n\n  return ('' + value).trim();\n}\n\nconst attributeCache = {};\nfunction applyAnimatedValues(instance, props) {\n  if (!instance.nodeType || !instance.setAttribute) {\n    return false;\n  }\n\n  const style = props.style,\n        children = props.children,\n        scrollTop = props.scrollTop,\n        scrollLeft = props.scrollLeft,\n        attributes = _objectWithoutPropertiesLoose(props, [\"style\", \"children\", \"scrollTop\", \"scrollLeft\"]);\n\n  if (scrollTop !== void 0) instance.scrollTop = scrollTop;\n  if (scrollLeft !== void 0) instance.scrollLeft = scrollLeft; // Set textContent, if children is an animatable value\n\n  if (children !== void 0) instance.textContent = children; // Apply CSS styles\n\n  for (let styleName in style) {\n    if (!style.hasOwnProperty(styleName)) continue;\n    var isCustomProperty = styleName.indexOf('--') === 0;\n    var styleValue = dangerousStyleValue(styleName, style[styleName], isCustomProperty);\n    if (styleName === 'float') styleName = 'cssFloat';\n    if (isCustomProperty) instance.style.setProperty(styleName, styleValue);else instance.style[styleName] = styleValue;\n  }\n\n  const isFilterElement = instance.nodeName === 'filter' || instance.parentNode && instance.parentNode.nodeName === 'filter'; // Apply DOM attributes\n\n  for (let name in attributes) {\n    // Attributes are written in dash case\n    const attributeName = isFilterElement || instance.hasAttribute(name) ? name : attributeCache[name] || (attributeCache[name] = name.replace(/([A-Z])/g, n => '-' + n.toLowerCase()));\n    instance.setAttribute(attributeName, attributes[name]);\n  }\n}\n\n/** The transform-functions\r\n * (https://developer.mozilla.org/fr/docs/Web/CSS/transform-function)\r\n * that you can pass as keys to your animated component style and that will be\r\n * animated. Perspective has been left out as it would conflict with the\r\n * non-transform perspective style.\r\n */\n\nconst domTransforms = ['matrix', 'translate', 'scale', 'rotate', 'skew']; // x, y, z and translate will get 'px' as unit default\n\nconst pxDefaults = ['x', 'y', 'z', 'translate']; // rotate and skew will get 'deg' as unit default\n\nconst dgDefaults = ['rotate', 'skew']; // adds a unit to the value when the value is unit-less (ie a number)\n\nconst mergeUnit = (value, unit) => is.num(value) && value !== 0 ? value + unit : value; // gets the default unit for a key\n\n\nconst getUnit = key => pxDefaults.some(name => key.startsWith(name)) ? 'px' : dgDefaults.some(name => key.startsWith(name)) ? 'deg' : '';\n/**\r\n * Returns the right Animated object based on the value type.\r\n *\r\n * x: AnimatedValue         --> x\r\n * 40px                     --> AnimatedValue(40px)\r\n * [40, 30]                 --> AnimatedValue([40,30])\r\n * [40, y: AnimatedValue]   --> AnimatedArray([AnimatedValue(40), y])\r\n *\r\n * @param value\r\n */\n\n\nconst ensureAnimated = function ensureAnimated(value) {\n  if (value === void 0) {\n    value = 0;\n  }\n\n  return is.arr(value) && value.some(isAnimated) ? new AnimatedArray(value.map(ensureAnimated)) : isAnimated(value) ? value : new AnimatedValue(value);\n};\n/**\r\n * Checks if the input value matches the identity value.\r\n *\r\n * isValueIdentity(0, 0)              --> true\r\n * isValueIdentity('0px', 0)          --> true\r\n * isValueIdentity([0, '0px', 0], 0)  --> true\r\n *\r\n * @param styleValue\r\n * @param id\r\n */\n\n\nconst isValueIdentity = (styleValue, id) => is.arr(styleValue) ? styleValue.every(v => isValueIdentity(v, id)) : is.num(styleValue) ? styleValue === id : parseFloat(styleValue) === id;\n/**\r\n * Checks if the style value is the identity for a given key.\r\n *\r\n * isTransformIdentity('scale', 1)               --> true\r\n * isTransformIdentity('scale', [1,1])\r\n * isTransformIdentity('rotate3d', [1,1,1,0])    --> true\r\n * isTransformIdentity('x', 0)                   --> true\r\n *\r\n * @param key\r\n * @param styleValue\r\n */\n\n\nconst isTransformIdentity = (key, styleValue) => key === 'rotate3d' ? isValueIdentity(is.arr(styleValue) ? styleValue[3] : styleValue, 0) : key.startsWith('scale') ? isValueIdentity(styleValue, 1) : isValueIdentity(styleValue, 0);\n/**\r\n * This AnimatedStyle will simplify animated components transforms by\r\n * interpolating all transform function passed as keys in the style object\r\n * including shortcuts such as x, y and z for translateX/Y/Z\r\n */\n\n\nclass AnimatedStyle extends AnimatedObject {\n  constructor(_ref) {\n    if (_ref === void 0) {\n      _ref = {};\n    }\n\n    let _ref2 = _ref,\n        x = _ref2.x,\n        y = _ref2.y,\n        z = _ref2.z,\n        style = _objectWithoutPropertiesLoose(_ref2, [\"x\", \"y\", \"z\"]);\n\n    const props = []; // transforms will be an array of functions applied to the props. Each function\n    // will return the interpolated transformed string, and a flag indicating if the\n    // interpolation result is an identity transform of its own\n\n    const transforms = []; // first we deal with x, y, z to group them into a single translate3d\n\n    if (x || y || z) {\n      // xyz should be an AnimatedValue or AnimatedArray\n      const xyz = ensureAnimated([x || 0, y || 0, z || 0]); // we add it to the array of Animated objects that will be interpolated\n\n      props.push(xyz); // we add the interpolation function to our transform array\n\n      transforms.push((_ref3) => {\n        let vx = _ref3[0],\n            vy = _ref3[1],\n            vz = _ref3[2];\n        return [`translate3d(${mergeUnit(vx, getUnit('x'))},${mergeUnit(vy, getUnit('y'))},${mergeUnit(vz, getUnit('z'))})`, isValueIdentity([vx, vy, vz], 0)];\n      });\n    } // then for each style key that matches the supported transform functions,\n    // we add the input value to the props and the interpolation transform\n    // function\n\n\n    each(style, (value, key) => {\n      if (key === 'transform') {\n        props.push(ensureAnimated(value));\n        transforms.push(transform => [transform, transform === '']);\n      } else if (domTransforms.some(transform => key.startsWith(transform))) {\n        const unit = getUnit(key);\n        props.push(ensureAnimated(value));\n        transforms.push(key === 'rotate3d' ? (_ref4) => {\n          let x = _ref4[0],\n              y = _ref4[1],\n              z = _ref4[2],\n              deg = _ref4[3];\n          return [`rotate3d(${x},${y},${z},${mergeUnit(deg, unit)})`, isTransformIdentity(key, deg)];\n        } : arg => [is.arr(arg) ? `${key}(${arg.map(v => mergeUnit(v, unit)).join(',')})` : `${key}(${mergeUnit(arg, unit)})`, isTransformIdentity(key, arg)]);\n        delete style[key];\n      }\n    }); // finally, we set the transform key of the animated style to the\n    // interpolation of all the props, using the transform functions we defined\n    // above\n\n    if (props.length > 0) {\n      style.transform = to(props, function () {\n        let transform = '';\n        let identity = true;\n\n        for (let i = 0; i < arguments.length; i++) {\n          const _transforms$i = transforms[i](i < 0 || arguments.length <= i ? undefined : arguments[i]),\n                t = _transforms$i[0],\n                id = _transforms$i[1];\n\n          transform += ' ' + t;\n          identity = identity && id;\n        } // if the identity flag was true for all transforms, we set the transform\n        // to none, otherwise we return the concatenated transform string\n\n\n        return identity ? 'none' : transform;\n      });\n    }\n\n    super(style);\n  }\n\n}\n\nconst elements = ['a', 'abbr', 'address', 'area', 'article', 'aside', 'audio', 'b', 'base', 'bdi', 'bdo', 'big', 'blockquote', 'body', 'br', 'button', 'canvas', 'caption', 'cite', 'code', 'col', 'colgroup', 'data', 'datalist', 'dd', 'del', 'details', 'dfn', 'dialog', 'div', 'dl', 'dt', 'em', 'embed', 'fieldset', 'figcaption', 'figure', 'footer', 'form', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'head', 'header', 'hgroup', 'hr', 'html', 'i', 'iframe', 'img', 'input', 'ins', 'kbd', 'keygen', 'label', 'legend', 'li', 'link', 'main', 'map', 'mark', 'menu', 'menuitem', 'meta', 'meter', 'nav', 'noscript', 'object', 'ol', 'optgroup', 'option', 'output', 'p', 'param', 'picture', 'pre', 'progress', 'q', 'rp', 'rt', 'ruby', 's', 'samp', 'script', 'section', 'select', 'small', 'source', 'span', 'strong', 'style', 'sub', 'summary', 'sup', 'table', 'tbody', 'td', 'textarea', 'tfoot', 'th', 'thead', 'time', 'title', 'tr', 'track', 'u', 'ul', 'var', 'video', 'wbr', // SVG\n'circle', 'clipPath', 'defs', 'ellipse', 'foreignObject', 'g', 'image', 'line', 'linearGradient', 'mask', 'path', 'pattern', 'polygon', 'polyline', 'radialGradient', 'rect', 'stop', 'svg', 'text', 'tspan'];\n\nconst animated = extendAnimated(withAnimated, elements);\n\nGlobals.assign({\n  defaultElement: 'div',\n  colorNames,\n  applyAnimatedValues,\n  createStringInterpolator,\n  createAnimatedStyle: style => new AnimatedStyle(style),\n  getComponentProps: (_ref) => {\n    let scrollTop = _ref.scrollTop,\n        scrollLeft = _ref.scrollLeft,\n        props = _objectWithoutPropertiesLoose(_ref, [\"scrollTop\", \"scrollLeft\"]);\n\n    return props;\n  }\n});\n\nexport { animated as a, animated };\n//# sourceMappingURL=index.js.map\n"]},"metadata":{},"sourceType":"module"}