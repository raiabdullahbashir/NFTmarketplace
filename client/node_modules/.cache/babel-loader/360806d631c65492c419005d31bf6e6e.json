{"ast":null,"code":"import invariant from \"invariant\"; ////////////////////////////////////////////////////////////////////////////////\n// startsWith(string, search) - Check if `string` starts with `search`\n\nvar startsWith = function startsWith(string, search) {\n  return string.substr(0, search.length) === search;\n}; ////////////////////////////////////////////////////////////////////////////////\n// pick(routes, uri)\n//\n// Ranks and picks the best route to match. Each segment gets the highest\n// amount of points, then the type of segment gets an additional amount of\n// points where\n//\n//     static > dynamic > splat > root\n//\n// This way we don't have to worry about the order of our routes, let the\n// computers do it.\n//\n// A route looks like this\n//\n//     { path, default, value }\n//\n// And a returned match looks like:\n//\n//     { route, params, uri }\n//\n// I know, I should use TypeScript not comments for these types.\n\n\nvar pick = function pick(routes, uri) {\n  var match = void 0;\n  var default_ = void 0;\n\n  var _uri$split = uri.split(\"?\"),\n      uriPathname = _uri$split[0];\n\n  var uriSegments = segmentize(uriPathname);\n  var isRootUri = uriSegments[0] === \"\";\n  var ranked = rankRoutes(routes);\n\n  for (var i = 0, l = ranked.length; i < l; i++) {\n    var missed = false;\n    var route = ranked[i].route;\n\n    if (route.default) {\n      default_ = {\n        route: route,\n        params: {},\n        uri: uri\n      };\n      continue;\n    }\n\n    var routeSegments = segmentize(route.path);\n    var params = {};\n    var max = Math.max(uriSegments.length, routeSegments.length);\n    var index = 0;\n\n    for (; index < max; index++) {\n      var routeSegment = routeSegments[index];\n      var uriSegment = uriSegments[index];\n\n      if (isSplat(routeSegment)) {\n        // Hit a splat, just grab the rest, and return a match\n        // uri:   /files/documents/work\n        // route: /files/*\n        var param = routeSegment.slice(1) || \"*\";\n        params[param] = uriSegments.slice(index).map(decodeURIComponent).join(\"/\");\n        break;\n      }\n\n      if (uriSegment === undefined) {\n        // URI is shorter than the route, no match\n        // uri:   /users\n        // route: /users/:userId\n        missed = true;\n        break;\n      }\n\n      var dynamicMatch = paramRe.exec(routeSegment);\n\n      if (dynamicMatch && !isRootUri) {\n        var matchIsNotReserved = reservedNames.indexOf(dynamicMatch[1]) === -1;\n        !matchIsNotReserved ? process.env.NODE_ENV !== \"production\" ? invariant(false, \"<Router> dynamic segment \\\"\" + dynamicMatch[1] + \"\\\" is a reserved name. Please use a different name in path \\\"\" + route.path + \"\\\".\") : invariant(false) : void 0;\n        var value = decodeURIComponent(uriSegment);\n        params[dynamicMatch[1]] = value;\n      } else if (routeSegment !== uriSegment) {\n        // Current segments don't match, not dynamic, not splat, so no match\n        // uri:   /users/123/settings\n        // route: /users/:id/profile\n        missed = true;\n        break;\n      }\n    }\n\n    if (!missed) {\n      match = {\n        route: route,\n        params: params,\n        uri: \"/\" + uriSegments.slice(0, index).join(\"/\")\n      };\n      break;\n    }\n  }\n\n  return match || default_ || null;\n}; ////////////////////////////////////////////////////////////////////////////////\n// match(path, uri) - Matches just one path to a uri, also lol\n\n\nvar match = function match(path, uri) {\n  return pick([{\n    path: path\n  }], uri);\n}; ////////////////////////////////////////////////////////////////////////////////\n// resolve(to, basepath)\n//\n// Resolves URIs as though every path is a directory, no files.  Relative URIs\n// in the browser can feel awkward because not only can you be \"in a directory\"\n// you can be \"at a file\", too. For example\n//\n//     browserSpecResolve('foo', '/bar/') => /bar/foo\n//     browserSpecResolve('foo', '/bar') => /foo\n//\n// But on the command line of a file system, it's not as complicated, you can't\n// `cd` from a file, only directories.  This way, links have to know less about\n// their current path. To go deeper you can do this:\n//\n//     <Link to=\"deeper\"/>\n//     // instead of\n//     <Link to=`{${props.uri}/deeper}`/>\n//\n// Just like `cd`, if you want to go deeper from the command line, you do this:\n//\n//     cd deeper\n//     # not\n//     cd $(pwd)/deeper\n//\n// By treating every path as a directory, linking to relative paths should\n// require less contextual information and (fingers crossed) be more intuitive.\n\n\nvar resolve = function resolve(to, base) {\n  // /foo/bar, /baz/qux => /foo/bar\n  if (startsWith(to, \"/\")) {\n    return to;\n  }\n\n  var _to$split = to.split(\"?\"),\n      toPathname = _to$split[0],\n      toQuery = _to$split[1];\n\n  var _base$split = base.split(\"?\"),\n      basePathname = _base$split[0];\n\n  var toSegments = segmentize(toPathname);\n  var baseSegments = segmentize(basePathname); // ?a=b, /users?b=c => /users?a=b\n\n  if (toSegments[0] === \"\") {\n    return addQuery(basePathname, toQuery);\n  } // profile, /users/789 => /users/789/profile\n\n\n  if (!startsWith(toSegments[0], \".\")) {\n    var pathname = baseSegments.concat(toSegments).join(\"/\");\n    return addQuery((basePathname === \"/\" ? \"\" : \"/\") + pathname, toQuery);\n  } // ./         /users/123  =>  /users/123\n  // ../        /users/123  =>  /users\n  // ../..      /users/123  =>  /\n  // ../../one  /a/b/c/d    =>  /a/b/one\n  // .././one   /a/b/c/d    =>  /a/b/c/one\n\n\n  var allSegments = baseSegments.concat(toSegments);\n  var segments = [];\n\n  for (var i = 0, l = allSegments.length; i < l; i++) {\n    var segment = allSegments[i];\n    if (segment === \"..\") segments.pop();else if (segment !== \".\") segments.push(segment);\n  }\n\n  return addQuery(\"/\" + segments.join(\"/\"), toQuery);\n}; ////////////////////////////////////////////////////////////////////////////////\n// insertParams(path, params)\n\n\nvar insertParams = function insertParams(path, params) {\n  var _path$split = path.split(\"?\"),\n      pathBase = _path$split[0],\n      _path$split$ = _path$split[1],\n      query = _path$split$ === undefined ? \"\" : _path$split$;\n\n  var segments = segmentize(pathBase);\n  var constructedPath = \"/\" + segments.map(function (segment) {\n    var match = paramRe.exec(segment);\n    return match ? params[match[1]] : segment;\n  }).join(\"/\");\n  var _params$location = params.location;\n  _params$location = _params$location === undefined ? {} : _params$location;\n  var _params$location$sear = _params$location.search,\n      search = _params$location$sear === undefined ? \"\" : _params$location$sear;\n  var searchSplit = search.split(\"?\")[1] || \"\";\n  constructedPath = addQuery(constructedPath, query, searchSplit);\n  return constructedPath;\n};\n\nvar validateRedirect = function validateRedirect(from, to) {\n  var filter = function filter(segment) {\n    return isDynamic(segment);\n  };\n\n  var fromString = segmentize(from).filter(filter).sort().join(\"/\");\n  var toString = segmentize(to).filter(filter).sort().join(\"/\");\n  return fromString === toString;\n}; ////////////////////////////////////////////////////////////////////////////////\n// Junk\n\n\nvar paramRe = /^:(.+)/;\nvar SEGMENT_POINTS = 4;\nvar STATIC_POINTS = 3;\nvar DYNAMIC_POINTS = 2;\nvar SPLAT_PENALTY = 1;\nvar ROOT_POINTS = 1;\n\nvar isRootSegment = function isRootSegment(segment) {\n  return segment === \"\";\n};\n\nvar isDynamic = function isDynamic(segment) {\n  return paramRe.test(segment);\n};\n\nvar isSplat = function isSplat(segment) {\n  return segment && segment[0] === \"*\";\n};\n\nvar rankRoute = function rankRoute(route, index) {\n  var score = route.default ? 0 : segmentize(route.path).reduce(function (score, segment) {\n    score += SEGMENT_POINTS;\n    if (isRootSegment(segment)) score += ROOT_POINTS;else if (isDynamic(segment)) score += DYNAMIC_POINTS;else if (isSplat(segment)) score -= SEGMENT_POINTS + SPLAT_PENALTY;else score += STATIC_POINTS;\n    return score;\n  }, 0);\n  return {\n    route: route,\n    score: score,\n    index: index\n  };\n};\n\nvar rankRoutes = function rankRoutes(routes) {\n  return routes.map(rankRoute).sort(function (a, b) {\n    return a.score < b.score ? 1 : a.score > b.score ? -1 : a.index - b.index;\n  });\n};\n\nvar segmentize = function segmentize(uri) {\n  return uri // strip starting/ending slashes\n  .replace(/(^\\/+|\\/+$)/g, \"\").split(\"/\");\n};\n\nvar addQuery = function addQuery(pathname) {\n  for (var _len = arguments.length, query = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n    query[_key - 1] = arguments[_key];\n  }\n\n  query = query.filter(function (q) {\n    return q && q.length > 0;\n  });\n  return pathname + (query && query.length > 0 ? \"?\" + query.join(\"&\") : \"\");\n};\n\nvar reservedNames = [\"uri\", \"path\"];\n/**\n * Shallow compares two objects.\n * @param {Object} obj1 The first object to compare.\n * @param {Object} obj2 The second object to compare.\n */\n\nvar shallowCompare = function shallowCompare(obj1, obj2) {\n  var obj1Keys = Object.keys(obj1);\n  return obj1Keys.length === Object.keys(obj2).length && obj1Keys.every(function (key) {\n    return obj2.hasOwnProperty(key) && obj1[key] === obj2[key];\n  });\n}; ////////////////////////////////////////////////////////////////////////////////\n\n\nexport { startsWith, pick, match, resolve, insertParams, validateRedirect, shallowCompare };","map":{"version":3,"names":["invariant","startsWith","string","search","substr","length","pick","routes","uri","match","default_","_uri$split","split","uriPathname","uriSegments","segmentize","isRootUri","ranked","rankRoutes","i","l","missed","route","default","params","routeSegments","path","max","Math","index","routeSegment","uriSegment","isSplat","param","slice","map","decodeURIComponent","join","undefined","dynamicMatch","paramRe","exec","matchIsNotReserved","reservedNames","indexOf","process","env","NODE_ENV","value","resolve","to","base","_to$split","toPathname","toQuery","_base$split","basePathname","toSegments","baseSegments","addQuery","pathname","concat","allSegments","segments","segment","pop","push","insertParams","_path$split","pathBase","_path$split$","query","constructedPath","_params$location","location","_params$location$sear","searchSplit","validateRedirect","from","filter","isDynamic","fromString","sort","toString","SEGMENT_POINTS","STATIC_POINTS","DYNAMIC_POINTS","SPLAT_PENALTY","ROOT_POINTS","isRootSegment","test","rankRoute","score","reduce","a","b","replace","_len","arguments","Array","_key","q","shallowCompare","obj1","obj2","obj1Keys","Object","keys","every","key","hasOwnProperty"],"sources":["C:/Users/raiab/Documents/Logics Yard/NFT code daniyal/NFT code/node_modules/@reach/router/es/lib/utils.js"],"sourcesContent":["import invariant from \"invariant\";\n\n////////////////////////////////////////////////////////////////////////////////\n// startsWith(string, search) - Check if `string` starts with `search`\nvar startsWith = function startsWith(string, search) {\n  return string.substr(0, search.length) === search;\n};\n\n////////////////////////////////////////////////////////////////////////////////\n// pick(routes, uri)\n//\n// Ranks and picks the best route to match. Each segment gets the highest\n// amount of points, then the type of segment gets an additional amount of\n// points where\n//\n//     static > dynamic > splat > root\n//\n// This way we don't have to worry about the order of our routes, let the\n// computers do it.\n//\n// A route looks like this\n//\n//     { path, default, value }\n//\n// And a returned match looks like:\n//\n//     { route, params, uri }\n//\n// I know, I should use TypeScript not comments for these types.\nvar pick = function pick(routes, uri) {\n  var match = void 0;\n  var default_ = void 0;\n\n  var _uri$split = uri.split(\"?\"),\n      uriPathname = _uri$split[0];\n\n  var uriSegments = segmentize(uriPathname);\n  var isRootUri = uriSegments[0] === \"\";\n  var ranked = rankRoutes(routes);\n\n  for (var i = 0, l = ranked.length; i < l; i++) {\n    var missed = false;\n    var route = ranked[i].route;\n\n    if (route.default) {\n      default_ = {\n        route: route,\n        params: {},\n        uri: uri\n      };\n      continue;\n    }\n\n    var routeSegments = segmentize(route.path);\n    var params = {};\n    var max = Math.max(uriSegments.length, routeSegments.length);\n    var index = 0;\n\n    for (; index < max; index++) {\n      var routeSegment = routeSegments[index];\n      var uriSegment = uriSegments[index];\n\n      if (isSplat(routeSegment)) {\n        // Hit a splat, just grab the rest, and return a match\n        // uri:   /files/documents/work\n        // route: /files/*\n        var param = routeSegment.slice(1) || \"*\";\n        params[param] = uriSegments.slice(index).map(decodeURIComponent).join(\"/\");\n        break;\n      }\n\n      if (uriSegment === undefined) {\n        // URI is shorter than the route, no match\n        // uri:   /users\n        // route: /users/:userId\n        missed = true;\n        break;\n      }\n\n      var dynamicMatch = paramRe.exec(routeSegment);\n\n      if (dynamicMatch && !isRootUri) {\n        var matchIsNotReserved = reservedNames.indexOf(dynamicMatch[1]) === -1;\n        !matchIsNotReserved ? process.env.NODE_ENV !== \"production\" ? invariant(false, \"<Router> dynamic segment \\\"\" + dynamicMatch[1] + \"\\\" is a reserved name. Please use a different name in path \\\"\" + route.path + \"\\\".\") : invariant(false) : void 0;\n        var value = decodeURIComponent(uriSegment);\n        params[dynamicMatch[1]] = value;\n      } else if (routeSegment !== uriSegment) {\n        // Current segments don't match, not dynamic, not splat, so no match\n        // uri:   /users/123/settings\n        // route: /users/:id/profile\n        missed = true;\n        break;\n      }\n    }\n\n    if (!missed) {\n      match = {\n        route: route,\n        params: params,\n        uri: \"/\" + uriSegments.slice(0, index).join(\"/\")\n      };\n      break;\n    }\n  }\n\n  return match || default_ || null;\n};\n\n////////////////////////////////////////////////////////////////////////////////\n// match(path, uri) - Matches just one path to a uri, also lol\nvar match = function match(path, uri) {\n  return pick([{ path: path }], uri);\n};\n\n////////////////////////////////////////////////////////////////////////////////\n// resolve(to, basepath)\n//\n// Resolves URIs as though every path is a directory, no files.  Relative URIs\n// in the browser can feel awkward because not only can you be \"in a directory\"\n// you can be \"at a file\", too. For example\n//\n//     browserSpecResolve('foo', '/bar/') => /bar/foo\n//     browserSpecResolve('foo', '/bar') => /foo\n//\n// But on the command line of a file system, it's not as complicated, you can't\n// `cd` from a file, only directories.  This way, links have to know less about\n// their current path. To go deeper you can do this:\n//\n//     <Link to=\"deeper\"/>\n//     // instead of\n//     <Link to=`{${props.uri}/deeper}`/>\n//\n// Just like `cd`, if you want to go deeper from the command line, you do this:\n//\n//     cd deeper\n//     # not\n//     cd $(pwd)/deeper\n//\n// By treating every path as a directory, linking to relative paths should\n// require less contextual information and (fingers crossed) be more intuitive.\nvar resolve = function resolve(to, base) {\n  // /foo/bar, /baz/qux => /foo/bar\n  if (startsWith(to, \"/\")) {\n    return to;\n  }\n\n  var _to$split = to.split(\"?\"),\n      toPathname = _to$split[0],\n      toQuery = _to$split[1];\n\n  var _base$split = base.split(\"?\"),\n      basePathname = _base$split[0];\n\n  var toSegments = segmentize(toPathname);\n  var baseSegments = segmentize(basePathname);\n\n  // ?a=b, /users?b=c => /users?a=b\n  if (toSegments[0] === \"\") {\n    return addQuery(basePathname, toQuery);\n  }\n\n  // profile, /users/789 => /users/789/profile\n  if (!startsWith(toSegments[0], \".\")) {\n    var pathname = baseSegments.concat(toSegments).join(\"/\");\n    return addQuery((basePathname === \"/\" ? \"\" : \"/\") + pathname, toQuery);\n  }\n\n  // ./         /users/123  =>  /users/123\n  // ../        /users/123  =>  /users\n  // ../..      /users/123  =>  /\n  // ../../one  /a/b/c/d    =>  /a/b/one\n  // .././one   /a/b/c/d    =>  /a/b/c/one\n  var allSegments = baseSegments.concat(toSegments);\n  var segments = [];\n  for (var i = 0, l = allSegments.length; i < l; i++) {\n    var segment = allSegments[i];\n    if (segment === \"..\") segments.pop();else if (segment !== \".\") segments.push(segment);\n  }\n\n  return addQuery(\"/\" + segments.join(\"/\"), toQuery);\n};\n\n////////////////////////////////////////////////////////////////////////////////\n// insertParams(path, params)\n\nvar insertParams = function insertParams(path, params) {\n  var _path$split = path.split(\"?\"),\n      pathBase = _path$split[0],\n      _path$split$ = _path$split[1],\n      query = _path$split$ === undefined ? \"\" : _path$split$;\n\n  var segments = segmentize(pathBase);\n  var constructedPath = \"/\" + segments.map(function (segment) {\n    var match = paramRe.exec(segment);\n    return match ? params[match[1]] : segment;\n  }).join(\"/\");\n  var _params$location = params.location;\n  _params$location = _params$location === undefined ? {} : _params$location;\n  var _params$location$sear = _params$location.search,\n      search = _params$location$sear === undefined ? \"\" : _params$location$sear;\n\n  var searchSplit = search.split(\"?\")[1] || \"\";\n  constructedPath = addQuery(constructedPath, query, searchSplit);\n  return constructedPath;\n};\n\nvar validateRedirect = function validateRedirect(from, to) {\n  var filter = function filter(segment) {\n    return isDynamic(segment);\n  };\n  var fromString = segmentize(from).filter(filter).sort().join(\"/\");\n  var toString = segmentize(to).filter(filter).sort().join(\"/\");\n  return fromString === toString;\n};\n\n////////////////////////////////////////////////////////////////////////////////\n// Junk\nvar paramRe = /^:(.+)/;\n\nvar SEGMENT_POINTS = 4;\nvar STATIC_POINTS = 3;\nvar DYNAMIC_POINTS = 2;\nvar SPLAT_PENALTY = 1;\nvar ROOT_POINTS = 1;\n\nvar isRootSegment = function isRootSegment(segment) {\n  return segment === \"\";\n};\nvar isDynamic = function isDynamic(segment) {\n  return paramRe.test(segment);\n};\nvar isSplat = function isSplat(segment) {\n  return segment && segment[0] === \"*\";\n};\n\nvar rankRoute = function rankRoute(route, index) {\n  var score = route.default ? 0 : segmentize(route.path).reduce(function (score, segment) {\n    score += SEGMENT_POINTS;\n    if (isRootSegment(segment)) score += ROOT_POINTS;else if (isDynamic(segment)) score += DYNAMIC_POINTS;else if (isSplat(segment)) score -= SEGMENT_POINTS + SPLAT_PENALTY;else score += STATIC_POINTS;\n    return score;\n  }, 0);\n  return { route: route, score: score, index: index };\n};\n\nvar rankRoutes = function rankRoutes(routes) {\n  return routes.map(rankRoute).sort(function (a, b) {\n    return a.score < b.score ? 1 : a.score > b.score ? -1 : a.index - b.index;\n  });\n};\n\nvar segmentize = function segmentize(uri) {\n  return uri\n  // strip starting/ending slashes\n  .replace(/(^\\/+|\\/+$)/g, \"\").split(\"/\");\n};\n\nvar addQuery = function addQuery(pathname) {\n  for (var _len = arguments.length, query = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n    query[_key - 1] = arguments[_key];\n  }\n\n  query = query.filter(function (q) {\n    return q && q.length > 0;\n  });\n  return pathname + (query && query.length > 0 ? \"?\" + query.join(\"&\") : \"\");\n};\n\nvar reservedNames = [\"uri\", \"path\"];\n\n/**\n * Shallow compares two objects.\n * @param {Object} obj1 The first object to compare.\n * @param {Object} obj2 The second object to compare.\n */\nvar shallowCompare = function shallowCompare(obj1, obj2) {\n  var obj1Keys = Object.keys(obj1);\n  return obj1Keys.length === Object.keys(obj2).length && obj1Keys.every(function (key) {\n    return obj2.hasOwnProperty(key) && obj1[key] === obj2[key];\n  });\n};\n\n////////////////////////////////////////////////////////////////////////////////\nexport { startsWith, pick, match, resolve, insertParams, validateRedirect, shallowCompare };"],"mappings":"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"},"metadata":{},"sourceType":"module"}