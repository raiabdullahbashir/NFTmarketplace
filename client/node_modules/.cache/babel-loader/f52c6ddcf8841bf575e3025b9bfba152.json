{"ast":null,"code":"\"use strict\";\n\nvar __assign = this && this.__assign || Object.assign || function (t) {\n  for (var s, i = 1, n = arguments.length; i < n; i++) {\n    s = arguments[i];\n\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n  }\n\n  return t;\n};\n\nvar __decorate = this && this.__decorate || function (decorators, target, key, desc) {\n  var c = arguments.length,\n      r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,\n      d;\n  if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : new P(function (resolve) {\n        resolve(result.value);\n      }).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nvar __generator = this && this.__generator || function (thisArg, body) {\n  var _ = {\n    label: 0,\n    sent: function () {\n      if (t[0] & 1) throw t[1];\n      return t[1];\n    },\n    trys: [],\n    ops: []\n  },\n      f,\n      y,\n      t,\n      g;\n  return g = {\n    next: verb(0),\n    \"throw\": verb(1),\n    \"return\": verb(2)\n  }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function () {\n    return this;\n  }), g;\n\n  function verb(n) {\n    return function (v) {\n      return step([n, v]);\n    };\n  }\n\n  function step(op) {\n    if (f) throw new TypeError(\"Generator is already executing.\");\n\n    while (_) try {\n      if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n      if (y = 0, t) op = [op[0] & 2, t.value];\n\n      switch (op[0]) {\n        case 0:\n        case 1:\n          t = op;\n          break;\n\n        case 4:\n          _.label++;\n          return {\n            value: op[1],\n            done: false\n          };\n\n        case 5:\n          _.label++;\n          y = op[1];\n          op = [0];\n          continue;\n\n        case 7:\n          op = _.ops.pop();\n\n          _.trys.pop();\n\n          continue;\n\n        default:\n          if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {\n            _ = 0;\n            continue;\n          }\n\n          if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {\n            _.label = op[1];\n            break;\n          }\n\n          if (op[0] === 6 && _.label < t[1]) {\n            _.label = t[1];\n            t = op;\n            break;\n          }\n\n          if (t && _.label < t[2]) {\n            _.label = t[2];\n\n            _.ops.push(op);\n\n            break;\n          }\n\n          if (t[2]) _.ops.pop();\n\n          _.trys.pop();\n\n          continue;\n      }\n\n      op = body.call(thisArg, _);\n    } catch (e) {\n      op = [6, e];\n      y = 0;\n    } finally {\n      f = t = 0;\n    }\n\n    if (op[0] & 5) throw op[1];\n    return {\n      value: op[0] ? op[1] : void 0,\n      done: true\n    };\n  }\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar json_schemas_1 = require(\"@0xproject/json-schemas\");\n\nvar utils_1 = require(\"@0xproject/utils\");\n\nvar web3_wrapper_1 = require(\"@0xproject/web3-wrapper\");\n\nvar ethABI = require(\"ethereumjs-abi\");\n\nvar ethUtil = require(\"ethereumjs-util\");\n\nvar _ = require(\"lodash\");\n\nvar authenticated_proxy_1 = require(\"./abi_gen/authenticated_proxy\");\n\nvar wyvern_atomicizer_1 = require(\"./abi_gen/wyvern_atomicizer\");\n\nvar wyvern_d_a_o_1 = require(\"./abi_gen/wyvern_d_a_o\");\n\nvar wyvern_exchange_1 = require(\"./abi_gen/wyvern_exchange\");\n\nvar wyvern_proxy_registry_1 = require(\"./abi_gen/wyvern_proxy_registry\");\n\nvar wyvern_token_1 = require(\"./abi_gen/wyvern_token\");\n\nvar schemas_1 = require(\"./schemas\");\n\nvar types_1 = require(\"./types\");\n\nvar assert_1 = require(\"./utils/assert\");\n\nvar constants_1 = require(\"./utils/constants\");\n\nvar decorators_1 = require(\"./utils/decorators\");\n\nvar signature_utils_1 = require(\"./utils/signature_utils\");\n\nvar utils_2 = require(\"./utils/utils\");\n\nvar WyvernProtocol =\n/** @class */\nfunction () {\n  function WyvernProtocol(provider, config) {\n    assert_1.assert.isWeb3Provider('provider', provider); // assert.doesConformToSchema('config', config, wyvernProtocolConfigSchema)\n\n    this._web3Wrapper = new web3_wrapper_1.Web3Wrapper(provider, {\n      gasPrice: config.gasPrice\n    });\n    var exchangeContractAddress = config.wyvernExchangeContractAddress || WyvernProtocol.getExchangeContractAddress(config.network);\n    this.wyvernExchange = new wyvern_exchange_1.WyvernExchangeContract(this._web3Wrapper.getContractInstance(constants_1.constants.EXCHANGE_ABI, exchangeContractAddress), {});\n    var proxyRegistryContractAddress = config.wyvernProxyRegistryContractAddress || WyvernProtocol.getProxyRegistryContractAddress(config.network);\n    this.wyvernProxyRegistry = new wyvern_proxy_registry_1.WyvernProxyRegistryContract(this._web3Wrapper.getContractInstance(constants_1.constants.PROXY_REGISTRY_ABI, proxyRegistryContractAddress), {});\n    var daoContractAddress = config.wyvernDAOContractAddress || WyvernProtocol.getDAOContractAddress(config.network);\n    this.wyvernDAO = new wyvern_d_a_o_1.WyvernDAOContract(this._web3Wrapper.getContractInstance(constants_1.constants.DAO_ABI, daoContractAddress), {});\n    var tokenContractAddress = config.wyvernTokenContractAddress || WyvernProtocol.getTokenContractAddress(config.network);\n    this.wyvernToken = new wyvern_token_1.WyvernTokenContract(this._web3Wrapper.getContractInstance(constants_1.constants.TOKEN_ABI, tokenContractAddress), {});\n    var atomicizerContractAddress = config.wyvernAtomicizerContractAddress || WyvernProtocol.getAtomicizerContractAddress(config.network);\n    this.wyvernAtomicizer = new wyvern_atomicizer_1.WyvernAtomicizerContract(this._web3Wrapper.getContractInstance(constants_1.constants.ATOMICIZER_ABI, atomicizerContractAddress), {});\n  }\n\n  WyvernProtocol.getExchangeContractAddress = function (network) {\n    return constants_1.constants.DEPLOYED[network].WyvernExchange;\n  };\n\n  WyvernProtocol.getProxyRegistryContractAddress = function (network) {\n    return constants_1.constants.DEPLOYED[network].WyvernProxyRegistry;\n  };\n\n  WyvernProtocol.getTokenContractAddress = function (network) {\n    return constants_1.constants.DEPLOYED[network].WyvernToken;\n  };\n\n  WyvernProtocol.getDAOContractAddress = function (network) {\n    return constants_1.constants.DEPLOYED[network].WyvernDAO;\n  };\n\n  WyvernProtocol.getAtomicizerContractAddress = function (network) {\n    return constants_1.constants.DEPLOYED[network].WyvernAtomicizer;\n  };\n\n  WyvernProtocol.getTokenTransferProxyAddress = function (network) {\n    return constants_1.constants.DEPLOYED[network].WyvernTokenTransferProxy;\n  };\n  /**\r\n   * Verifies that the elliptic curve signature `signature` was generated\r\n   * by signing `data` with the private key corresponding to the `signerAddress` address.\r\n   * @param   data          The hex encoded data signed by the supplied signature.\r\n   * @param   signature     An object containing the elliptic curve signature parameters.\r\n   * @param   signerAddress The hex encoded address that signed the data, producing the supplied signature.\r\n   * @return  Whether the signature is valid for the supplied signerAddress and data.\r\n   */\n\n\n  WyvernProtocol.isValidSignature = function (data, signature, signerAddress) {\n    assert_1.assert.isHexString('data', data);\n    assert_1.assert.doesConformToSchema('signature', signature, schemas_1.schemas.ecSignatureSchema);\n    assert_1.assert.isETHAddressHex('signerAddress', signerAddress);\n    var isValidSignature = signature_utils_1.signatureUtils.isValidSignature(data, signature, signerAddress);\n    return isValidSignature;\n  };\n  /**\r\n   * Generates a pseudo-random 256-bit salt.\r\n   * The salt can be included in an 0x order, ensuring that the order generates a unique orderHash\r\n   * and will not collide with other outstanding orders that are identical in all other parameters.\r\n   * @return  A pseudo-random 256-bit number that can be used as a salt.\r\n   */\n\n\n  WyvernProtocol.generatePseudoRandomSalt = function () {\n    // BigNumber.random returns a pseudo-random number between 0 & 1 with a passed in number of decimal places.\n    // Source: https://mikemcl.github.io/bignumber.js/#random\n    var randomNumber = utils_1.BigNumber.random(constants_1.constants.MAX_DIGITS_IN_UNSIGNED_256_INT);\n    var factor = new utils_1.BigNumber(10).pow(constants_1.constants.MAX_DIGITS_IN_UNSIGNED_256_INT - 1);\n    var salt = randomNumber.times(factor).round();\n    return salt;\n  };\n  /**\r\n   * Checks if the supplied hex encoded order hash is valid.\r\n   * Note: Valid means it has the expected format, not that an order with the orderHash exists.\r\n   * Use this method when processing orderHashes submitted as user input.\r\n   * @param   orderHash    Hex encoded orderHash.\r\n   * @return  Whether the supplied orderHash has the expected format.\r\n   */\n\n\n  WyvernProtocol.isValidOrderHash = function (orderHash) {\n    // Since this method can be called to check if any arbitrary string conforms to an orderHash's\n    // format, we only assert that we were indeed passed a string.\n    assert_1.assert.isString('orderHash', orderHash);\n    var schemaValidator = new json_schemas_1.SchemaValidator();\n    var isValidOrderHash = schemaValidator.validate(orderHash, schemas_1.schemas.orderHashSchema).valid;\n    return isValidOrderHash;\n  };\n  /**\r\n   * A unit amount is defined as the amount of a token above the specified decimal places (integer part).\r\n   * E.g: If a currency has 18 decimal places, 1e18 or one quintillion of the currency is equivalent\r\n   * to 1 unit.\r\n   * @param   amount      The amount in baseUnits that you would like converted to units.\r\n   * @param   decimals    The number of decimal places the unit amount has.\r\n   * @return  The amount in units.\r\n   */\n\n\n  WyvernProtocol.toUnitAmount = function (amount, decimals) {\n    assert_1.assert.isValidBaseUnitAmount('amount', amount);\n    assert_1.assert.isNumber('decimals', decimals);\n    var aUnit = new utils_1.BigNumber(10).pow(decimals);\n    var unit = amount.div(aUnit);\n    return unit;\n  };\n  /**\r\n   * A baseUnit is defined as the smallest denomination of a token. An amount expressed in baseUnits\r\n   * is the amount expressed in the smallest denomination.\r\n   * E.g: 1 unit of a token with 18 decimal places is expressed in baseUnits as 1000000000000000000\r\n   * @param   amount      The amount of units that you would like converted to baseUnits.\r\n   * @param   decimals    The number of decimal places the unit amount has.\r\n   * @return  The amount in baseUnits.\r\n   */\n\n\n  WyvernProtocol.toBaseUnitAmount = function (amount, decimals) {\n    assert_1.assert.isBigNumber('amount', amount);\n    assert_1.assert.isNumber('decimals', decimals);\n    var unit = new utils_1.BigNumber(10).pow(decimals);\n    var baseUnitAmount = amount.times(unit);\n    var hasDecimals = baseUnitAmount.decimalPlaces() !== 0;\n\n    if (hasDecimals) {\n      throw new Error(\"Invalid unit amount: \" + amount.toString() + \" - Too many decimal places\");\n    }\n\n    return baseUnitAmount;\n  };\n  /**\r\n   * Computes the orderHash for a supplied order.\r\n   * @param   order   An object that conforms to the Order or SignedOrder interface definitions.\r\n   * @return  The resulting orderHash from hashing the supplied order.\r\n   */\n\n\n  WyvernProtocol.getOrderHashHex = function (order) {\n    assert_1.assert.doesConformToSchema('order', order, schemas_1.schemas.orderSchema);\n    var orderHashHex = utils_2.utils.getOrderHashHex(order);\n    return orderHashHex;\n  };\n  /**\r\n   * Computes the assetHash for a supplied asset.\r\n   */\n\n\n  WyvernProtocol.getAssetHashHex = function (assetHash, schema) {\n    var assetHashHex = utils_2.utils.getAssetHashHex(assetHash, schema);\n    return assetHashHex;\n  };\n  /**\r\n   * Sets a new web3 provider for wyvernProtocol.js. Updating the provider will stop all\r\n   * subscriptions so you will need to re-subscribe to all events relevant to your app after this call.\r\n   * @param   provider    The Web3Provider you would like the wyvernProtocol.js library to use from now on.\r\n   * @param   networkId   The id of the network your provider is connected to\r\n   */\n\n\n  WyvernProtocol.prototype.setProvider = function (provider, networkId) {\n    this._web3Wrapper.setProvider(provider);\n\n    this.wyvernExchange._invalidateContractInstances();\n\n    this.wyvernExchange._setNetworkId(networkId);\n\n    this.wyvernProxyRegistry._invalidateContractInstance();\n\n    this.wyvernProxyRegistry._setNetworkId(networkId);\n  };\n  /**\r\n   * Get user Ethereum addresses available through the supplied web3 provider available for sending transactions.\r\n   * @return  An array of available user Ethereum addresses.\r\n   */\n\n\n  WyvernProtocol.prototype.getAvailableAddressesAsync = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      var availableAddresses;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            return [4\n            /*yield*/\n            , this._web3Wrapper.getAvailableAddressesAsync()];\n\n          case 1:\n            availableAddresses = _a.sent();\n            return [2\n            /*return*/\n            , availableAddresses];\n        }\n      });\n    });\n  };\n  /**\r\n   * Gets the authenticated proxy contract for a specific account address\r\n   * @param accountAddress address to retrieve the proxy contract from\r\n   */\n\n\n  WyvernProtocol.prototype.getAuthenticatedProxy = function (accountAddress) {\n    return __awaiter(this, void 0, void 0, function () {\n      var proxyAddress;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            return [4\n            /*yield*/\n            , this.wyvernProxyRegistry.proxies.callAsync(accountAddress)];\n\n          case 1:\n            proxyAddress = _a.sent();\n            return [2\n            /*return*/\n            , new authenticated_proxy_1.AuthenticatedProxyContract(this._web3Wrapper.getContractInstance(constants_1.constants.AUTHENTICATED_PROXY_ABI, proxyAddress), {})];\n        }\n      });\n    });\n  };\n  /**\r\n   * Signs an orderHash and returns its elliptic curve signature.\r\n   * This method currently supports TestRPC, Geth and Parity above and below V1.6.6\r\n   * @param   orderHash       Hex encoded orderHash to sign.\r\n   * @param   signerAddress   The hex encoded Ethereum address you wish to sign it with. This address\r\n   *          must be available via the Web3.Provider supplied to wyvernProtocol.js.\r\n   * @return  An object containing the Elliptic curve signature parameters generated by signing the orderHash.\r\n   */\n\n\n  WyvernProtocol.prototype.signOrderHashAsync = function (orderHash, signerAddress) {\n    return __awaiter(this, void 0, void 0, function () {\n      var msgHashHex, nodeVersion, isParityNode, isTestRpc, orderHashBuff, msgHashBuff, signature, validVParamValues, ecSignatureVRS, isValidVRSSignature, ecSignatureRSV, isValidRSVSignature;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            assert_1.assert.isHexString('orderHash', orderHash);\n            return [4\n            /*yield*/\n            , this._web3Wrapper.getNodeVersionAsync()];\n\n          case 1:\n            nodeVersion = _a.sent();\n            isParityNode = utils_2.utils.isParityNode(nodeVersion);\n            isTestRpc = utils_2.utils.isTestRpc(nodeVersion);\n\n            if (isParityNode || isTestRpc) {\n              // Parity and TestRpc nodes add the personalMessage prefix itself\n              msgHashHex = orderHash;\n            } else {\n              orderHashBuff = ethUtil.toBuffer(orderHash);\n              msgHashBuff = ethUtil.hashPersonalMessage(orderHashBuff);\n              msgHashHex = ethUtil.bufferToHex(msgHashBuff);\n            }\n\n            return [4\n            /*yield*/\n            , this._web3Wrapper.signTransactionAsync(signerAddress, msgHashHex)];\n\n          case 2:\n            signature = _a.sent();\n            validVParamValues = [27, 28];\n            ecSignatureVRS = signature_utils_1.signatureUtils.parseSignatureHexAsVRS(signature);\n\n            if (_.includes(validVParamValues, ecSignatureVRS.v)) {\n              isValidVRSSignature = WyvernProtocol.isValidSignature(orderHash, ecSignatureVRS, signerAddress);\n\n              if (isValidVRSSignature) {\n                return [2\n                /*return*/\n                , ecSignatureVRS];\n              }\n            }\n\n            ecSignatureRSV = signature_utils_1.signatureUtils.parseSignatureHexAsRSV(signature);\n\n            if (_.includes(validVParamValues, ecSignatureRSV.v)) {\n              isValidRSVSignature = WyvernProtocol.isValidSignature(orderHash, ecSignatureRSV, signerAddress);\n\n              if (isValidRSVSignature) {\n                return [2\n                /*return*/\n                , ecSignatureRSV];\n              }\n            }\n\n            throw new Error(types_1.WyvernProtocolError.InvalidSignature);\n        }\n      });\n    });\n  };\n  /**\r\n   * Waits for a transaction to be mined and returns the transaction receipt.\r\n   * @param   txHash            Transaction hash\r\n   * @param   pollingIntervalMs How often (in ms) should we check if the transaction is mined.\r\n   * @param   timeoutMs         How long (in ms) to poll for transaction mined until aborting.\r\n   * @return  Transaction receipt with decoded log args.\r\n   */\n\n\n  WyvernProtocol.prototype.awaitTransactionMinedAsync = function (txHash, pollingIntervalMs, timeoutMs) {\n    if (pollingIntervalMs === void 0) {\n      pollingIntervalMs = 1000;\n    }\n\n    return __awaiter(this, void 0, void 0, function () {\n      var timeoutExceeded, txReceiptPromise;\n\n      var _this = this;\n\n      return __generator(this, function (_a) {\n        timeoutExceeded = false;\n\n        if (timeoutMs) {\n          setTimeout(function () {\n            return timeoutExceeded = true;\n          }, timeoutMs);\n        }\n\n        txReceiptPromise = new Promise(function (resolve, reject) {\n          var intervalId = utils_1.intervalUtils.setAsyncExcludingInterval(function () {\n            return __awaiter(_this, void 0, void 0, function () {\n              var transactionReceipt, logsWithDecodedArgs, transactionReceiptWithDecodedLogArgs;\n              return __generator(this, function (_a) {\n                switch (_a.label) {\n                  case 0:\n                    if (timeoutExceeded) {\n                      utils_1.intervalUtils.clearAsyncExcludingInterval(intervalId);\n                      return [2\n                      /*return*/\n                      , reject(types_1.WyvernProtocolError.TransactionMiningTimeout)];\n                    }\n\n                    return [4\n                    /*yield*/\n                    , this._web3Wrapper.getTransactionReceiptAsync(txHash)];\n\n                  case 1:\n                    transactionReceipt = _a.sent();\n\n                    if (!_.isNull(transactionReceipt)) {\n                      utils_1.intervalUtils.clearAsyncExcludingInterval(intervalId);\n                      logsWithDecodedArgs = _.map(transactionReceipt.logs, this._abiDecoder.tryToDecodeLogOrNoop.bind(this._abiDecoder));\n                      transactionReceiptWithDecodedLogArgs = __assign({}, transactionReceipt, {\n                        logs: logsWithDecodedArgs\n                      });\n                      resolve(transactionReceiptWithDecodedLogArgs);\n                    }\n\n                    return [2\n                    /*return*/\n                    ];\n                }\n              });\n            });\n          }, pollingIntervalMs, function () {\n            return {};\n          });\n        });\n        return [2\n        /*return*/\n        , txReceiptPromise];\n      });\n    });\n  };\n\n  WyvernProtocol.NULL_ADDRESS = constants_1.constants.NULL_ADDRESS;\n  WyvernProtocol.MAX_UINT_256 = new utils_1.BigNumber(2).pow(256).sub(1);\n  /**\r\n   * Encodes the replacementPattern for a supplied ABI and replace kind\r\n   * @param   abi AnnotatedFunctionABI\r\n   * @param   replaceKind Parameter kind to replace\r\n   * @return  The resulting encoded replacementPattern\r\n   */\n\n  WyvernProtocol.encodeReplacementPattern = function (abi, replaceKind, encodeToBytes) {\n    if (replaceKind === void 0) {\n      replaceKind = types_1.FunctionInputKind.Replaceable;\n    }\n\n    if (encodeToBytes === void 0) {\n      encodeToBytes = true;\n    }\n\n    var output = [];\n    var data = [];\n    var dynamicOffset = abi.inputs.reduce(function (len, _a) {\n      var type = _a.type;\n      var match = type.match(/\\[(.+)\\]$/);\n      return len + (match ? parseInt(match[1], 10) * 32 : 32);\n    }, 0);\n    abi.inputs.map(function (_a) {\n      var kind = _a.kind,\n          type = _a.type,\n          value = _a.value;\n      return {\n        bitmask: kind === replaceKind ? 255 : 0,\n        type: ethABI.elementaryName(type),\n        value: value !== undefined ? value : WyvernProtocol.generateDefaultValue(type)\n      };\n    }).reduce(function (offset, _a) {\n      var bitmask = _a.bitmask,\n          type = _a.type,\n          value = _a.value; // The 0xff bytes in the mask select the replacement bytes. All other bytes are 0x00.\n\n      var cur = new Buffer(ethABI.encodeSingle(type, value).length).fill(bitmask);\n\n      if (ethABI.isDynamic(type)) {\n        if (bitmask) {\n          throw new Error('Replacement is not supported for dynamic parameters.');\n        }\n\n        output.push(new Buffer(ethABI.encodeSingle('uint256', dynamicOffset).length));\n        data.push(cur);\n        return offset + cur.length;\n      }\n\n      output.push(cur);\n      return offset;\n    }, dynamicOffset); // 4 initial bytes of 0x00 for the method hash.\n\n    var methodIdMask = new Buffer(4);\n    var mask = Buffer.concat([methodIdMask, Buffer.concat(output.concat(data))]);\n    return encodeToBytes ? \"0x\" + mask.toString('hex') : mask.map(function (b) {\n      return b ? 1 : 0;\n    }).join('');\n  };\n  /**\r\n   * Encodes the atomicized replacementPattern for a supplied ABI and replace kind\r\n   * @param   abis array of AnnotatedFunctionABI\r\n   * @param   replaceKind Parameter kind to replace\r\n   * @return  The resulting encoded replacementPattern\r\n   */\n\n\n  WyvernProtocol.encodeAtomicizedReplacementPattern = function (abis, replaceKind) {\n    if (replaceKind === void 0) {\n      replaceKind = types_1.FunctionInputKind.Replaceable;\n    }\n\n    var allowReplaceByte = '1';\n    var doNotAllowReplaceByte = '0';\n    /* Four bytes for method ID. */\n\n    var maskArr = [doNotAllowReplaceByte, doNotAllowReplaceByte, doNotAllowReplaceByte, doNotAllowReplaceByte];\n    var encodedUint256 = ethABI.encodeSingle(ethABI.elementaryName('uint256'), WyvernProtocol.generateDefaultValue('uint256'));\n    var dataLocationSize = encodedUint256.length;\n    var dynamicArgumentLengthSize = encodedUint256.length; // See https://solidity.readthedocs.io/en/develop/abi-spec.html#examples\n    // Prepare dymanic types to be passed in (they need locations of their data parts). 4 for addresses, values, calldata lengths, calldatas\n\n    maskArr.push(doNotAllowReplaceByte.repeat(dataLocationSize * 4)); // Length of addresses array\n\n    maskArr.push(doNotAllowReplaceByte.repeat(dynamicArgumentLengthSize)); // Addresses should not be replaced\n\n    var encoded = ethABI.encodeSingle(ethABI.elementaryName('address'), WyvernProtocol.generateDefaultValue('address'));\n    maskArr.push(doNotAllowReplaceByte.repeat(encoded.length * abis.length)); // Length of values array\n\n    maskArr.push(doNotAllowReplaceByte.repeat(dynamicArgumentLengthSize)); // Add the values...\n\n    encoded = ethABI.encodeSingle(ethABI.elementaryName('uint'), WyvernProtocol.generateDefaultValue('uint'));\n    maskArr.push(doNotAllowReplaceByte.repeat(encoded.length * abis.length)); // Length of calldata lengths array\n\n    maskArr.push(doNotAllowReplaceByte.repeat(dynamicArgumentLengthSize)); // ... and calldata lengths\n\n    maskArr.push(doNotAllowReplaceByte.repeat(encoded.length * abis.length)); // Length of replacementPatterns\n\n    maskArr.push(doNotAllowReplaceByte.repeat(dynamicArgumentLengthSize)); // Raw replacementPatterns\n\n    var replacementBytes = [];\n    abis.map(function (abi) {\n      var replacement = WyvernProtocol.encodeReplacementPattern(abi, replaceKind, false);\n      replacementBytes.push(replacement);\n    });\n    var concatenatedReplacementPatterns = replacementBytes.join('');\n    maskArr.push(concatenatedReplacementPatterns);\n\n    if (concatenatedReplacementPatterns.length % 32 !== 0) {\n      // Pad replacementPatterns to nearest multiple of 32\n      maskArr.push(doNotAllowReplaceByte.repeat(32 - concatenatedReplacementPatterns.length % 32));\n    }\n\n    var mask = maskArr.reduce(function (x, y) {\n      return x + y;\n    }, '');\n    var ret = [];\n    /* Encode into bytes. */\n\n    for (var _i = 0, mask_1 = mask; _i < mask_1.length; _i++) {\n      var char = mask_1[_i];\n      var byte = char === allowReplaceByte ? 255 : 0;\n      var buf = Buffer.alloc(1);\n      buf.writeUInt8(byte, 0);\n      ret.push(buf);\n    }\n\n    return '0x' + Buffer.concat(ret).toString('hex');\n  };\n  /**\r\n   * Computes the default value for a type\r\n   * @param type The ABI type to calculate a default value for\r\n   * @return The default value for that type\r\n   */\n\n\n  WyvernProtocol.generateDefaultValue = function (type) {\n    switch (type) {\n      case 'address':\n      case 'bytes20':\n        /* Null address is sometimes checked in transfer calls. */\n        // But we need to use 0x000 because bitwise XOR won't work if there's a 0 in the actual address, since it will be replaced as 1 OR 0 = 1\n        return '0x0000000000000000000000000000000000000000';\n\n      case 'bytes32':\n        return '0x0000000000000000000000000000000000000000000000000000000000000000';\n\n      case 'bool':\n        return false;\n\n      case 'int':\n      case 'uint':\n      case 'uint8':\n      case 'uint16':\n      case 'uint32':\n      case 'uint64':\n      case 'uint256':\n        return 0;\n\n      default:\n        throw new Error('Default value not yet implemented for type: ' + type);\n    }\n  };\n\n  __decorate([decorators_1.decorators.syncWyvernProtocolErrorHandler], WyvernProtocol, \"getOrderHashHex\", null);\n\n  return WyvernProtocol;\n}();\n\nexports.WyvernProtocol = WyvernProtocol;","map":{"version":3,"sources":["../src/wyvernProtocol.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\r\nvar __assign = (this && this.__assign) || Object.assign || function(t) {\r\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n        s = arguments[i];\r\n        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\r\n            t[p] = s[p];\r\n    }\r\n    return t;\r\n};\r\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n};\r\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n};\r\nvar __generator = (this && this.__generator) || function (thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar json_schemas_1 = require(\"@0xproject/json-schemas\");\r\nvar utils_1 = require(\"@0xproject/utils\");\r\nvar web3_wrapper_1 = require(\"@0xproject/web3-wrapper\");\r\nvar ethABI = require(\"ethereumjs-abi\");\r\nvar ethUtil = require(\"ethereumjs-util\");\r\nvar _ = require(\"lodash\");\r\nvar authenticated_proxy_1 = require(\"./abi_gen/authenticated_proxy\");\r\nvar wyvern_atomicizer_1 = require(\"./abi_gen/wyvern_atomicizer\");\r\nvar wyvern_d_a_o_1 = require(\"./abi_gen/wyvern_d_a_o\");\r\nvar wyvern_exchange_1 = require(\"./abi_gen/wyvern_exchange\");\r\nvar wyvern_proxy_registry_1 = require(\"./abi_gen/wyvern_proxy_registry\");\r\nvar wyvern_token_1 = require(\"./abi_gen/wyvern_token\");\r\nvar schemas_1 = require(\"./schemas\");\r\nvar types_1 = require(\"./types\");\r\nvar assert_1 = require(\"./utils/assert\");\r\nvar constants_1 = require(\"./utils/constants\");\r\nvar decorators_1 = require(\"./utils/decorators\");\r\nvar signature_utils_1 = require(\"./utils/signature_utils\");\r\nvar utils_2 = require(\"./utils/utils\");\r\nvar WyvernProtocol = /** @class */ (function () {\r\n    function WyvernProtocol(provider, config) {\r\n        assert_1.assert.isWeb3Provider('provider', provider);\r\n        // assert.doesConformToSchema('config', config, wyvernProtocolConfigSchema)\r\n        this._web3Wrapper = new web3_wrapper_1.Web3Wrapper(provider, { gasPrice: config.gasPrice });\r\n        var exchangeContractAddress = config.wyvernExchangeContractAddress || WyvernProtocol.getExchangeContractAddress(config.network);\r\n        this.wyvernExchange = new wyvern_exchange_1.WyvernExchangeContract(this._web3Wrapper.getContractInstance(constants_1.constants.EXCHANGE_ABI, exchangeContractAddress), {});\r\n        var proxyRegistryContractAddress = config.wyvernProxyRegistryContractAddress || WyvernProtocol.getProxyRegistryContractAddress(config.network);\r\n        this.wyvernProxyRegistry = new wyvern_proxy_registry_1.WyvernProxyRegistryContract(this._web3Wrapper.getContractInstance(constants_1.constants.PROXY_REGISTRY_ABI, proxyRegistryContractAddress), {});\r\n        var daoContractAddress = config.wyvernDAOContractAddress || WyvernProtocol.getDAOContractAddress(config.network);\r\n        this.wyvernDAO = new wyvern_d_a_o_1.WyvernDAOContract(this._web3Wrapper.getContractInstance(constants_1.constants.DAO_ABI, daoContractAddress), {});\r\n        var tokenContractAddress = config.wyvernTokenContractAddress || WyvernProtocol.getTokenContractAddress(config.network);\r\n        this.wyvernToken = new wyvern_token_1.WyvernTokenContract(this._web3Wrapper.getContractInstance(constants_1.constants.TOKEN_ABI, tokenContractAddress), {});\r\n        var atomicizerContractAddress = config.wyvernAtomicizerContractAddress || WyvernProtocol.getAtomicizerContractAddress(config.network);\r\n        this.wyvernAtomicizer = new wyvern_atomicizer_1.WyvernAtomicizerContract(this._web3Wrapper.getContractInstance(constants_1.constants.ATOMICIZER_ABI, atomicizerContractAddress), {});\r\n    }\r\n    WyvernProtocol.getExchangeContractAddress = function (network) {\r\n        return constants_1.constants.DEPLOYED[network].WyvernExchange;\r\n    };\r\n    WyvernProtocol.getProxyRegistryContractAddress = function (network) {\r\n        return constants_1.constants.DEPLOYED[network].WyvernProxyRegistry;\r\n    };\r\n    WyvernProtocol.getTokenContractAddress = function (network) {\r\n        return constants_1.constants.DEPLOYED[network].WyvernToken;\r\n    };\r\n    WyvernProtocol.getDAOContractAddress = function (network) {\r\n        return constants_1.constants.DEPLOYED[network].WyvernDAO;\r\n    };\r\n    WyvernProtocol.getAtomicizerContractAddress = function (network) {\r\n        return constants_1.constants.DEPLOYED[network].WyvernAtomicizer;\r\n    };\r\n    WyvernProtocol.getTokenTransferProxyAddress = function (network) {\r\n        return constants_1.constants.DEPLOYED[network].WyvernTokenTransferProxy;\r\n    };\r\n    /**\r\n     * Verifies that the elliptic curve signature `signature` was generated\r\n     * by signing `data` with the private key corresponding to the `signerAddress` address.\r\n     * @param   data          The hex encoded data signed by the supplied signature.\r\n     * @param   signature     An object containing the elliptic curve signature parameters.\r\n     * @param   signerAddress The hex encoded address that signed the data, producing the supplied signature.\r\n     * @return  Whether the signature is valid for the supplied signerAddress and data.\r\n     */\r\n    WyvernProtocol.isValidSignature = function (data, signature, signerAddress) {\r\n        assert_1.assert.isHexString('data', data);\r\n        assert_1.assert.doesConformToSchema('signature', signature, schemas_1.schemas.ecSignatureSchema);\r\n        assert_1.assert.isETHAddressHex('signerAddress', signerAddress);\r\n        var isValidSignature = signature_utils_1.signatureUtils.isValidSignature(data, signature, signerAddress);\r\n        return isValidSignature;\r\n    };\r\n    /**\r\n     * Generates a pseudo-random 256-bit salt.\r\n     * The salt can be included in an 0x order, ensuring that the order generates a unique orderHash\r\n     * and will not collide with other outstanding orders that are identical in all other parameters.\r\n     * @return  A pseudo-random 256-bit number that can be used as a salt.\r\n     */\r\n    WyvernProtocol.generatePseudoRandomSalt = function () {\r\n        // BigNumber.random returns a pseudo-random number between 0 & 1 with a passed in number of decimal places.\r\n        // Source: https://mikemcl.github.io/bignumber.js/#random\r\n        var randomNumber = utils_1.BigNumber.random(constants_1.constants.MAX_DIGITS_IN_UNSIGNED_256_INT);\r\n        var factor = new utils_1.BigNumber(10).pow(constants_1.constants.MAX_DIGITS_IN_UNSIGNED_256_INT - 1);\r\n        var salt = randomNumber.times(factor).round();\r\n        return salt;\r\n    };\r\n    /**\r\n     * Checks if the supplied hex encoded order hash is valid.\r\n     * Note: Valid means it has the expected format, not that an order with the orderHash exists.\r\n     * Use this method when processing orderHashes submitted as user input.\r\n     * @param   orderHash    Hex encoded orderHash.\r\n     * @return  Whether the supplied orderHash has the expected format.\r\n     */\r\n    WyvernProtocol.isValidOrderHash = function (orderHash) {\r\n        // Since this method can be called to check if any arbitrary string conforms to an orderHash's\r\n        // format, we only assert that we were indeed passed a string.\r\n        assert_1.assert.isString('orderHash', orderHash);\r\n        var schemaValidator = new json_schemas_1.SchemaValidator();\r\n        var isValidOrderHash = schemaValidator.validate(orderHash, schemas_1.schemas.orderHashSchema).valid;\r\n        return isValidOrderHash;\r\n    };\r\n    /**\r\n     * A unit amount is defined as the amount of a token above the specified decimal places (integer part).\r\n     * E.g: If a currency has 18 decimal places, 1e18 or one quintillion of the currency is equivalent\r\n     * to 1 unit.\r\n     * @param   amount      The amount in baseUnits that you would like converted to units.\r\n     * @param   decimals    The number of decimal places the unit amount has.\r\n     * @return  The amount in units.\r\n     */\r\n    WyvernProtocol.toUnitAmount = function (amount, decimals) {\r\n        assert_1.assert.isValidBaseUnitAmount('amount', amount);\r\n        assert_1.assert.isNumber('decimals', decimals);\r\n        var aUnit = new utils_1.BigNumber(10).pow(decimals);\r\n        var unit = amount.div(aUnit);\r\n        return unit;\r\n    };\r\n    /**\r\n     * A baseUnit is defined as the smallest denomination of a token. An amount expressed in baseUnits\r\n     * is the amount expressed in the smallest denomination.\r\n     * E.g: 1 unit of a token with 18 decimal places is expressed in baseUnits as 1000000000000000000\r\n     * @param   amount      The amount of units that you would like converted to baseUnits.\r\n     * @param   decimals    The number of decimal places the unit amount has.\r\n     * @return  The amount in baseUnits.\r\n     */\r\n    WyvernProtocol.toBaseUnitAmount = function (amount, decimals) {\r\n        assert_1.assert.isBigNumber('amount', amount);\r\n        assert_1.assert.isNumber('decimals', decimals);\r\n        var unit = new utils_1.BigNumber(10).pow(decimals);\r\n        var baseUnitAmount = amount.times(unit);\r\n        var hasDecimals = baseUnitAmount.decimalPlaces() !== 0;\r\n        if (hasDecimals) {\r\n            throw new Error(\"Invalid unit amount: \" + amount.toString() + \" - Too many decimal places\");\r\n        }\r\n        return baseUnitAmount;\r\n    };\r\n    /**\r\n     * Computes the orderHash for a supplied order.\r\n     * @param   order   An object that conforms to the Order or SignedOrder interface definitions.\r\n     * @return  The resulting orderHash from hashing the supplied order.\r\n     */\r\n    WyvernProtocol.getOrderHashHex = function (order) {\r\n        assert_1.assert.doesConformToSchema('order', order, schemas_1.schemas.orderSchema);\r\n        var orderHashHex = utils_2.utils.getOrderHashHex(order);\r\n        return orderHashHex;\r\n    };\r\n    /**\r\n     * Computes the assetHash for a supplied asset.\r\n     */\r\n    WyvernProtocol.getAssetHashHex = function (assetHash, schema) {\r\n        var assetHashHex = utils_2.utils.getAssetHashHex(assetHash, schema);\r\n        return assetHashHex;\r\n    };\r\n    /**\r\n     * Sets a new web3 provider for wyvernProtocol.js. Updating the provider will stop all\r\n     * subscriptions so you will need to re-subscribe to all events relevant to your app after this call.\r\n     * @param   provider    The Web3Provider you would like the wyvernProtocol.js library to use from now on.\r\n     * @param   networkId   The id of the network your provider is connected to\r\n     */\r\n    WyvernProtocol.prototype.setProvider = function (provider, networkId) {\r\n        this._web3Wrapper.setProvider(provider);\r\n        this.wyvernExchange._invalidateContractInstances();\r\n        this.wyvernExchange._setNetworkId(networkId);\r\n        this.wyvernProxyRegistry._invalidateContractInstance();\r\n        this.wyvernProxyRegistry._setNetworkId(networkId);\r\n    };\r\n    /**\r\n     * Get user Ethereum addresses available through the supplied web3 provider available for sending transactions.\r\n     * @return  An array of available user Ethereum addresses.\r\n     */\r\n    WyvernProtocol.prototype.getAvailableAddressesAsync = function () {\r\n        return __awaiter(this, void 0, void 0, function () {\r\n            var availableAddresses;\r\n            return __generator(this, function (_a) {\r\n                switch (_a.label) {\r\n                    case 0: return [4 /*yield*/, this._web3Wrapper.getAvailableAddressesAsync()];\r\n                    case 1:\r\n                        availableAddresses = _a.sent();\r\n                        return [2 /*return*/, availableAddresses];\r\n                }\r\n            });\r\n        });\r\n    };\r\n    /**\r\n     * Gets the authenticated proxy contract for a specific account address\r\n     * @param accountAddress address to retrieve the proxy contract from\r\n     */\r\n    WyvernProtocol.prototype.getAuthenticatedProxy = function (accountAddress) {\r\n        return __awaiter(this, void 0, void 0, function () {\r\n            var proxyAddress;\r\n            return __generator(this, function (_a) {\r\n                switch (_a.label) {\r\n                    case 0: return [4 /*yield*/, this.wyvernProxyRegistry.proxies.callAsync(accountAddress)];\r\n                    case 1:\r\n                        proxyAddress = _a.sent();\r\n                        return [2 /*return*/, new authenticated_proxy_1.AuthenticatedProxyContract(this._web3Wrapper.getContractInstance(constants_1.constants.AUTHENTICATED_PROXY_ABI, proxyAddress), {})];\r\n                }\r\n            });\r\n        });\r\n    };\r\n    /**\r\n     * Signs an orderHash and returns its elliptic curve signature.\r\n     * This method currently supports TestRPC, Geth and Parity above and below V1.6.6\r\n     * @param   orderHash       Hex encoded orderHash to sign.\r\n     * @param   signerAddress   The hex encoded Ethereum address you wish to sign it with. This address\r\n     *          must be available via the Web3.Provider supplied to wyvernProtocol.js.\r\n     * @return  An object containing the Elliptic curve signature parameters generated by signing the orderHash.\r\n     */\r\n    WyvernProtocol.prototype.signOrderHashAsync = function (orderHash, signerAddress) {\r\n        return __awaiter(this, void 0, void 0, function () {\r\n            var msgHashHex, nodeVersion, isParityNode, isTestRpc, orderHashBuff, msgHashBuff, signature, validVParamValues, ecSignatureVRS, isValidVRSSignature, ecSignatureRSV, isValidRSVSignature;\r\n            return __generator(this, function (_a) {\r\n                switch (_a.label) {\r\n                    case 0:\r\n                        assert_1.assert.isHexString('orderHash', orderHash);\r\n                        return [4 /*yield*/, this._web3Wrapper.getNodeVersionAsync()];\r\n                    case 1:\r\n                        nodeVersion = _a.sent();\r\n                        isParityNode = utils_2.utils.isParityNode(nodeVersion);\r\n                        isTestRpc = utils_2.utils.isTestRpc(nodeVersion);\r\n                        if (isParityNode || isTestRpc) {\r\n                            // Parity and TestRpc nodes add the personalMessage prefix itself\r\n                            msgHashHex = orderHash;\r\n                        }\r\n                        else {\r\n                            orderHashBuff = ethUtil.toBuffer(orderHash);\r\n                            msgHashBuff = ethUtil.hashPersonalMessage(orderHashBuff);\r\n                            msgHashHex = ethUtil.bufferToHex(msgHashBuff);\r\n                        }\r\n                        return [4 /*yield*/, this._web3Wrapper.signTransactionAsync(signerAddress, msgHashHex)];\r\n                    case 2:\r\n                        signature = _a.sent();\r\n                        validVParamValues = [27, 28];\r\n                        ecSignatureVRS = signature_utils_1.signatureUtils.parseSignatureHexAsVRS(signature);\r\n                        if (_.includes(validVParamValues, ecSignatureVRS.v)) {\r\n                            isValidVRSSignature = WyvernProtocol.isValidSignature(orderHash, ecSignatureVRS, signerAddress);\r\n                            if (isValidVRSSignature) {\r\n                                return [2 /*return*/, ecSignatureVRS];\r\n                            }\r\n                        }\r\n                        ecSignatureRSV = signature_utils_1.signatureUtils.parseSignatureHexAsRSV(signature);\r\n                        if (_.includes(validVParamValues, ecSignatureRSV.v)) {\r\n                            isValidRSVSignature = WyvernProtocol.isValidSignature(orderHash, ecSignatureRSV, signerAddress);\r\n                            if (isValidRSVSignature) {\r\n                                return [2 /*return*/, ecSignatureRSV];\r\n                            }\r\n                        }\r\n                        throw new Error(types_1.WyvernProtocolError.InvalidSignature);\r\n                }\r\n            });\r\n        });\r\n    };\r\n    /**\r\n     * Waits for a transaction to be mined and returns the transaction receipt.\r\n     * @param   txHash            Transaction hash\r\n     * @param   pollingIntervalMs How often (in ms) should we check if the transaction is mined.\r\n     * @param   timeoutMs         How long (in ms) to poll for transaction mined until aborting.\r\n     * @return  Transaction receipt with decoded log args.\r\n     */\r\n    WyvernProtocol.prototype.awaitTransactionMinedAsync = function (txHash, pollingIntervalMs, timeoutMs) {\r\n        if (pollingIntervalMs === void 0) { pollingIntervalMs = 1000; }\r\n        return __awaiter(this, void 0, void 0, function () {\r\n            var timeoutExceeded, txReceiptPromise;\r\n            var _this = this;\r\n            return __generator(this, function (_a) {\r\n                timeoutExceeded = false;\r\n                if (timeoutMs) {\r\n                    setTimeout(function () { return (timeoutExceeded = true); }, timeoutMs);\r\n                }\r\n                txReceiptPromise = new Promise(function (resolve, reject) {\r\n                    var intervalId = utils_1.intervalUtils.setAsyncExcludingInterval(function () { return __awaiter(_this, void 0, void 0, function () {\r\n                        var transactionReceipt, logsWithDecodedArgs, transactionReceiptWithDecodedLogArgs;\r\n                        return __generator(this, function (_a) {\r\n                            switch (_a.label) {\r\n                                case 0:\r\n                                    if (timeoutExceeded) {\r\n                                        utils_1.intervalUtils.clearAsyncExcludingInterval(intervalId);\r\n                                        return [2 /*return*/, reject(types_1.WyvernProtocolError.TransactionMiningTimeout)];\r\n                                    }\r\n                                    return [4 /*yield*/, this._web3Wrapper.getTransactionReceiptAsync(txHash)];\r\n                                case 1:\r\n                                    transactionReceipt = _a.sent();\r\n                                    if (!_.isNull(transactionReceipt)) {\r\n                                        utils_1.intervalUtils.clearAsyncExcludingInterval(intervalId);\r\n                                        logsWithDecodedArgs = _.map(transactionReceipt.logs, this._abiDecoder.tryToDecodeLogOrNoop.bind(this._abiDecoder));\r\n                                        transactionReceiptWithDecodedLogArgs = __assign({}, transactionReceipt, { logs: logsWithDecodedArgs });\r\n                                        resolve(transactionReceiptWithDecodedLogArgs);\r\n                                    }\r\n                                    return [2 /*return*/];\r\n                            }\r\n                        });\r\n                    }); }, pollingIntervalMs, function () { return ({}); });\r\n                });\r\n                return [2 /*return*/, txReceiptPromise];\r\n            });\r\n        });\r\n    };\r\n    WyvernProtocol.NULL_ADDRESS = constants_1.constants.NULL_ADDRESS;\r\n    WyvernProtocol.MAX_UINT_256 = new utils_1.BigNumber(2).pow(256).sub(1);\r\n    /**\r\n     * Encodes the replacementPattern for a supplied ABI and replace kind\r\n     * @param   abi AnnotatedFunctionABI\r\n     * @param   replaceKind Parameter kind to replace\r\n     * @return  The resulting encoded replacementPattern\r\n     */\r\n    WyvernProtocol.encodeReplacementPattern = function (abi, replaceKind, encodeToBytes) {\r\n        if (replaceKind === void 0) { replaceKind = types_1.FunctionInputKind.Replaceable; }\r\n        if (encodeToBytes === void 0) { encodeToBytes = true; }\r\n        var output = [];\r\n        var data = [];\r\n        var dynamicOffset = abi.inputs.reduce(function (len, _a) {\r\n            var type = _a.type;\r\n            var match = type.match(/\\[(.+)\\]$/);\r\n            return len + (match ? parseInt(match[1], 10) * 32 : 32);\r\n        }, 0);\r\n        abi.inputs\r\n            .map(function (_a) {\r\n            var kind = _a.kind, type = _a.type, value = _a.value;\r\n            return ({\r\n                bitmask: kind === replaceKind ? 255 : 0,\r\n                type: ethABI.elementaryName(type),\r\n                value: value !== undefined ? value : WyvernProtocol.generateDefaultValue(type),\r\n            });\r\n        })\r\n            .reduce(function (offset, _a) {\r\n            var bitmask = _a.bitmask, type = _a.type, value = _a.value;\r\n            // The 0xff bytes in the mask select the replacement bytes. All other bytes are 0x00.\r\n            var cur = new Buffer(ethABI.encodeSingle(type, value).length).fill(bitmask);\r\n            if (ethABI.isDynamic(type)) {\r\n                if (bitmask) {\r\n                    throw new Error('Replacement is not supported for dynamic parameters.');\r\n                }\r\n                output.push(new Buffer(ethABI.encodeSingle('uint256', dynamicOffset).length));\r\n                data.push(cur);\r\n                return offset + cur.length;\r\n            }\r\n            output.push(cur);\r\n            return offset;\r\n        }, dynamicOffset);\r\n        // 4 initial bytes of 0x00 for the method hash.\r\n        var methodIdMask = new Buffer(4);\r\n        var mask = Buffer.concat([methodIdMask, Buffer.concat(output.concat(data))]);\r\n        return encodeToBytes ? \"0x\" + mask.toString('hex') : mask.map(function (b) { return b ? 1 : 0; }).join('');\r\n    };\r\n    /**\r\n     * Encodes the atomicized replacementPattern for a supplied ABI and replace kind\r\n     * @param   abis array of AnnotatedFunctionABI\r\n     * @param   replaceKind Parameter kind to replace\r\n     * @return  The resulting encoded replacementPattern\r\n     */\r\n    WyvernProtocol.encodeAtomicizedReplacementPattern = function (abis, replaceKind) {\r\n        if (replaceKind === void 0) { replaceKind = types_1.FunctionInputKind.Replaceable; }\r\n        var allowReplaceByte = '1';\r\n        var doNotAllowReplaceByte = '0';\r\n        /* Four bytes for method ID. */\r\n        var maskArr = [doNotAllowReplaceByte, doNotAllowReplaceByte,\r\n            doNotAllowReplaceByte, doNotAllowReplaceByte];\r\n        var encodedUint256 = ethABI.encodeSingle(ethABI.elementaryName('uint256'), WyvernProtocol.generateDefaultValue('uint256'));\r\n        var dataLocationSize = encodedUint256.length;\r\n        var dynamicArgumentLengthSize = encodedUint256.length;\r\n        // See https://solidity.readthedocs.io/en/develop/abi-spec.html#examples\r\n        // Prepare dymanic types to be passed in (they need locations of their data parts). 4 for addresses, values, calldata lengths, calldatas\r\n        maskArr.push(doNotAllowReplaceByte.repeat(dataLocationSize * 4));\r\n        // Length of addresses array\r\n        maskArr.push(doNotAllowReplaceByte.repeat(dynamicArgumentLengthSize));\r\n        // Addresses should not be replaced\r\n        var encoded = ethABI.encodeSingle(ethABI.elementaryName('address'), WyvernProtocol.generateDefaultValue('address'));\r\n        maskArr.push(doNotAllowReplaceByte.repeat(encoded.length * abis.length));\r\n        // Length of values array\r\n        maskArr.push(doNotAllowReplaceByte.repeat(dynamicArgumentLengthSize));\r\n        // Add the values...\r\n        encoded = ethABI.encodeSingle(ethABI.elementaryName('uint'), WyvernProtocol.generateDefaultValue('uint'));\r\n        maskArr.push(doNotAllowReplaceByte.repeat(encoded.length * abis.length));\r\n        // Length of calldata lengths array\r\n        maskArr.push(doNotAllowReplaceByte.repeat(dynamicArgumentLengthSize));\r\n        // ... and calldata lengths\r\n        maskArr.push(doNotAllowReplaceByte.repeat(encoded.length * abis.length));\r\n        // Length of replacementPatterns\r\n        maskArr.push(doNotAllowReplaceByte.repeat(dynamicArgumentLengthSize));\r\n        // Raw replacementPatterns\r\n        var replacementBytes = [];\r\n        abis.map(function (abi) {\r\n            var replacement = WyvernProtocol.encodeReplacementPattern(abi, replaceKind, false);\r\n            replacementBytes.push(replacement);\r\n        });\r\n        var concatenatedReplacementPatterns = replacementBytes.join('');\r\n        maskArr.push(concatenatedReplacementPatterns);\r\n        if (concatenatedReplacementPatterns.length % 32 !== 0) {\r\n            // Pad replacementPatterns to nearest multiple of 32\r\n            maskArr.push(doNotAllowReplaceByte.repeat(32 - concatenatedReplacementPatterns.length % 32));\r\n        }\r\n        var mask = maskArr.reduce(function (x, y) { return x + y; }, '');\r\n        var ret = [];\r\n        /* Encode into bytes. */\r\n        for (var _i = 0, mask_1 = mask; _i < mask_1.length; _i++) {\r\n            var char = mask_1[_i];\r\n            var byte = char === allowReplaceByte ? 255 : 0;\r\n            var buf = Buffer.alloc(1);\r\n            buf.writeUInt8(byte, 0);\r\n            ret.push(buf);\r\n        }\r\n        return '0x' + Buffer.concat(ret).toString('hex');\r\n    };\r\n    /**\r\n     * Computes the default value for a type\r\n     * @param type The ABI type to calculate a default value for\r\n     * @return The default value for that type\r\n     */\r\n    WyvernProtocol.generateDefaultValue = function (type) {\r\n        switch (type) {\r\n            case 'address':\r\n            case 'bytes20':\r\n                /* Null address is sometimes checked in transfer calls. */\r\n                // But we need to use 0x000 because bitwise XOR won't work if there's a 0 in the actual address, since it will be replaced as 1 OR 0 = 1\r\n                return '0x0000000000000000000000000000000000000000';\r\n            case 'bytes32':\r\n                return '0x0000000000000000000000000000000000000000000000000000000000000000';\r\n            case 'bool':\r\n                return false;\r\n            case 'int':\r\n            case 'uint':\r\n            case 'uint8':\r\n            case 'uint16':\r\n            case 'uint32':\r\n            case 'uint64':\r\n            case 'uint256':\r\n                return 0;\r\n            default:\r\n                throw new Error('Default value not yet implemented for type: ' + type);\r\n        }\r\n    };\r\n    __decorate([\r\n        decorators_1.decorators.syncWyvernProtocolErrorHandler\r\n    ], WyvernProtocol, \"getOrderHashHex\", null);\r\n    return WyvernProtocol;\r\n}());\r\nexports.WyvernProtocol = WyvernProtocol;\r\n//# sourceMappingURL=wyvernProtocol.js.map"]},"metadata":{},"sourceType":"script"}