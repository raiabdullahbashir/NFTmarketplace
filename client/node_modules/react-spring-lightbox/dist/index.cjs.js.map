{"version":3,"file":"index.cjs.js","sources":["../src/components/ImageStage/utils/getTranslateOffsetsFromScale.ts","../src/components/ImageStage/utils/imageIsOutOfBounds.ts","../src/components/ImageStage/components/Image/index.tsx","../src/components/ImageStage/utils/useDoubleClick.tsx","../src/components/ImageStage/components/ImagePager/index.tsx","../src/components/ImageStage/index.tsx","../src/components/ImageStage/utils/useRefSize.tsx","../src/components/PageContainer/index.tsx","../src/components/CreatePortal/index.tsx","../src/index.tsx"],"sourcesContent":["type IGetTranslateOffsetsFromScale = {\r\n    /** The current [x,y] translate values of image */\r\n    currentTranslate: [translateX: number, translateY: number];\r\n    /** The image dom node used as a reference to calculate translate offsets */\r\n    imageRef: React.RefObject<HTMLImageElement>;\r\n    /** The amount of change in the new transform scale */\r\n    pinchDelta: number;\r\n    /** The current transform scale of image */\r\n    scale: number;\r\n    /** The [x,y] coordinates of the zoom origin */\r\n    touchOrigin: [touchOriginX: number, touchOriginY: number];\r\n};\r\n\r\ntype ITranslateOffsetsReturnType = [translateX: number, translateY: number];\r\n\r\n/**\r\n * Calculates the the translate(x,y) coordinates needed to zoom-in\r\n * to a point in an image.\r\n *\r\n * @returns {array} The next [x,y] translate values to apply to image\r\n */\r\nconst getTranslateOffsetsFromScale = ({\r\n    imageRef,\r\n    scale,\r\n    pinchDelta,\r\n    touchOrigin: [touchOriginX, touchOriginY],\r\n    currentTranslate: [translateX, translateY],\r\n}: IGetTranslateOffsetsFromScale): ITranslateOffsetsReturnType => {\r\n    if (!imageRef?.current) {\r\n        return [0, 0];\r\n    }\r\n\r\n    const {\r\n        height: imageHeight,\r\n        left: imageTopLeftX,\r\n        top: imageTopLeftY,\r\n        width: imageWidth,\r\n    } = imageRef.current?.getBoundingClientRect();\r\n\r\n    // Get the (x,y) touch position relative to image origin at the current scale\r\n    const imageCoordX = (touchOriginX - imageTopLeftX - imageWidth / 2) / scale;\r\n    const imageCoordY =\r\n        (touchOriginY - imageTopLeftY - imageHeight / 2) / scale;\r\n\r\n    // Calculate translateX/Y offset at the next scale to zoom to touch position\r\n    const newTranslateX = -imageCoordX * pinchDelta + translateX;\r\n    const newTranslateY = -imageCoordY * pinchDelta + translateY;\r\n\r\n    return [newTranslateX, newTranslateY];\r\n};\r\n\r\nexport default getTranslateOffsetsFromScale;\r\n","/**\r\n * Determines if the provided image is within the viewport\r\n *\r\n * @returns True if image needs to be resized to fit viewport, otherwise false\r\n */\r\nconst imageIsOutOfBounds = (\r\n    imageRef: React.RefObject<HTMLImageElement>\r\n): boolean => {\r\n    // If no ref is provided, return false\r\n    if (!imageRef.current) {\r\n        return false;\r\n    }\r\n\r\n    const {\r\n        bottom: bottomRightY,\r\n        left: topLeftX,\r\n        right: bottomRightX,\r\n        top: topLeftY,\r\n    } = imageRef.current?.getBoundingClientRect();\r\n    const { innerHeight: windowHeight, innerWidth: windowWidth } = window;\r\n\r\n    if (\r\n        topLeftX > windowWidth * (1 / 2) ||\r\n        topLeftY > windowHeight * (1 / 2) ||\r\n        bottomRightX < windowWidth * (1 / 2) ||\r\n        bottomRightY < windowHeight * (1 / 2)\r\n    )\r\n        return true;\r\n\r\n    return false;\r\n};\r\n\r\nexport default imageIsOutOfBounds;\r\n","import { animated, to, useSpring } from '@react-spring/web';\r\nimport {\r\n    getTranslateOffsetsFromScale,\r\n    imageIsOutOfBounds,\r\n    useDoubleClick,\r\n} from '../../utils';\r\nimport { useGesture } from 'react-use-gesture';\r\nimport React, { useEffect, useRef, useState } from 'react';\r\nimport styled from 'styled-components';\r\nimport type { ImagesListItem } from '../../../../types/ImagesList';\r\n\r\nconst defaultImageTransform = {\r\n    pinching: false,\r\n    scale: 1,\r\n    translateX: 0,\r\n    translateY: 0,\r\n};\r\n\r\ntype IImageProps = {\r\n    /** Any valid <img /> props to pass to the lightbox img element ie src, alt, caption etc*/\r\n    imgProps: ImagesListItem;\r\n    /** Affects Width calculation method, depending on whether the Lightbox is Inline or not */\r\n    inline: boolean;\r\n    /** True if this image is currently shown in pager, otherwise false */\r\n    isCurrentImage: boolean;\r\n    /** Fixed height of the image stage, used to restrict maximum height of images */\r\n    pagerHeight: '100%' | number;\r\n    /** Indicates parent ImagePager is in a state of dragging, if true click to zoom is disabled */\r\n    pagerIsDragging: boolean;\r\n    /** Function that can be called to disable dragging in the pager */\r\n    setDisableDrag: (disable: boolean) => void;\r\n    /** Overrides the default behavior of double clicking causing an image zoom to a single click */\r\n    singleClickToZoom: boolean;\r\n};\r\n\r\n/**\r\n * Animates pinch-zoom + panning on image using spring physics\r\n */\r\nconst Image = ({\r\n    imgProps: { style: imgStyleProp, ...restImgProps },\r\n    inline,\r\n    isCurrentImage,\r\n    pagerHeight,\r\n    pagerIsDragging,\r\n    setDisableDrag,\r\n    singleClickToZoom,\r\n}: IImageProps) => {\r\n    const [isPanningImage, setIsPanningImage] = useState<boolean>(false);\r\n    const imageRef = useRef<HTMLImageElement>(null);\r\n\r\n    /**\r\n     * Animates scale and translate offsets of Image as they change in gestures\r\n     *\r\n     * @see https://www.react-spring.io/docs/hooks/use-spring\r\n     */\r\n    const [{ scale, translateX, translateY }, springApi] = useSpring(() => ({\r\n        ...defaultImageTransform,\r\n        onChange: (result, instance) => {\r\n            if (result.value.scale < 1 || !result.value.pinching) {\r\n                instance.start(defaultImageTransform);\r\n            }\r\n\r\n            if (result.value.scale > 1 && imageIsOutOfBounds(imageRef)) {\r\n                instance.start(defaultImageTransform);\r\n            }\r\n        },\r\n        // Enable dragging in ImagePager if image is at the default size\r\n        onRest: (result, instance) => {\r\n            if (result.value.scale === 1) {\r\n                instance.start(defaultImageTransform);\r\n                setDisableDrag(false);\r\n            }\r\n        },\r\n    }));\r\n\r\n    // Reset scale of this image when dragging to new image in ImagePager\r\n    useEffect(() => {\r\n        if (!isCurrentImage && scale.get() !== 1) {\r\n            springApi.start(defaultImageTransform);\r\n        }\r\n    }, [isCurrentImage, scale, springApi]);\r\n\r\n    /**\r\n     * Update Image scale and translate offsets during pinch/pan gestures\r\n     *\r\n     * @see https://github.com/react-spring/react-use-gesture#usegesture-hook-supporting-multiple-gestures-at-once\r\n     */\r\n    useGesture(\r\n        {\r\n            onDrag: ({\r\n                movement: [xMovement, yMovement],\r\n                pinching,\r\n                cancel,\r\n                first,\r\n                memo = { initialTranslateX: 0, initialTranslateY: 0 },\r\n                touches,\r\n                tap,\r\n            }) => {\r\n                if (pagerIsDragging || scale.get() === 1 || tap) {\r\n                    return;\r\n                }\r\n\r\n                // Disable click to zoom during drag\r\n                if (xMovement && yMovement && !isPanningImage) {\r\n                    setIsPanningImage(true);\r\n                }\r\n\r\n                if (touches > 1) {\r\n                    return;\r\n                }\r\n                if (pinching || scale.get() <= 1) {\r\n                    return;\r\n                }\r\n\r\n                // Prevent dragging image out of viewport\r\n                if (scale.get() > 1 && imageIsOutOfBounds(imageRef)) {\r\n                    cancel();\r\n                    return;\r\n                } else {\r\n                    if (first) {\r\n                        return {\r\n                            initialTranslateX: translateX.get(),\r\n                            initialTranslateY: translateY.get(),\r\n                        };\r\n                    }\r\n\r\n                    // Translate image from dragging\r\n                    springApi.start({\r\n                        translateX: memo.initialTranslateX + xMovement,\r\n                        translateY: memo.initialTranslateY + yMovement,\r\n                    });\r\n\r\n                    return memo;\r\n                }\r\n            },\r\n            onDragEnd: ({ memo }) => {\r\n                if (memo !== undefined) {\r\n                    // Add small timeout to prevent onClick handler from firing after drag\r\n                    setTimeout(() => setIsPanningImage(false), 100);\r\n                }\r\n            },\r\n            onPinch: ({\r\n                movement: [xMovement],\r\n                origin: [touchOriginX, touchOriginY],\r\n                event,\r\n                ctrlKey,\r\n                last,\r\n                cancel,\r\n            }) => {\r\n                if (pagerIsDragging) {\r\n                    return;\r\n                }\r\n\r\n                // Prevent ImagePager from registering isDragging\r\n                setDisableDrag(true);\r\n\r\n                // Disable click to zoom during pinch\r\n                if (xMovement && !isPanningImage) {\r\n                    setIsPanningImage(true);\r\n                }\r\n\r\n                // Don't calculate new translate offsets on final frame\r\n                if (last) {\r\n                    cancel();\r\n                    return;\r\n                }\r\n\r\n                // Speed up pinch zoom when using mouse versus touch\r\n                const SCALE_FACTOR = ctrlKey ? 1000 : 250;\r\n                const pinchScale = scale.get() + xMovement / SCALE_FACTOR;\r\n                const pinchDelta = pinchScale - scale.get();\r\n\r\n                /**\r\n                 * Calculate touch origin for pinch/zoom\r\n                 *\r\n                 * if event is a touch event (React.TouchEvent<Element>, TouchEvent or WebKitGestureEvent) use touchOriginX/Y\r\n                 * if event is a wheel event (React.WheelEvent<Element> or WheelEvent) use the mouse cursor's clientX/Y\r\n                 */\r\n                let touchOrigin: [touchOriginX: number, touchOriginY: number] =\r\n                    [touchOriginX, touchOriginY];\r\n                if ('clientX' in event && 'clientY' in event && ctrlKey) {\r\n                    touchOrigin = [event.clientX, event.clientY];\r\n                }\r\n\r\n                // Calculate the amount of x, y translate offset needed to\r\n                // zoom-in to point as image scale grows\r\n                const [newTranslateX, newTranslateY] =\r\n                    getTranslateOffsetsFromScale({\r\n                        currentTranslate: [translateX.get(), translateY.get()],\r\n                        imageRef,\r\n                        pinchDelta,\r\n                        scale: scale.get(),\r\n                        // Use the [x, y] coords of mouse if a trackpad or ctrl + wheel event\r\n                        // Otherwise use touch origin\r\n                        touchOrigin,\r\n                    });\r\n\r\n                // Restrict the amount of zoom between half and 3x image size\r\n                if (pinchScale < 0.5) {\r\n                    springApi.start({ pinching: true, scale: 0.5 });\r\n                } else if (pinchScale > 3.0) {\r\n                    springApi.start({ pinching: true, scale: 3.0 });\r\n                } else {\r\n                    springApi.start({\r\n                        pinching: true,\r\n                        scale: pinchScale,\r\n                        translateX: newTranslateX,\r\n                        translateY: newTranslateY,\r\n                    });\r\n                }\r\n            },\r\n            onPinchEnd: () => {\r\n                if (!pagerIsDragging) {\r\n                    if (scale.get() > 1) {\r\n                        setDisableDrag(true);\r\n                    } else {\r\n                        springApi.start(defaultImageTransform);\r\n                    }\r\n                    // Add small timeout to prevent onClick handler from firing after panning\r\n                    setTimeout(() => setIsPanningImage(false), 100);\r\n                }\r\n            },\r\n        },\r\n        /**\r\n         * useGesture config\r\n         * @see https://github.com/react-spring/react-use-gesture#usegesture-config\r\n         */\r\n        {\r\n            domTarget: imageRef as React.RefObject<EventTarget>,\r\n            drag: {\r\n                filterTaps: true,\r\n            },\r\n            enabled: !inline,\r\n            eventOptions: {\r\n                passive: false,\r\n            },\r\n        }\r\n    );\r\n\r\n    // Handle click/tap on image\r\n    useDoubleClick({\r\n        [singleClickToZoom ? 'onSingleClick' : 'onDoubleClick']: (\r\n            e: MouseEvent\r\n        ) => {\r\n            if (pagerIsDragging || isPanningImage) {\r\n                e.stopPropagation();\r\n                return;\r\n            }\r\n\r\n            // If tapped while already zoomed-in, zoom out to default scale\r\n            if (scale.get() !== 1) {\r\n                springApi.start(defaultImageTransform);\r\n                return;\r\n            }\r\n\r\n            // Zoom-in to origin of click on image\r\n            const { clientX: touchOriginX, clientY: touchOriginY } = e;\r\n            const pinchScale = scale.get() + 1;\r\n            const pinchDelta = pinchScale - scale.get();\r\n\r\n            // Calculate the amount of x, y translate offset needed to\r\n            // zoom-in to point as image scale grows\r\n            const [newTranslateX, newTranslateY] = getTranslateOffsetsFromScale(\r\n                {\r\n                    currentTranslate: [translateX.get(), translateY.get()],\r\n                    imageRef,\r\n                    pinchDelta,\r\n                    scale: scale.get(),\r\n                    touchOrigin: [touchOriginX, touchOriginY],\r\n                }\r\n            );\r\n\r\n            // Disable dragging in pager\r\n            setDisableDrag(true);\r\n            springApi.start({\r\n                pinching: true,\r\n                scale: pinchScale,\r\n                translateX: newTranslateX,\r\n                translateY: newTranslateY,\r\n            });\r\n        },\r\n        enabled: !inline,\r\n        latency: singleClickToZoom ? 0 : 200,\r\n        ref: imageRef,\r\n    });\r\n\r\n    return (\r\n        <AnimatedImage\r\n            $inline={inline}\r\n            className=\"lightbox-image\"\r\n            draggable=\"false\"\r\n            onClick={(e: React.MouseEvent<HTMLImageElement>) => {\r\n                // Don't close lighbox when clicking image\r\n                e.stopPropagation();\r\n                e.nativeEvent.stopImmediatePropagation();\r\n            }}\r\n            onDragStart={(e: React.DragEvent<HTMLImageElement>) => {\r\n                // Disable image ghost dragging in firefox\r\n                e.preventDefault();\r\n            }}\r\n            ref={imageRef}\r\n            style={{\r\n                ...imgStyleProp,\r\n                maxHeight: pagerHeight,\r\n                transform: to(\r\n                    [scale, translateX, translateY],\r\n                    (s, x, y) => `translate(${x}px, ${y}px) scale(${s})`\r\n                ),\r\n                ...(isCurrentImage && { willChange: 'transform' }),\r\n            }}\r\n            // Include any valid img html attributes provided in the <Lightbox /> images prop\r\n            {...(restImgProps as React.ComponentProps<typeof animated.img>)}\r\n        />\r\n    );\r\n};\r\n\r\nImage.displayName = 'Image';\r\n\r\nexport default Image;\r\n\r\nconst AnimatedImage = styled(animated.img)<{ $inline: boolean }>`\r\n    width: auto;\r\n    height: auto;\r\n    max-width: 100%;\r\n    user-select: none;\r\n    touch-action: ${({ $inline }) => (!$inline ? 'none' : 'pan-y')};\r\n    ::selection {\r\n        background: none;\r\n    }\r\n`;\r\n","import React, { useEffect } from 'react';\r\n\r\ntype IUseDoubleClickProps = {\r\n    /** Set to false to disable onDoubleClick/onSingleClick  */\r\n    enabled?: boolean;\r\n    /** The amount of time (in milliseconds) to wait before differentiating a single from a double click */\r\n    latency?: number;\r\n    /** A callback function for double click events */\r\n    onDoubleClick?: (event: MouseEvent) => void;\r\n    /** A callback function for single click events */\r\n    onSingleClick?: (event: MouseEvent) => void;\r\n    /** Dom node to watch for double clicks */\r\n    ref: React.RefObject<HTMLElement>;\r\n};\r\n\r\n/**\r\n * React Hook that returns the current window size\r\n * and report updates from the 'resize' window event\r\n */\r\nconst useDoubleClick = ({\r\n    ref,\r\n    latency = 300,\r\n    enabled = true,\r\n    onSingleClick = () => null,\r\n    onDoubleClick = () => null,\r\n}: IUseDoubleClickProps) => {\r\n    useEffect(() => {\r\n        const clickRef = ref.current;\r\n        let clickCount = 0;\r\n        let timer: ReturnType<typeof setTimeout>;\r\n\r\n        const handleClick = (e: MouseEvent) => {\r\n            if (enabled) {\r\n                clickCount += 1;\r\n\r\n                timer = setTimeout(() => {\r\n                    if (clickCount === 1) onSingleClick(e);\r\n                    else if (clickCount === 2) onDoubleClick(e);\r\n\r\n                    clickCount = 0;\r\n                }, latency);\r\n            }\r\n        };\r\n\r\n        // Add event listener for click events\r\n        clickRef?.addEventListener('click', handleClick);\r\n\r\n        // Remove event listener\r\n        return () => {\r\n            clickRef?.removeEventListener('click', handleClick);\r\n\r\n            if (timer) {\r\n                clearTimeout(timer);\r\n            }\r\n        };\r\n    });\r\n};\r\n\r\nexport default useDoubleClick;\r\n","import { animated, useSprings } from '@react-spring/web';\r\nimport { useGesture } from 'react-use-gesture';\r\nimport Image from '../Image';\r\nimport React, { useEffect, useRef, useState } from 'react';\r\nimport styled from 'styled-components';\r\nimport type { ImagesList } from '../../../../types/ImagesList';\r\n\r\ntype IImagePager = {\r\n    /** Index of image in images array that is currently shown */\r\n    currentIndex: number;\r\n    /** image stage height */\r\n    imageStageHeight: number;\r\n    /** image stage width */\r\n    imageStageWidth: number;\r\n    /** Array of image objects to be shown in Lightbox */\r\n    images: ImagesList;\r\n    /** Affects Width calculation method, depending on whether the Lightbox is Inline or not */\r\n    inline: boolean;\r\n    /** Function that closes the Lightbox */\r\n    onClose?: () => void;\r\n    /** Function that can be called to disable dragging in the pager */\r\n    onNext: () => void;\r\n    /** True if this image is currently shown in pager, otherwise false */\r\n    onPrev: () => void;\r\n    /** A React component that renders inside the image stage, useful for making overlays over the image */\r\n    renderImageOverlay: () => React.ReactNode;\r\n    /** Overrides the default behavior of double clicking causing an image zoom to a single click */\r\n    singleClickToZoom: boolean;\r\n};\r\n\r\n/**\r\n * Gesture controlled surface that animates prev/next page changes via spring physics.\r\n */\r\nconst ImagePager = ({\r\n    currentIndex,\r\n    images,\r\n    imageStageHeight,\r\n    imageStageWidth,\r\n    inline,\r\n    onClose,\r\n    onNext,\r\n    onPrev,\r\n    renderImageOverlay,\r\n    singleClickToZoom,\r\n}: IImagePager) => {\r\n    const firstRender = useRef(true);\r\n\r\n    const [disableDrag, setDisableDrag] = useState<boolean>(false);\r\n    const [pagerHeight, setPagerHeight] = useState<'100%' | number>('100%');\r\n    const [isDragging, setIsDragging] = useState<boolean>(false);\r\n\r\n    //Determine the absolute height of the image pager\r\n    useEffect(() => {\r\n        const currPagerHeight = inline\r\n            ? imageStageHeight\r\n            : imageStageHeight - 50;\r\n\r\n        if (currPagerHeight !== pagerHeight) {\r\n            setPagerHeight(currPagerHeight);\r\n        }\r\n    }, [inline, pagerHeight, imageStageHeight]);\r\n\r\n    // Generate page positions based on current index\r\n    const getPagePositions = React.useCallback(\r\n        (i: number, down = false, xDelta = 0) => {\r\n            const x =\r\n                (i - currentIndex) * imageStageWidth + (down ? xDelta : 0);\r\n\r\n            if (i < currentIndex - 1 || i > currentIndex + 1) {\r\n                return { display: 'none', x };\r\n            }\r\n            return { display: 'flex', x };\r\n        },\r\n        [currentIndex, imageStageWidth]\r\n    );\r\n\r\n    /**\r\n     * Animates translateX of all images at the same time\r\n     *\r\n     * @see https://www.react-spring.io/docs/hooks/use-springs\r\n     */\r\n    const [pagerSprings, springsApi] = useSprings(images.length, (i) =>\r\n        getPagePositions(i)\r\n    );\r\n\r\n    // Animate page change if currentIndex changes\r\n    useEffect(() => {\r\n        // No need to set page position for initial render\r\n        if (firstRender.current) {\r\n            firstRender.current = false;\r\n            return;\r\n        }\r\n        // Update page positions after prev/next page state change\r\n        springsApi.start((i) => getPagePositions(i));\r\n    }, [currentIndex, getPagePositions, springsApi]);\r\n\r\n    /**\r\n     * Update each Image's visibility and translateX offset during dragging\r\n     *\r\n     * @see https://github.com/react-spring/react-use-gesture\r\n     */\r\n    const bind = useGesture(\r\n        {\r\n            onDrag: ({\r\n                down,\r\n                movement: [xMovement],\r\n                direction: [xDir],\r\n                velocity,\r\n                distance,\r\n                cancel,\r\n                active,\r\n                touches,\r\n                tap,\r\n            }) => {\r\n                // Disable drag if Image has been zoomed in to allow for panning\r\n                if (disableDrag || xMovement === 0 || tap) {\r\n                    return;\r\n                }\r\n                if (!isDragging) {\r\n                    setIsDragging(true);\r\n                }\r\n\r\n                const isHorizontalDrag = Math.abs(xDir) > 0.7;\r\n                const draggedFarEnough =\r\n                    down &&\r\n                    isHorizontalDrag &&\r\n                    distance > imageStageWidth / 3.5;\r\n                const draggedFastEnough =\r\n                    down && isHorizontalDrag && velocity > 2;\r\n\r\n                // Handle next/prev image from valid drag\r\n                if ((draggedFarEnough || draggedFastEnough) && active) {\r\n                    const goToIndex = xDir > 0 ? -1 : 1;\r\n\r\n                    // Cancel gesture event\r\n                    cancel();\r\n\r\n                    if (goToIndex > 0) {\r\n                        onNext();\r\n                    } else if (goToIndex < 0) {\r\n                        onPrev();\r\n                    }\r\n\r\n                    return;\r\n                }\r\n\r\n                // Don't move pager during two+ finger touch events, i.e. pinch-zoom\r\n                if (touches > 1) {\r\n                    cancel();\r\n                    return;\r\n                }\r\n\r\n                // Update page x-coordinates for single finger/mouse gestures\r\n                springsApi.start((i) => getPagePositions(i, down, xMovement));\r\n                return;\r\n            },\r\n            onDragEnd: () => {\r\n                if (isDragging) {\r\n                    springsApi.start((i) => getPagePositions(i));\r\n                    // Add small timeout buffer to prevent event handlers from firing in child Images\r\n                    setTimeout(() => setIsDragging(false), 100);\r\n                }\r\n            },\r\n            onWheel: ({ velocity, direction: [xDir, yDir], ctrlKey }) => {\r\n                // Disable drag if Image has been zoomed in to allow for panning\r\n                if (ctrlKey || disableDrag || velocity === 0) {\r\n                    return;\r\n                }\r\n\r\n                if (!isDragging) {\r\n                    setIsDragging(true);\r\n                }\r\n\r\n                const draggedFastEnough = velocity > 1.1;\r\n\r\n                // Handle next/prev image from valid drag\r\n                if (draggedFastEnough) {\r\n                    const goToIndex = xDir + yDir > 0 ? -1 : 1;\r\n\r\n                    if (goToIndex > 0) {\r\n                        onNext();\r\n                    } else if (goToIndex < 0) {\r\n                        onPrev();\r\n                    }\r\n                }\r\n            },\r\n            onWheelEnd: () => {\r\n                springsApi.start((i) => getPagePositions(i));\r\n                // Add small timeout buffer to prevent event handlers from firing in child Images\r\n                setTimeout(() => setIsDragging(false), 100);\r\n            },\r\n        },\r\n        {\r\n            drag: {\r\n                filterTaps: true,\r\n            },\r\n            wheel: {\r\n                enabled: !inline,\r\n            },\r\n        }\r\n    );\r\n\r\n    return (\r\n        <ImagePagerContainer>\r\n            {pagerSprings.map(({ display, x }, i) => (\r\n                <AnimatedImagePager\r\n                    $inline={inline}\r\n                    {...bind()}\r\n                    className=\"lightbox-image-pager\"\r\n                    key={i}\r\n                    onClick={() => {\r\n                        if (onClose) {\r\n                            return (\r\n                                Math.abs(x.get()) < 1 &&\r\n                                !disableDrag &&\r\n                                onClose()\r\n                            );\r\n                        }\r\n                    }}\r\n                    role=\"presentation\"\r\n                    style={{\r\n                        display,\r\n                        transform: x.to(\r\n                            (xInterp: number) => `translateX(${xInterp}px)`\r\n                        ),\r\n                    }}\r\n                >\r\n                    <PagerContentWrapper>\r\n                        <PagerInnerContentWrapper>\r\n                            <ImageContainer\r\n                                $inline={inline}\r\n                                onClick={(e) => {\r\n                                    e.stopPropagation();\r\n                                    e.nativeEvent.stopImmediatePropagation();\r\n                                }}\r\n                            >\r\n                                <Image\r\n                                    imgProps={images[i]}\r\n                                    inline={inline}\r\n                                    isCurrentImage={i === currentIndex}\r\n                                    pagerHeight={pagerHeight}\r\n                                    pagerIsDragging={isDragging}\r\n                                    setDisableDrag={setDisableDrag}\r\n                                    singleClickToZoom={singleClickToZoom}\r\n                                />\r\n                                {renderImageOverlay()}\r\n                            </ImageContainer>\r\n                        </PagerInnerContentWrapper>\r\n                    </PagerContentWrapper>\r\n                </AnimatedImagePager>\r\n            ))}\r\n        </ImagePagerContainer>\r\n    );\r\n};\r\n\r\nImagePager.displayName = 'ImagePager';\r\n\r\nexport default ImagePager;\r\n\r\nconst ImagePagerContainer = styled.div`\r\n    height: 100%;\r\n    width: 100%;\r\n`;\r\n\r\nconst PagerInnerContentWrapper = styled.div`\r\n    display: flex;\r\n    justify-content: center;\r\n    align-items: center;\r\n`;\r\n\r\nconst PagerContentWrapper = styled.div`\r\n    width: 100%;\r\n    display: flex;\r\n    justify-content: center;\r\n`;\r\n\r\nconst AnimatedImagePager = styled(animated.div)<{ $inline: boolean }>`\r\n    position: absolute;\r\n    top: 0px;\r\n    left: 0px;\r\n    right: 0px;\r\n    bottom: 0px;\r\n    height: 100%;\r\n    width: 100%;\r\n    will-change: transform;\r\n    touch-action: ${({ $inline }) => (!$inline ? 'none' : 'pan-y')};\r\n    display: flex;\r\n    flex-direction: column;\r\n    justify-content: center;\r\n    align-items: center;\r\n`;\r\n\r\nconst ImageContainer = styled.div<{ $inline: boolean }>`\r\n    position: relative;\r\n    touch-action: ${({ $inline }) => (!$inline ? 'none' : 'pan-y')};\r\n    user-select: none;\r\n    display: flex;\r\n    justify-content: center;\r\n    width: 100%;\r\n`;\r\n","import ImagePager from './components/ImagePager';\r\nimport React from 'react';\r\nimport styled from 'styled-components';\r\nimport useRefSize from './utils/useRefSize';\r\nimport type { ImagesList } from '../../types/ImagesList';\r\n\r\ntype IImageStageProps = {\r\n    /** classnames are applied to the root ImageStage component */\r\n    className?: string;\r\n    /** Index of image in images array that is currently shown */\r\n    currentIndex: number;\r\n    /** Array of image objects to be shown in Lightbox */\r\n    images: ImagesList;\r\n    /** Affects Width calculation method, depending on whether the Lightbox is Inline or not */\r\n    inline: boolean;\r\n    /** Function that closes the Lightbox */\r\n    onClose?: () => void;\r\n    /** Function that can be called to disable dragging in the pager */\r\n    onNext: () => void;\r\n    /** True if this image is currently shown in pager, otherwise false */\r\n    onPrev: () => void;\r\n    /** A React component that renders inside the image stage, useful for making overlays over the image */\r\n    renderImageOverlay: () => React.ReactNode;\r\n    /** A React component that is used for next button in image pager */\r\n    renderNextButton: ({ canNext }: { canNext: boolean }) => React.ReactNode;\r\n    /** A React component that is used for previous button in image pager */\r\n    renderPrevButton: ({ canPrev }: { canPrev: boolean }) => React.ReactNode;\r\n    /** Overrides the default behavior of double clicking causing an image zoom to a single click */\r\n    singleClickToZoom: boolean;\r\n};\r\n\r\n/**\r\n * Containing element for ImagePager and prev/next button controls\r\n */\r\nconst ImageStage = ({\r\n    className = '',\r\n    currentIndex,\r\n    images,\r\n    inline,\r\n    onClose,\r\n    onNext,\r\n    onPrev,\r\n    renderImageOverlay,\r\n    renderNextButton,\r\n    renderPrevButton,\r\n    singleClickToZoom,\r\n}: IImageStageProps) => {\r\n    // Extra sanity check that the next/prev image exists before moving to it\r\n    const canPrev = currentIndex > 0;\r\n    const canNext = currentIndex + 1 < images.length;\r\n\r\n    const onNextImage = canNext ? onNext : () => null;\r\n    const onPrevImage = canPrev ? onPrev : () => null;\r\n\r\n    const [{ height: containerHeight, width: containerWidth }, containerRef] =\r\n        useRefSize();\r\n\r\n    return (\r\n        <ImageStageContainer\r\n            className={className}\r\n            data-testid=\"lightbox-image-stage\"\r\n            ref={containerRef}\r\n        >\r\n            {renderPrevButton({ canPrev })}\r\n            {containerWidth && (\r\n                <ImagePager\r\n                    currentIndex={currentIndex}\r\n                    images={images}\r\n                    imageStageHeight={containerHeight}\r\n                    imageStageWidth={containerWidth}\r\n                    inline={inline}\r\n                    onClose={onClose}\r\n                    onNext={onNextImage}\r\n                    onPrev={onPrevImage}\r\n                    renderImageOverlay={renderImageOverlay}\r\n                    singleClickToZoom={singleClickToZoom}\r\n                />\r\n            )}\r\n            {renderNextButton({ canNext })}\r\n        </ImageStageContainer>\r\n    );\r\n};\r\n\r\nexport default ImageStage;\r\n\r\nconst ImageStageContainer = styled.div`\r\n    position: relative;\r\n    height: 100%;\r\n    width: 100%;\r\n    display: flex;\r\n    justify-content: center;\r\n    align-items: center;\r\n`;\r\n","import { useCallback, useEffect, useRef, useState } from 'react';\r\n\r\ntype RefSize = {\r\n    height: number;\r\n    width: number;\r\n};\r\n\r\ntype Node = HTMLDivElement | null;\r\n\r\ntype IUseRefSize = [refSize: RefSize, elementRef: (node: any) => void | null];\r\n\r\n/**\r\n * React Hook that returns the current ref size\r\n * and report updates from the 'resize' ref event\r\n *\r\n * @returns {RefSize} An object containing the ref width and height\r\n * @returns {elementRef} A callback ref to be used on the container being measured\r\n */\r\nconst useRefSize = (): IUseRefSize => {\r\n    const ref = useRef<HTMLDivElement>(null);\r\n\r\n    const [node, setNode] = useState<Node>(null);\r\n    const [refSize, setRefSize] = useState<RefSize>({\r\n        height: ref.current?.clientHeight || 0,\r\n        width: ref.current?.clientWidth || 0,\r\n    });\r\n\r\n    const elementRef = useCallback((node) => {\r\n        if (node !== null) {\r\n            setNode(node);\r\n\r\n            setRefSize({\r\n                height: node.clientHeight,\r\n                width: node.clientWidth,\r\n            });\r\n        }\r\n    }, []);\r\n\r\n    useEffect(() => {\r\n        const handleResize = () => {\r\n            if (node) {\r\n                const height = node.clientHeight;\r\n                const width = node.clientWidth;\r\n                if (height !== refSize.height || width !== refSize.width) {\r\n                    setRefSize({\r\n                        height,\r\n                        width,\r\n                    });\r\n                }\r\n            }\r\n        };\r\n\r\n        window.addEventListener('resize', handleResize);\r\n        window.addEventListener('orientationchange', handleResize);\r\n\r\n        return () => {\r\n            window.removeEventListener('resize', handleResize);\r\n            window.removeEventListener('orientationchange', handleResize);\r\n        };\r\n    }, [node, refSize.height, refSize.width]);\r\n\r\n    return [refSize, elementRef];\r\n};\r\n\r\nexport default useRefSize;\r\n","import React from 'react';\r\nimport { useTransition, animated, config } from '@react-spring/web';\r\nimport styled from 'styled-components';\r\n\r\ntype IPageContainerProps = {\r\n    /** All child components of Lightbox */\r\n    children: React.ReactNode[];\r\n    /** Classes are applied to the root lightbox component */\r\n    className: string;\r\n    /** Flag that dictates if the lightbox is open or closed */\r\n    isOpen: boolean;\r\n    /** React-Spring useTransition config for page open/close animation */\r\n    pageTransitionConfig: any;\r\n    /** Inline styles are applied to the root lightbox component */\r\n    style: React.CSSProperties;\r\n};\r\n\r\n/**\r\n * Animates the lightbox as it opens/closes\r\n */\r\nconst PageContainer = ({\r\n    children,\r\n    className,\r\n    isOpen,\r\n    pageTransitionConfig,\r\n    style,\r\n}: IPageContainerProps) => {\r\n    const defaultTransition = {\r\n        config: { ...config.default, friction: 32, mass: 1, tension: 320 },\r\n        enter: { opacity: 1, transform: 'scale(1)' },\r\n        from: { opacity: 0, transform: 'scale(0.75)' },\r\n        leave: { opacity: 0, transform: 'scale(0.75)' },\r\n    };\r\n\r\n    const transitions = useTransition(isOpen, {\r\n        ...defaultTransition,\r\n        ...pageTransitionConfig,\r\n    });\r\n\r\n    return (\r\n        <>\r\n            {transitions(\r\n                (animatedStyles, item) =>\r\n                    item && (\r\n                        <AnimatedPageContainer\r\n                            className={`lightbox-container${\r\n                                className ? ` ${className}` : ''\r\n                            }`}\r\n                            data-testid=\"lightbox-container\"\r\n                            style={{ ...animatedStyles, ...style }}\r\n                        >\r\n                            {children}\r\n                        </AnimatedPageContainer>\r\n                    )\r\n            )}\r\n        </>\r\n    );\r\n};\r\n\r\nexport default PageContainer;\r\n\r\nconst AnimatedPageContainer = styled(animated.div)`\r\n    display: flex;\r\n    flex-direction: column;\r\n    position: fixed;\r\n    z-index: 400;\r\n    top: 0;\r\n    bottom: 0;\r\n    left: 0;\r\n    right: 0;\r\n`;\r\n","import React from 'react';\r\nimport ReactDOM from 'react-dom';\r\n\r\ntype ICreatePortal = {\r\n    children: React.ReactNode;\r\n};\r\n\r\n/**\r\n * Creates a SSR + next.js friendly React Portal inside <body />\r\n *\r\n * Child components are rendered on the client side only\r\n\r\n * @see https://reactjs.org/docs/portals.html\r\n */\r\nclass CreatePortal extends React.Component<ICreatePortal> {\r\n    portalContainer: HTMLDivElement;\r\n    body: HTMLElement;\r\n\r\n    // Only executes on the client-side\r\n    componentDidMount() {\r\n        // Get the document body\r\n        this.body = document.body;\r\n\r\n        // Create a container <div /> for React Portal\r\n        this.portalContainer = document.createElement('div');\r\n        this.portalContainer.setAttribute('class', 'lightbox-portal');\r\n\r\n        // Append the container to the document body\r\n        this.body.appendChild(this.portalContainer);\r\n\r\n        // Force a re-render as we're on the client side now\r\n        // children prop will render to portalContainer\r\n        this.forceUpdate();\r\n\r\n        // Add event listener to prevent trackpad/ctrl+mousewheel zooming of lightbox\r\n        // Zooming is handled specifically within /ImageStage/components/Image\r\n        this.portalContainer.addEventListener('wheel', this.preventWheel);\r\n    }\r\n\r\n    componentWillUnmount() {\r\n        // Remove wheel event listener\r\n        this.portalContainer.removeEventListener('wheel', this.preventWheel);\r\n\r\n        // Cleanup Portal from DOM\r\n        this.body.removeChild(this.portalContainer);\r\n    }\r\n\r\n    preventWheel = (e: WheelEvent) => e.preventDefault();\r\n\r\n    render() {\r\n        // Return null during SSR\r\n        if (this.portalContainer === undefined) return null;\r\n\r\n        const { children } = this.props;\r\n\r\n        return <>{ReactDOM.createPortal(children, this.portalContainer)}</>;\r\n    }\r\n}\r\n\r\nexport default CreatePortal;\r\n","import React, { useEffect } from 'react';\r\nimport { ImageStage, PageContainer, CreatePortal } from './components';\r\nimport type { ImagesList } from './types/ImagesList';\r\n\r\nexport type ImagesListType = ImagesList;\r\n\r\ntype ILightboxProps = {\r\n    /** classnames are applied to the root lightbox component */\r\n    className?: string;\r\n    /** Index of image in images array that is currently shown */\r\n    currentIndex: number;\r\n    /** Array of images to be shown in Lightbox, each image object may contain any valid 'img' attribute with the exceptions of 'draggable', 'onClick', 'onDragStart' and 'ref' */\r\n    images: ImagesList;\r\n    /** Determines whether the Lightbox returns just an Inline carousel (ImageStage) */\r\n    inline?: boolean;\r\n    /** Flag that dictates if the lightbox is open or closed */\r\n    isOpen: boolean;\r\n    /** Function that closes the Lightbox */\r\n    onClose?: () => void;\r\n    /** Function that changes currentIndex to next image in images */\r\n    onNext: () => void;\r\n    /** Function that changes currentIndex to previous image in images */\r\n    onPrev: () => void;\r\n    /** React-Spring useTransition config for page open/close animation */\r\n    pageTransitionConfig?: any;\r\n    /** A React component that renders below the image pager */\r\n    renderFooter?: () => React.ReactNode;\r\n    /** A React component that renders above the image pager */\r\n    renderHeader?: () => React.ReactNode;\r\n    /** A React component that renders inside the image stage, useful for making overlays over the image */\r\n    renderImageOverlay?: () => React.ReactNode;\r\n    /** A React component that is used for next button in image pager */\r\n    renderNextButton?: () => React.ReactNode;\r\n    /** A React component that is used for previous button in image pager */\r\n    renderPrevButton?: () => React.ReactNode;\r\n    /** Overrides the default behavior of double clicking causing an image zoom to a single click */\r\n    singleClickToZoom?: boolean;\r\n    /** Inline styles that are applied to the root lightbox component */\r\n    style?: React.CSSProperties;\r\n};\r\n\r\n/**\r\n * Gesture controlled lightbox that interpolates animations with spring physics.\r\n *\r\n * Demos and docs:\r\n * @see https://timellenberger.com/libraries/react-spring-lightbox\r\n *\r\n * GitHub repo:\r\n * @see https://github.com/tim-soft/react-spring-lightbox\r\n *\r\n * Built with:\r\n * @see https://github.com/react-spring/react-use-gesture\r\n * @see https://github.com/react-spring/react-spring\r\n * @see https://github.com/styled-components/styled-components\r\n */\r\nconst Lightbox = ({\r\n    isOpen,\r\n    onClose,\r\n    inline = false,\r\n    images = [],\r\n    currentIndex,\r\n    onPrev,\r\n    onNext,\r\n    renderHeader = () => null,\r\n    renderFooter = () => null,\r\n    renderPrevButton = () => null,\r\n    renderNextButton = () => null,\r\n    renderImageOverlay = () => null,\r\n    className = '',\r\n    singleClickToZoom = false,\r\n    style = {},\r\n    pageTransitionConfig = null,\r\n}: ILightboxProps) => {\r\n    // Handle event listeners for keyboard\r\n    useEffect(() => {\r\n        /**\r\n         * Prevent keyboard from controlling background page\r\n         * when lightbox is open\r\n         */\r\n        const preventBackgroundScroll = (e: KeyboardEvent) => {\r\n            const keysToIgnore = [\r\n                'ArrowUp',\r\n                'ArrowDown',\r\n                'End',\r\n                'Home',\r\n                'PageUp',\r\n                'PageDown',\r\n            ];\r\n\r\n            if (isOpen && keysToIgnore.includes(e.key)) e.preventDefault();\r\n        };\r\n\r\n        /**\r\n         * Navigate images with arrow keys, close on Esc key\r\n         */\r\n        const handleKeyboardInput = (e: KeyboardEvent) => {\r\n            if (isOpen) {\r\n                switch (e.key) {\r\n                    case 'ArrowLeft':\r\n                        onPrev();\r\n                        break;\r\n                    case 'ArrowRight':\r\n                        onNext();\r\n                        break;\r\n                    case 'Escape':\r\n                        onClose && onClose();\r\n                        break;\r\n                    default:\r\n                        e.preventDefault();\r\n                        break;\r\n                }\r\n            }\r\n        };\r\n\r\n        document.addEventListener('keyup', handleKeyboardInput);\r\n        document.addEventListener('keydown', preventBackgroundScroll);\r\n\r\n        return () => {\r\n            document.removeEventListener('keyup', handleKeyboardInput);\r\n            document.removeEventListener('keydown', preventBackgroundScroll);\r\n        };\r\n    });\r\n\r\n    const imageStage = (\r\n        <ImageStage\r\n            currentIndex={currentIndex}\r\n            images={images}\r\n            inline={inline}\r\n            onClose={onClose}\r\n            onNext={onNext}\r\n            onPrev={onPrev}\r\n            renderImageOverlay={renderImageOverlay}\r\n            renderNextButton={renderNextButton}\r\n            renderPrevButton={renderPrevButton}\r\n            singleClickToZoom={singleClickToZoom}\r\n        />\r\n    );\r\n\r\n    if (inline) {\r\n        return imageStage;\r\n    }\r\n\r\n    return (\r\n        <CreatePortal>\r\n            <PageContainer\r\n                className={className}\r\n                isOpen={isOpen}\r\n                pageTransitionConfig={pageTransitionConfig}\r\n                style={style}\r\n            >\r\n                {renderHeader()}\r\n                {imageStage}\r\n                {renderFooter()}\r\n            </PageContainer>\r\n        </CreatePortal>\r\n    );\r\n};\r\n\r\nexport default Lightbox;\r\n"],"names":["getTranslateOffsetsFromScale","_ref","_imageRef$current","imageRef","scale","pinchDelta","touchOrigin","touchOriginX","touchOriginY","currentTranslate","translateX","translateY","current","height","imageHeight","left","imageTopLeftX","top","imageTopLeftY","width","imageWidth","getBoundingClientRect","imageIsOutOfBounds","bottom","bottomRightY","topLeftX","right","bottomRightX","topLeftY","innerHeight","windowHeight","innerWidth","windowWidth","window","defaultImageTransform","pinching","Image","imgProps","style","imgStyleProp","inline","isCurrentImage","pagerHeight","pagerIsDragging","setDisableDrag","singleClickToZoom","restImgProps","_excluded","isPanningImage","setIsPanningImage","useState","useRef","springApi","useSpring","onChange","result","instance","value","start","onRest","useEffect","get","useGesture","onDrag","_ref2","movement","xMovement","yMovement","cancel","first","memo","initialTranslateX","initialTranslateY","touches","tap","onDragEnd","_ref3","undefined","setTimeout","onPinch","_ref4","origin","event","ctrlKey","last","SCALE_FACTOR","pinchScale","clientX","clientY","newTranslateX","newTranslateY","onPinchEnd","domTarget","drag","filterTaps","enabled","eventOptions","passive","ref","latency","onSingleClick","onDoubleClick","clickRef","timer","clickCount","handleClick","e","addEventListener","removeEventListener","clearTimeout","useDoubleClick","stopPropagation","React","AnimatedImage","_extends","$inline","className","draggable","onClick","nativeEvent","stopImmediatePropagation","onDragStart","preventDefault","maxHeight","transform","to","s","x","y","concat","willChange","displayName","styled","animated","img","_templateObject","_taggedTemplateLiteral","_ref5","ImagePager","currentIndex","images","imageStageHeight","imageStageWidth","onClose","onNext","onPrev","renderImageOverlay","firstRender","disableDrag","setPagerHeight","isDragging","setIsDragging","currPagerHeight","getPagePositions","useCallback","i","down","xDelta","display","pagerSprings","springsApi","useSprings","length","bind","direction","xDir","velocity","distance","active","isHorizontalDrag","Math","abs","goToIndex","onWheel","yDir","onWheelEnd","wheel","createElement","ImagePagerContainer","map","AnimatedImagePager","key","role","xInterp","PagerContentWrapper","PagerInnerContentWrapper","ImageContainer","div","_templateObject2","_templateObject3","_templateObject4","_templateObject5","_ref6","ImageStage","renderNextButton","renderPrevButton","canPrev","canNext","onNextImage","onPrevImage","containerHeight","containerWidth","containerRef","_ref$current","_ref$current2","node","setNode","refSize","setRefSize","clientHeight","clientWidth","elementRef","handleResize","useRefSize","ImageStageContainer","PageContainer","children","isOpen","pageTransitionConfig","defaultTransition","config","_objectSpread","default","friction","mass","tension","enter","opacity","from","leave","transitions","useTransition","Fragment","animatedStyles","item","AnimatedPageContainer","CreatePortal","Component","constructor","super","arguments","_defineProperty","this","componentDidMount","body","document","portalContainer","setAttribute","appendChild","forceUpdate","preventWheel","componentWillUnmount","removeChild","render","props","ReactDOM","createPortal","renderHeader","renderFooter","preventBackgroundScroll","includes","handleKeyboardInput","imageStage"],"mappings":"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"}