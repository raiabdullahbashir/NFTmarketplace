'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

var React = require('react');
var React__default = _interopDefault(React);
var _extends = _interopDefault(require('@babel/runtime/helpers/extends'));
var shared = require('@react-spring/shared');
var _objectWithoutPropertiesLoose = _interopDefault(require('@babel/runtime/helpers/objectWithoutPropertiesLoose'));
var useMemoOne = require('use-memo-one');
var G = require('@react-spring/shared/globals');
var animated = require('@react-spring/animated/index.cjs.js');
var stringInterpolation = require('@react-spring/shared/stringInterpolation');

/** API
 *  useChain(references, timeSteps, timeFrame)
 */

function useChain(refs, timeSteps, timeFrame) {
  if (timeFrame === void 0) {
    timeFrame = 1000;
  }

  React.useEffect(function () {
    if (timeSteps) {
      var prevDelay = 0;
      refs.forEach(function (ref, i) {
        if (!ref.current) return;
        var controllers = ref.current.controllers;

        if (controllers.length) {
          var delay = timeFrame * timeSteps[i]; // Use the previous delay if none exists.

          if (isNaN(delay)) delay = prevDelay;else prevDelay = delay;
          controllers.forEach(function (ctrl) {
            ctrl.queue.forEach(function (props) {
              return props.delay += delay;
            });
            ctrl.start();
          });
        }
      });
    } else {
      var p = Promise.resolve();
      refs.forEach(function (ref) {
        var _ref = ref.current || {},
            controllers = _ref.controllers,
            start = _ref.start;

        if (controllers && controllers.length) {
          // Take the queue of each controller
          var updates = controllers.map(function (ctrl) {
            var q = ctrl.queue;
            ctrl.queue = [];
            return q;
          }); // Apply the queue when the previous ref stops animating

          p = p.then(function () {
            controllers.forEach(function (ctrl, i) {
              var _ctrl$queue;

              return (_ctrl$queue = ctrl.queue).push.apply(_ctrl$queue, updates[i]);
            });
            return start();
          });
        } else {
          console.warn('useChain ref has no animations:', ref);
        }
      });
    }
  });
}

function fillArray(length, mapIndex) {
  var arr = [];

  for (var i = 0; i < length; i++) {
    arr.push(mapIndex(i));
  }

  return arr;
}
function withDefault(value, defaultValue) {
  return value == null ? defaultValue : value;
}
function callProp(obj) {
  for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    args[_key - 1] = arguments[_key];
  }

  return shared.is.fun(obj) ? obj.apply(void 0, args) : obj;
}
/**
 * Extract any properties whose keys are *not* reserved for customizing your
 * animations. All hooks use this function, which means `useTransition` props
 * are reserved for `useSpring` calls, etc.
 */

function getForwardProps(props) {
  var children = props.children,
      config = props.config,
      from = props.from,
      to = props.to,
      ref = props.ref,
      reset = props.reset,
      cancel = props.cancel,
      reverse = props.reverse,
      immediate = props.immediate,
      delay = props.delay,
      lazy = props.lazy,
      items = props.items,
      trail = props.trail,
      unique = props.unique,
      initial = props.initial,
      enter = props.enter,
      leave = props.leave,
      update = props.update,
      onAnimate = props.onAnimate,
      onStart = props.onStart,
      onRest = props.onRest,
      onFrame = props.onFrame,
      onDestroyed = props.onDestroyed,
      timestamp = props.timestamp,
      attach = props.attach,
      forward = _objectWithoutPropertiesLoose(props, ["children", "config", "from", "to", "ref", "reset", "cancel", "reverse", "immediate", "delay", "lazy", "items", "trail", "unique", "initial", "enter", "leave", "update", "onAnimate", "onStart", "onRest", "onFrame", "onDestroyed", "timestamp", "attach"]);

  return forward;
}

function interpolateTo(props) {
  var to = getForwardProps(props);
  var out = {
    to: to
  };
  shared.each(props, function (val, key) {
    return key in to || (out[key] = val);
  });
  return out;
}
/**
 * This tries to put deleted items back into the given `out` list in correct
 * order. Deleted items must have a `left` and `right` property with key of
 * their sibling which is used to find the correct placement.
 */

function reconcileDeleted(deleted, current) {
  // Copy as we will be mutating the arrays
  deleted = [].concat(deleted);
  current = [].concat(current); // Used to detect deadlock (when a pass finds 0 siblings)

  var failedTries = 0; // Track where the current pass start/ends

  var passIndex = 0;
  var nextPassIndex = deleted.length; // Insert all deleted items into `current`

  for (var i = 0; i < deleted.length; i++) {
    if (i === nextPassIndex) {
      // Sanity test: Push to end if somehow no siblings were found
      if (passIndex + failedTries === nextPassIndex) {
        for (var j = i; j < deleted.length; j++) {
          var _deleted$j = deleted[j],
              _left = _deleted$j.left,
              _right = _deleted$j.right,
              _deletedItem = _objectWithoutPropertiesLoose(_deleted$j, ["left", "right"]);

          current.push(_deletedItem);
        }

        break;
      } // Update local state at the end of each pass


      passIndex = nextPassIndex;
      nextPassIndex = deleted.length;
      failedTries = 0;
    } // The index of the deleted item in `current`


    var index = -1; // Look for the left or right sibling in `current`

    var _deleted$i = deleted[i],
        left = _deleted$i.left,
        right = _deleted$i.right,
        deletedItem = _objectWithoutPropertiesLoose(_deleted$i, ["left", "right"]);

    for (var _j = current.length; --_j >= 0;) {
      var key = current[_j].originalKey;

      if (key === right) {
        index = _j;
        break;
      }

      if (key === left) {
        index = _j + 1;
        break;
      }
    } // Items with no index are revisited in the next pass


    if (index < 0) {
      failedTries++;
      deleted.push(deleted[i]);
    } else {
      current.splice(index, 0, deletedItem);
    }
  }

  return current;
}
function freeze(obj) {
  if (typeof process !== 'undefined' && process.env.NODE_ENV === 'development') {
    return Object.freeze(obj);
  }

  return obj;
}

var linear = function linear(t) {
  return t;
};

var emptyObj = Object.freeze({});
var nextId = 1;
var Controller =
/*#__PURE__*/
function () {
  function Controller(props) {
    this.id = nextId++;
    this.idle = true;
    this.runCount = 0;
    this.destroyed = false;
    this.props = {};
    this.queue = [];
    this.timestamps = {};
    this.values = {};
    this.merged = {};
    this.animated = {};
    this.animations = {};
    this.configs = [];
    this.children = [];
    this.onEndQueue = [];
    this.cancelledAt = 0;
    if (props) this.update(props).start();
  }
  /**
   * Push props into the update queue. The props are used after `start` is
   * called and any delay is over. The props are intelligently diffed to ensure
   * that later calls to this method properly override any delayed props.
   * The `propsArg` argument is always copied before mutations are made.
   */


  var _proto = Controller.prototype;

  _proto.update = function update(propsArg) {
    if (!propsArg || this.destroyed) return this;
    var props = interpolateTo(propsArg); // For async animations, the `from` prop must be defined for
    // the Animated nodes to exist before animations have started.

    this._ensureAnimated(props.from, true);

    this._ensureAnimated(props.to);

    props.timestamp = G.now(); // The `delay` prop of every update must be a number >= 0

    if (shared.is.fun(props.delay) && shared.is.obj(props.to)) {
      var from = props.from || emptyObj;

      for (var key in props.to) {
        var _to, _ref;

        this.queue.push(_extends({}, props, {
          to: (_to = {}, _to[key] = props.to[key], _to),
          from: key in from ? (_ref = {}, _ref[key] = from[key], _ref) : void 0,
          delay: Math.max(0, Math.round(props.delay(key)))
        }));
      }
    } else {
      props.delay = shared.is.num(props.delay) ? Math.max(0, Math.round(props.delay)) : 0; // Coerce falsy values to undefined for these props

      if (!props.to) props.to = void 0;
      if (!props.from) props.from = void 0;
      this.queue.push(props);
    }

    return this;
  }
  /**
   * Flush the update queue, and call `onEnd` when they have settled.
   *
   * The `onEnd` callback does **not** wait for unsettled updates from previous `start` calls.
   */
  ;

  _proto.start = function start(onEnd) {
    if (this.queue.length) this._flush(onEnd);else if (onEnd) onEnd();
    return this;
  }
  /** Stop one animation or all animations */
  ;

  _proto.stop = function stop() {
    var _this = this;

    for (var _len = arguments.length, keys = new Array(_len), _key = 0; _key < _len; _key++) {
      keys[_key] = arguments[_key];
    }

    // Stop animations by key
    if (keys.length) {
      var _loop = function _loop() {
        var key = _keys[_i];

        var index = _this.configs.findIndex(function (config) {
          return key === config.key;
        });

        _this._stopAnimation(key);

        _this.configs[index] = _this.animations[key];
      };

      for (var _i = 0, _keys = keys; _i < _keys.length; _i++) {
        _loop();
      }
    } // Stop all animations
    else if (this.runCount) {
        this.cancelledAt = G.now(); // Update the animation configs

        shared.each(this.configs, function (config) {
          return _this._stopAnimation(config.key);
        });
        this.configs = Object.values(this.animations); // Exit the frameloop

        if (!this.idle) {
          this._stop();
        }
      }

    return this;
  }
  /** Revert the controller to its initial state */
  ;

  _proto.reset = function reset() {
    // Stop all current animations
    this.stop(); // Revert the internal state

    this.destroyed = false;
    this.props = {};
    this.queue = [];
    this.timestamps = {};
    this.values = {};
    this.merged = {};
    this.animated = {};
    this.animations = {};
    this.configs = [];
    return this;
  }
  /** Prevent all current and future animation */
  ;

  _proto.destroy = function destroy() {
    if (!this.destroyed) {
      this.stop();
      this.destroyed = true;
    }
  }
  /** @internal Called by the frameloop */
  ;

  _proto.onFrame = function onFrame(_ref2) {
    var id = _ref2[0],
        idle = _ref2[1],
        changes = _ref2[2];
    if (id !== this.id) return;

    if (changes && changes.length) {
      for (var _iterator = changes, _isArray = Array.isArray(_iterator), _i2 = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {
        var _ref3;

        if (_isArray) {
          if (_i2 >= _iterator.length) break;
          _ref3 = _iterator[_i2++];
        } else {
          _i2 = _iterator.next();
          if (_i2.done) break;
          _ref3 = _i2.value;
        }

        var _ref4 = _ref3,
            key = _ref4[0],
            value = _ref4[1];
        this.values[key] = value;
      } // The `onFrame` prop always exists when `changes` exists.


      this.props.onFrame(_extends({}, this.values));
    }

    if (idle) {
      this._stop();
    }
  }
  /**
   * Set a prop for the next animations where the prop is undefined. The given
   * value is overridden by the next update where the prop is defined.
   *
   * Ongoing animations are not changed.
   */
  ;

  _proto.setProp = function setProp(key, value) {
    this.props[key] = value;
    this.timestamps[key] = G.now();
    return this;
  }
  /** @internal Get the `AnimatedValue` nodes for the given key */
  ;

  _proto.getPayload = function getPayload(key) {
    var anim = this.animations[key];
    return anim && anim.animatedValues;
  } // Create an Animated node if none exists.
  ;

  _proto._ensureAnimated = function _ensureAnimated(values, shouldUpdate) {
    if (shouldUpdate === void 0) {
      shouldUpdate = false;
    }

    if (!shared.is.obj(values)) return;

    for (var key in values) {
      var value = values[key];
      var animated = this.animated[key];

      if (animated && shouldUpdate && this.animations[key].isNew) {
        // Ensure the initial value is up-to-date.
        if (animated.setValue) {
          animated.setValue(computeGoalValue(value));
        } else {
          // Derived nodes need to be swapped out.
          animated = null;
        }
      }

      if (!animated) {
        animated = createAnimated(value);

        if (this.animated[key]) {
          // Swap out the old node with the new node.
          moveChildren(this.animated[key], animated);
        }

        this.animated[key] = animated;

        this._stopAnimation(key, true);
      }
    }
  } // Add this controller to the frameloop.
  ;

  _proto._start = function _start(onEnd) {
    if (this.idle) {
      if (this.configs.some(function (config) {
        return !config.idle;
      })) {
        this.idle = false;
        G.frameLoop.start(this);
      } else if (onEnd) {
        return onEnd();
      }
    }

    if (onEnd) {
      this.onEndQueue.push(onEnd);
    }
  } // Attach our children to the given keys if possible.
  ;

  _proto._attach = function _attach(keys, visited) {
    var _this2 = this;

    if (visited === void 0) {
      visited = {};
    }

    shared.each(this.children, function (c) {
      if (visited[_this2.id]) return;
      visited[_this2.id] = true;
      var attached = keys.filter(function (key) {
        var payload = c.getPayload(key);

        if (payload) {
          shared.each(payload, function (node) {
            return node.done && node.reset(true);
          });
          return true;
        }
      });

      if (attached.length) {
        c._attach(attached, visited);

        c._start();
      }
    });
  } // Remove this controller from the frameloop, and notify any listeners.
  ;

  _proto._stop = function _stop() {
    this.idle = true;
    G.frameLoop.stop(this);
    var onRest = this.props.onRest;

    if (shared.is.fun(onRest)) {
      onRest(this.merged);
    }

    var onEndQueue = this.onEndQueue;

    if (onEndQueue.length) {
      this.onEndQueue = [];
      shared.each(onEndQueue, function (onEnd) {
        return onEnd();
      });
    }
  } // Execute the current queue of prop updates.
  ;

  _proto._flush = function _flush(onEnd) {
    var _this3 = this;

    var queue = this.queue.reduce(reduceDelays, []);
    this.queue.length = 0; // Track the number of unsettled updates.

    var runsLeft = Object.keys(queue).length;
    this.runCount += runsLeft; // Any run can finish last.

    var onRunEnd = function onRunEnd() {
      _this3.runCount--;

      if (! --runsLeft && onEnd) {
        onEnd();
      }
    };

    shared.each(queue, function (props, delay) {
      if (delay) {
        setTimeout(function () {
          // Cancelling methods touch the `cancelledAt` property
          if (props.timestamp < _this3.cancelledAt) return;

          _this3._run(props, onRunEnd);
        }, delay);
      } else {
        _this3._run(props, onRunEnd);
      }
    });
  } // Update the props and animations
  ;

  _proto._run = function _run(props, onEnd) {
    if (shared.is.arr(props.to) || shared.is.fun(props.to)) {
      this._runAsync(props, onEnd);
    } else if (this._diff(props)) {
      this._animate(props)._start(onEnd);
    } else {
      onEnd();
    }
  } // Start an async chain or an async script.
  ;

  _proto._runAsync = function _runAsync(_ref5, onEnd) {
    var _this4 = this;

    var to = _ref5.to,
        props = _objectWithoutPropertiesLoose(_ref5, ["to"]);

    // Merge other props immediately.
    if (this._diff(props)) {
      this._animate(props);
    } // Async scripts can be declaratively cancelled.


    if (props.cancel === true) {
      this.props.asyncTo = void 0;
      return onEnd();
    } // Never run more than one script at a time


    var timestamp = props.timestamp;

    if (!this._diff({
      asyncTo: to,
      timestamp: timestamp
    })) {
      return onEnd();
    }

    var isCancelled = function isCancelled() {
      return (// Cancelling methods touch the `cancelledAt` property
        timestamp < _this4.cancelledAt || // Async scripts are also cancelled when a new chain/script begins
        shared.is.fun(to) && to !== _this4.props.asyncTo
      );
    };

    var last;

    var next = function next(props) {
      if (isCancelled()) throw _this4;
      return (last = new Promise(function (done) {
        _this4.update(props).start(done);
      })).then(function () {
        if (isCancelled()) throw _this4;
      });
    };

    var queue = Promise.resolve();

    if (shared.is.arr(to)) {
      shared.each(to, function (props) {
        queue = queue.then(function () {
          return next(props);
        });
      });
    } else if (shared.is.fun(to)) {
      queue = queue.then(function () {
        return to(next, _this4.stop.bind(_this4)) // Always wait for the last update.
        .then(function () {
          return last;
        });
      });
    }

    queue.catch(function (err) {
      return err !== _this4 && console.error(err);
    }).then(onEnd);
  } // Merge every fresh prop. Returns true if one or more props changed.
  // These props cannot trigger an update by themselves:
  //   [delay, config, immediate, reverse, attach]
  ;

  _proto._diff = function _diff(_ref6) {
    var _this5 = this;

    var timestamp = _ref6.timestamp,
        delay = _ref6.delay,
        config = _ref6.config,
        immediate = _ref6.immediate,
        reverse = _ref6.reverse,
        attach = _ref6.attach,
        props = _objectWithoutPropertiesLoose(_ref6, ["timestamp", "delay", "config", "immediate", "reverse", "attach"]);

    var changed = false; // Generalized diffing algorithm

    var diffProp = function diffProp(keys, value, owner) {
      if (shared.is.und(value)) return;
      var lastKey = keys[keys.length - 1];

      if (shared.is.obj(value)) {
        if (!shared.is.obj(owner[lastKey])) owner[lastKey] = {};

        for (var key in value) {
          diffProp(keys.concat(key), value[key], owner[lastKey]);
        }
      } else {
        var keyPath = keys.join('.');
        var oldTimestamp = _this5.timestamps[keyPath];

        if (shared.is.und(oldTimestamp) || timestamp >= oldTimestamp) {
          _this5.timestamps[keyPath] = timestamp;
          var oldValue = owner[lastKey];

          if (!isEqual(value, oldValue)) {
            changed = true;
            owner[lastKey] = value;
          }
        }
      }
    };

    if (reverse) {
      var to = props.to;
      props.to = props.from;
      props.from = shared.is.obj(to) ? to : void 0;
    } // The "attach" prop is called on every diff. It overwrites the "parent" prop.


    props.parent = (attach ? attach(this) : props.parent) || null;
    var oldParent = this.props.parent || null;

    if (props.parent !== oldParent) {
      if (oldParent) oldParent.children.splice(oldParent.children.indexOf(this), 1);
      if (props.parent) props.parent.children.push(this);
    }

    for (var key in props) {
      diffProp([key], props[key], this.props);
    } // These props only affect one update


    if ('reset' in props) this.props.reset = false;
    if ('cancel' in props) this.props.cancel = void 0;
    return changed;
  } // Return true if the given prop was changed by this update
  ;

  _proto._isModified = function _isModified(props, prop) {
    return this.timestamps[prop] === props.timestamp;
  } // Update the animation configs. The given props override any default props.
  ;

  _proto._animate = function _animate(props) {
    var _this6 = this;

    var _this$props = this.props,
        _this$props$from = _this$props.from,
        from = _this$props$from === void 0 ? emptyObj : _this$props$from,
        _this$props$to = _this$props.to,
        to = _this$props$to === void 0 ? emptyObj : _this$props$to,
        parent = _this$props.parent,
        onAnimate = _this$props.onAnimate,
        onStart = _this$props.onStart;

    if (shared.is.fun(onAnimate)) {
      onAnimate(props, this);
    }

    var isPrevented = function isPrevented(_) {
      return false;
    };

    if (props.cancel && this._isModified(props, 'cancel')) {
      // Stop all animations when `cancel` is true
      if (props.cancel === true) {
        this.stop(); // Prevent pending updates from *before* this update only!
        // (This must come after the `stop` call above)

        this.cancelledAt = props.timestamp;
        return this;
      } // Prevent matching properties from animating when
      // `cancel` is a string or array of strings


      var keys = shared.toArray(props.cancel);

      if (shared.is.arr(keys) && keys.length) {
        isPrevented = function isPrevented(key) {
          return keys.indexOf(key) >= 0;
        };

        this.stop.apply(this, keys);
      }
    } // Merge `from` values with `to` values


    this.merged = freeze(_extends({}, from, to)); // True if any animation was updated

    var changed = false; // The animations that are starting or restarting

    var started = []; // Attach when a new "parent" controller exists.

    var isAttaching = parent && this._isModified(props, 'parent'); // Reduces input { key: value } pairs into animation objects


    for (var key in this.merged) {
      if (isPrevented(key)) continue;
      var state = this.animations[key];

      if (!state) {
        console.warn("Failed to animate key: \"" + key + "\"\n" + ("Did you forget to define \"from." + key + "\" for an async animation?"));
        continue;
      } // Reuse the Animated nodes whenever possible


      var animated$1 = state.animated,
          animatedValues = state.animatedValues;
      var value = this.merged[key];
      var goalValue = computeGoalValue(value);
      var currValue = animated$1.getValue(); // Stop animations with a goal value equal to its current value.

      if (!props.reset && !isAttaching && isEqual(goalValue, currValue)) {
        // The animation might be stopped already.
        if (!state.idle) {
          changed = true;

          this._stopAnimation(key);
        }

        continue;
      } // Replace an animation when its goal value is changed (or it's been reset)


      if (props.reset || isAttaching || !isEqual(goalValue, state.isNew ? currValue : state.goalValue)) {
        var _ret = function () {
          var immediate = !!callProp((shared.is.und(props.immediate) ? _this6.props : props).immediate, key);
          var isActive = animatedValues.some(function (node) {
            return !node.done;
          });
          var fromValue = !shared.is.und(from[key]) ? computeGoalValue(from[key]) : goalValue; // Animatable strings use interpolation

          var isInterpolated = isAnimatableString(value);

          if (isInterpolated) {
            var output = [props.reset ? fromValue : currValue, goalValue];
            var input = animatedValues[0];

            if (input) {
              input.setValue(0, false);
              input.reset(isActive);
            } else {
              input = new animated.AnimatedValue(0);
            }

            try {
              var prev = animated$1;
              animated$1 = input.to({
                output: output
              });
              moveChildren(prev, animated$1);
            } catch (err) {
              console.warn('Failed to interpolate string from "%s" to "%s"', output[0], output[1]);
              console.error(err);
              return "continue";
            }

            if (G.skipAnimation) {
              input.setValue(1);

              _this6._stopAnimation(key);

              return "continue";
            }

            if (immediate) {
              input.setValue(1, false);
            }
          } else {
            // Convert values into Animated nodes (reusing nodes whenever possible)
            if (shared.is.arr(value)) {
              if (animated$1 instanceof animated.AnimatedArray) {
                if (props.reset) animated$1.setValue(fromValue, false);
                shared.each(animatedValues, function (node) {
                  return node.reset(isActive);
                });
              } else {
                var _prev = animated$1;
                animated$1 = createAnimated(fromValue);
                moveChildren(_prev, animated$1);
              }
            } else {
              if (animated$1 instanceof animated.AnimatedValue) {
                if (props.reset) animated$1.setValue(fromValue, false);
                animated$1.reset(isActive);
              } else {
                var _prev2 = animated$1;
                animated$1 = new animated.AnimatedValue(fromValue);
                moveChildren(_prev2, animated$1);
              }
            }

            if (G.skipAnimation) {
              animated$1.setValue(goalValue);

              _this6._stopAnimation(key);

              return "continue";
            }

            if (immediate) {
              animated$1.setValue(goalValue, false);
            }
          } // Only change the "config" of updated animations.


          var config = callProp(props.config, key) || callProp(_this6.props.config, key) || emptyObj;

          if (!(immediate || G.skipAnimation)) {
            started.push(key);
          }

          var fromValues = animatedValues.map(function (v) {
            return v.getValue();
          });
          var toValues = parent && parent.getPayload(key) || shared.toArray(isInterpolated ? 1 : goalValue);
          changed = true;
          _this6.animations[key] = {
            key: key,
            idle: false,
            goalValue: goalValue,
            toValues: toValues,
            fromValues: fromValues,
            animated: animated$1,
            animatedValues: Array.from(animated$1.getPayload()),
            immediate: immediate,
            duration: config.duration,
            easing: withDefault(config.easing, linear),
            decay: config.decay,
            mass: withDefault(config.mass, 1),
            tension: withDefault(config.tension, 170),
            friction: withDefault(config.friction, 26),
            initialVelocity: withDefault(config.velocity, 0),
            clamp: withDefault(config.clamp, false),
            precision: withDefault(config.precision, 0.005),
            config: config
          };
        }();

        if (_ret === "continue") continue;
      }
    }

    if (changed) {
      if (started.length) {
        this._attach(started);

        if (shared.is.fun(onStart)) shared.each(started, function (key) {
          onStart(_this6.animations[key]);
        });
      } // Make animations available to the frameloop


      var _keys2 = Object.keys(this.animations);

      this.configs.length = _keys2.length;
      shared.each(_keys2, function (key, i) {
        var config = _this6.animations[key];
        _this6.configs[i] = config;
        _this6.values[key] = config.animated.getValue();
        _this6.animated[key] = config.animated;
      });
    }

    return this;
  }
  /**
   * Stop an animation by its key.
   *
   * This mutates the `timestamps.to[key]`, `props.to[key]`, and `animations[key]` properties.
   * Notably, it does *not* mutate the `configs[key]` or `animated[key]` properties.
   */
  ;

  _proto._stopAnimation = function _stopAnimation(key, isNew) {
    var animated = this.animated[key];

    if (!animated) {
      return console.warn("Cannot stop an animation for a key that isn't animated: \"" + key + "\"");
    } // Prevent any pending updates to this key


    this.timestamps['to.' + key] = G.now(); // Idle animations are skipped unless their Animated node changed

    var state = this.animations[key] || emptyObj;
    if (state.idle && animated === state.animated) return; // Use the previous `isNew` value if nothing was passed

    if (shared.is.und(isNew)) {
      isNew = !!state.isNew;
    } // Tell the frameloop to skip animating these values


    var animatedValues = Array.from(animated.getPayload());
    shared.each(animatedValues, function (node) {
      node.done = true;
    }); // The current value becomes the goal value,
    // which ensures the integrity of the diffing algorithm.

    var goalValue = animated.getValue();

    if (this.props.to) {
      this.props.to[key] = goalValue;
    } // Remove unused data from this key's animation config


    this.animations[key] = {
      key: key,
      idle: true,
      isNew: isNew,
      goalValue: goalValue,
      animated: animated,
      animatedValues: animatedValues
    };
  };

  return Controller;
}();
/** Wrap any value with an `Animated` node */

function createAnimated(value) {
  return shared.is.arr(value) ? new animated.AnimatedArray(value.map(createAnimated)) : isAnimatableString(value) ? // Convert "red" into "rgba(255, 0, 0, 1)" etc
  new animated.AnimatedValue(0).to({
    output: [value, value]
  }) : // The `AnimatedValue` class supports any type, but only numbers are
  // interpolated by the frameloop.
  new animated.AnimatedValue(value);
}
/**
 * Replace an `Animated` node in the graph.
 * This is most useful for async updates, which don't cause a re-render.
 */


function moveChildren(prev, next) {
  shared.each(Array.from(prev.getChildren()), function (child) {
    child.updatePayload(prev, next);
    prev.removeChild(child);
    next.addChild(child);
  });
} // Merge updates with the same delay.
// NOTE: Mutation of `props` may occur!


function reduceDelays(merged, props) {
  var prev = merged[props.delay];

  if (prev) {
    props.to = merge(prev.to, props.to);
    props.from = merge(prev.from, props.from);
    Object.assign(prev, props);
  } else {
    merged[props.delay] = props;
  }

  return merged;
}

function merge(dest, src) {
  return shared.is.obj(dest) && shared.is.obj(src) ? _extends({}, dest, src) : src || dest;
} // Not all strings can be animated (eg: {display: "none"})


function isAnimatableString(value) {
  if (!shared.is.str(value)) return false;
  return value.startsWith('#') || /\d/.test(value) || !!(G.colorNames && G.colorNames[value]);
} // Compute the goal value, converting "red" to "rgba(255, 0, 0, 1)" in the process


function computeGoalValue(value) {
  return shared.is.arr(value) ? value.map(computeGoalValue) : isAnimatableString(value) ? G.createStringInterpolator({
    range: [0, 1],
    output: [value, value]
  })(1) : value;
} // Compare animatable values


function isEqual(a, b) {
  if (shared.is.arr(a)) {
    if (!shared.is.arr(b) || a.length !== b.length) return false;

    for (var i = 0; i < a.length; i++) {
      if (a[i] !== b[i]) return false;
    }

    return true;
  }

  return a === b;
}

/** API
 * const props = useSprings(number, [{ ... }, { ... }, ...])
 * const [props, set] = useSprings(number, (i, controller) => ({ ... }))
 */

var useSprings = function useSprings(length, propsArg, deps) {
  var hasNewSprings = length !== shared.usePrev(length);
  var isFn = shared.is.fun(propsArg);
  var state = React.useRef({
    springs: [],
    ref: null
  }).current; // The `propsArg` coerced into an array

  var props = isFn ? [] : propsArg; // Recreate the controllers whenever `length` changes

  var springs = useMemoOne.useMemoOne(function () {
    return fillArray(length, function (i) {
      var s = new Controller();
      var p = props[i] || (props[i] = callProp(propsArg, i, s));
      return s.update(p);
    });
  }, [length]);

  var _useMemo = React.useMemo(function () {
    return {
      /** Apply any pending updates */
      start: function start() {
        return Promise.all(state.springs.map(function (s) {
          return new Promise(function (done) {
            return s.start(done);
          });
        }));
      },

      /** Update the spring controllers */
      update: function update(props) {
        var isFn = shared.is.fun(props);
        var isArr = shared.is.arr(props);
        state.springs.forEach(function (spring, i) {
          spring.update(isFn ? callProp(props, i, spring) : isArr ? props[i] : props);
          if (!state.ref) spring.start();
        });
      },

      /** Stop one key or all keys from animating */
      stop: function stop() {
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }

        return state.springs.forEach(function (s) {
          return s.stop.apply(s, args);
        });
      }
    };
  }, []),
      start = _useMemo.start,
      update = _useMemo.update,
      stop = _useMemo.stop;

  var ref = props[0] ? props[0].ref : isFn ? state.ref : null;
  React.useImperativeHandle(ref, function () {
    return {
      start: start,
      stop: stop,

      get controllers() {
        return state.springs;
      }

    };
  }); // Once mounted, update the local state and start any animations.

  React.useEffect(function () {
    if (!isFn || hasNewSprings) {
      props.forEach(function (p, i) {
        // Set default props for async updates
        springs[i].setProp('config', p.config);
        springs[i].setProp('immediate', p.immediate);
      });
    }

    if (hasNewSprings) {
      state.springs.forEach(function (s) {
        return s.destroy();
      });
      state.springs = springs;
      state.ref = ref;

      if (!ref) {
        springs.forEach(function (s) {
          return s.start();
        });
      }
    } else if (!isFn) {
      update(props);
    }
  }, deps); // Destroy the controllers on unmount

  shared.useOnce(function () {
    return function () {
      state.springs.forEach(function (s) {
        return s.destroy();
      });
    };
  });
  var values = springs.map(function (s) {
    return _extends({}, s.animated);
  });
  return isFn ? [values, update, stop] : values;
};

/** API
 * const props = useSpring({ ... })
 * const [props, set] = useSpring(() => ({ ... }))
 */

var useSpring = function useSpring(props, deps) {
  var isFn = shared.is.fun(props);

  var _useSprings = useSprings(1, isFn ? props : [props], deps),
      result = _useSprings[0],
      set = _useSprings[1],
      stop = _useSprings[2];

  return isFn ? [result[0], set, stop] : result;
};

/** API
 * const trails = useTrail(number, { ... })
 * const [trails, set] = useTrail(number, () => ({ ... }))
 */

var useTrail = function useTrail(length, propsArg) {
  var hasNewSprings = length !== shared.usePrev(length);
  var isFn = shared.is.fun(propsArg); // The `propsArg` coerced into an object

  var props = isFn ? null : propsArg; // Retain the controllers so we can update them.

  var springsRef = React.useRef([]);
  var springs = springsRef.current;
  if (hasNewSprings) springs.length = length; // The controllers are recreated whenever `length` changes.

  var _useSprings = useSprings(length, function (i, spring) {
    if (isFn && !props) {
      props = callProp(propsArg, spring) || {};
    }

    springs[i] = spring;
    return _extends({}, props, i > 0 && {
      attach: function attach() {
        return springs[i - 1];
      },
      onStart: withArgument(props.onStart, i),
      onFrame: withArgument(props.onFrame, i),
      onRest: withArgument(props.onRest, i)
    }, {
      config: callProp(props.config, i)
    });
  }),
      values = _useSprings[0],
      animate = _useSprings[1],
      stop = _useSprings[2];
  /** For imperative updates to the props of all springs in the trail */


  var update = useMemoOne.useCallbackOne(function (propsArg) {
    return animate(function (i, spring) {
      var props = callProp(propsArg, i, spring) || {};
      var parent = springsRef.current[props.reverse ? i + 1 : i - 1];
      return _extends({}, props, {
        attach: function attach() {
          return parent;
        },
        config: callProp(props.config, i)
      });
    });
  }, []); // Update the animations on re-render when `propsArg` is an object
  // and the controllers were *not* created in the current render.

  React.useEffect(function () {
    if (!isFn && !hasNewSprings) {
      update(propsArg);
    }
  }); // Return the update/stop functions when the `propsArg` is a function.

  return isFn ? [values, update, stop] : values;
};

function withArgument(fn, arg) {
  return shared.is.fun(fn) ? function () {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return fn.apply(void 0, args.concat([arg]));
  } : fn;
}

/** API
 * const transitions = useTransition(items, itemKeys, { ... })
 * const [transitions, update] = useTransition(items, itemKeys, () => ({ ... }))
 */

var guid = 0;
var INITIAL = 'initial';
var ENTER = 'enter';
var UPDATE = 'update';
var LEAVE = 'leave';

var makeKeys = function makeKeys(items, keys) {
  return (typeof keys === 'function' ? items.map(keys) : shared.toArray(keys)).map(String);
};

var makeConfig = function makeConfig(props) {
  var items = props.items,
      keys = props.keys,
      rest = _objectWithoutPropertiesLoose(props, ["items", "keys"]);

  items = shared.toArray(shared.is.und(items) ? null : items);
  return _extends({
    items: items,
    keys: makeKeys(items, keys)
  }, rest);
};

function useTransition(input, keyTransform, props) {
  props = makeConfig(_extends({}, props, {
    items: input,
    keys: keyTransform || function (i) {
      return i;
    }
  }));

  var _props = props,
      _props$lazy = _props.lazy,
      lazy = _props$lazy === void 0 ? false : _props$lazy,
      _props$unique = _props.unique,
      from = _props.from,
      enter = _props.enter,
      leave = _props.leave,
      update = _props.update,
      onDestroyed = _props.onDestroyed,
      keys = _props.keys,
      items = _props.items,
      onFrame = _props.onFrame,
      _onRest = _props.onRest,
      onStart = _props.onStart,
      ref = _props.ref,
      extra = _objectWithoutPropertiesLoose(_props, ["lazy", "unique", "from", "enter", "leave", "update", "onDestroyed", "keys", "items", "onFrame", "onRest", "onStart", "ref"]);

  var forceUpdate = shared.useForceUpdate();
  var mounted = React.useRef(false);
  var state = React.useRef({
    mounted: false,
    first: true,
    deleted: [],
    current: {},
    transitions: [],
    prevProps: {},
    paused: !!ref,
    instances: !mounted.current && new Map(),
    forceUpdate: forceUpdate
  });
  React.useImperativeHandle(ref, function () {
    return {
      start: function start() {
        return Promise.all(Array.from(state.current.instances).map(function (_ref) {
          var c = _ref[1];
          return new Promise(function (r) {
            return c.start(r);
          });
        }));
      },
      stop: function stop(finished) {
        return Array.from(state.current.instances).forEach(function (_ref2) {
          var c = _ref2[1];
          return c.stop(finished);
        });
      },

      get controllers() {
        return Array.from(state.current.instances).map(function (_ref3) {
          var c = _ref3[1];
          return c;
        });
      }

    };
  }); // Update state

  state.current = diffItems(state.current, props);

  if (state.current.changed) {
    // Update state
    state.current.transitions.forEach(function (transition) {
      var phase = transition.phase,
          key = transition.key,
          item = transition.item,
          props = transition.props;
      if (!state.current.instances.has(key)) state.current.instances.set(key, new Controller()); // Avoid calling `onStart` more than once per transition.

      var started = false; // update the map object

      var ctrl = state.current.instances.get(key);

      var itemProps = _extends({}, extra, props, {
        onRest: function onRest(values) {
          if (state.current.mounted) {
            if (transition.destroyed) {
              // If no ref is given delete destroyed items immediately
              if (!ref && !lazy) cleanUp(state, key);
              if (onDestroyed) onDestroyed(item);
            } // A transition comes to rest once all its springs conclude


            var curInstances = Array.from(state.current.instances);
            var active = curInstances.some(function (_ref4) {
              var c = _ref4[1];
              return !c.idle;
            });

            if (!active && (ref || lazy) && state.current.deleted.length > 0) {
              cleanUp(state);
            }

            if (shared.is.fun(_onRest)) {
              _onRest(item, phase, values);
            }
          }
        },
        onFrame: shared.is.fun(onFrame) && function (values) {
          return onFrame(item, phase, values);
        },
        onStart: shared.is.fun(onStart) && function (animation) {
          return started || (started = (onStart(item, phase, animation), true));
        } // Update controller

      });

      ctrl.update(itemProps);
      if (!state.current.paused) ctrl.start();
    });
  }

  shared.useOnce(function () {
    state.current.mounted = mounted.current = true;
    return function () {
      state.current.mounted = mounted.current = false;
      Array.from(state.current.instances).map(function (_ref5) {
        var c = _ref5[1];
        return c.destroy();
      });
      state.current.instances.clear();
    };
  });
  return state.current.transitions.map(function (_ref6) {
    var item = _ref6.item,
        phase = _ref6.phase,
        key = _ref6.key;
    return {
      item: item,
      key: key,
      phase: phase,
      props: _extends({}, state.current.instances.get(key).animated)
    };
  });
}

function cleanUp(_ref7, filterKey) {
  var state = _ref7.current;
  var deleted = state.deleted;

  var _loop = function _loop() {
    if (_isArray) {
      if (_i >= _iterator.length) return "break";
      _ref9 = _iterator[_i++];
    } else {
      _i = _iterator.next();
      if (_i.done) return "break";
      _ref9 = _i.value;
    }

    var _ref8 = _ref9;
    var key = _ref8.key;

    var filter = function filter(t) {
      return t.key !== key;
    };

    if (shared.is.und(filterKey) || filterKey === key) {
      state.instances.delete(key);
      state.transitions = state.transitions.filter(filter);
      state.deleted = state.deleted.filter(filter);
    }
  };

  for (var _iterator = deleted, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {
    var _ref9;

    var _ret = _loop();

    if (_ret === "break") break;
  }

  state.forceUpdate();
}

function diffItems(_ref10, props) {
  var first = _ref10.first,
      current = _ref10.current,
      deleted = _ref10.deleted,
      prevProps = _ref10.prevProps,
      state = _objectWithoutPropertiesLoose(_ref10, ["first", "current", "deleted", "prevProps"]);

  var items = props.items,
      keys = props.keys,
      initial = props.initial,
      from = props.from,
      enter = props.enter,
      leave = props.leave,
      update = props.update,
      _props$trail = props.trail,
      trail = _props$trail === void 0 ? 0 : _props$trail,
      unique = props.unique,
      config = props.config,
      _props$order = props.order,
      order = _props$order === void 0 ? [ENTER, LEAVE, UPDATE] : _props$order;

  var _makeConfig = makeConfig(prevProps),
      _keys = _makeConfig.keys,
      _items = _makeConfig.items;

  if (props.reset) {
    current = {};
    state.transitions = [];
  } // Compare next keys with current keys


  var currentKeys = Object.keys(current);
  var currentSet = new Set(currentKeys);
  var nextSet = new Set(keys);
  var addedKeys = keys.filter(function (key) {
    return !currentSet.has(key);
  });
  var updatedKeys = update ? keys.filter(function (key) {
    return currentSet.has(key);
  }) : [];
  var deletedKeys = state.transitions.filter(function (t) {
    return !t.destroyed && !nextSet.has(t.originalKey);
  }).map(function (t) {
    return t.originalKey;
  });
  var delay = -trail;

  var _loop2 = function _loop2() {
    var phase = order.shift();

    if (phase === ENTER) {
      if (first && !shared.is.und(initial)) {
        phase = INITIAL;
        from = initial;
      }

      addedKeys.forEach(function (key) {
        // In unique mode, remove fading out transitions if their key comes in again
        if (unique && deleted.find(function (d) {
          return d.originalKey === key;
        })) {
          deleted = deleted.filter(function (t) {
            return t.originalKey !== key;
          });
        }

        var i = keys.indexOf(key);
        var item = items[i];
        var enterProps = callProp(enter, item, i);
        current[key] = {
          phase: phase,
          originalKey: key,
          key: unique ? String(key) : guid++,
          item: item,
          props: _extends({
            delay: delay += trail,
            config: callProp(config, item, phase),
            from: callProp(from, item, i),
            to: enterProps
          }, shared.is.obj(enterProps) && interpolateTo(enterProps))
        };
      });
    } else if (phase === LEAVE) {
      deletedKeys.forEach(function (key) {
        var i = _keys.indexOf(key);

        var item = _items[i];
        var leaveProps = callProp(leave, item, i);
        deleted.push(_extends({}, current[key], {
          phase: phase,
          destroyed: true,
          left: _keys[i - 1],
          right: _keys[i + 1],
          props: _extends({
            delay: delay += trail,
            config: callProp(config, item, phase),
            to: leaveProps
          }, shared.is.obj(leaveProps) && interpolateTo(leaveProps))
        }));
        delete current[key];
      });
    } else if (phase === UPDATE) {
      updatedKeys.forEach(function (key) {
        var i = keys.indexOf(key);
        var item = items[i];
        var updateProps = callProp(update, item, i);
        current[key] = _extends({}, current[key], {
          phase: phase,
          props: _extends({
            delay: delay += trail,
            config: callProp(config, item, phase),
            to: updateProps
          }, shared.is.obj(updateProps) && interpolateTo(updateProps))
        });
      });
    }
  };

  while (order.length) {
    _loop2();
  }

  var out = keys.map(function (key) {
    return current[key];
  });
  out = reconcileDeleted(deleted, out);
  return _extends({}, state, {
    first: first && !addedKeys.length,
    changed: !!(addedKeys.length || deletedKeys.length || updatedKeys.length),
    transitions: out,
    current: current,
    deleted: deleted,
    prevProps: props
  });
}

function Spring(_ref) {
  var children = _ref.children,
      props = _objectWithoutPropertiesLoose(_ref, ["children"]);

  return children(useSpring(props));
}
function Trail(_ref2) {
  var items = _ref2.items,
      children = _ref2.children,
      props = _objectWithoutPropertiesLoose(_ref2, ["items", "children"]);

  var trails = useTrail(items.length, props);
  return items.map(function (item, index) {
    var result = children(item, index);
    return shared.is.fun(result) ? result(trails[index]) : result;
  });
}
function Transition(_ref3) {
  var items = _ref3.items,
      _ref3$keys = _ref3.keys,
      keys = _ref3$keys === void 0 ? null : _ref3$keys,
      children = _ref3.children,
      props = _objectWithoutPropertiesLoose(_ref3, ["items", "keys", "children"]);

  var transitions = useTransition(items, keys, props);
  return transitions.map(function (_ref4, index) {
    var item = _ref4.item,
        key = _ref4.key,
        props = _ref4.props,
        phase = _ref4.phase;
    var result = children(item, phase, index);
    var element = shared.is.fun(result) ? result(props) : result;
    return element && element.type ? React__default.createElement(element.type, _extends({}, element.props, {
      key: key,
      ref: element.ref
    })) : element;
  });
}

var FrameLoop =
/*#__PURE__*/
function () {
  function FrameLoop(_temp) {
    var _this = this;

    var _ref = _temp === void 0 ? {} : _temp,
        update = _ref.update,
        onFrame = _ref.onFrame,
        requestFrame = _ref.requestFrame;

    /**
     * On each frame, these controllers are searched for values to animate.
     */
    this.controllers = new Map();
    /**
     * True when no controllers are animating.
     */

    this.idle = true;

    this.requestFrame = // The global `requestAnimationFrame` must be dereferenced to avoid "Illegal invocation" errors
    requestFrame || function (fn) {
      return (0, G.requestAnimationFrame)(fn);
    };

    this.onFrame = onFrame && onFrame.bind(this) || function (updates) {
      updates.forEach(function (update) {
        var ctrl = _this.controllers.get(update[0]);

        if (ctrl) ctrl.onFrame(update);
      });
    };

    this.update = update && update.bind(this) || function () {
      if (_this.idle) {
        return false;
      } // Update the animations.


      var updates = [];

      for (var _i = 0, _Array$from = Array.from(_this.controllers.keys()); _i < _Array$from.length; _i++) {
        var id = _Array$from[_i];
        var idle = true;

        var ctrl = _this.controllers.get(id);

        var changes = ctrl.props.onFrame ? [] : null;

        for (var _iterator = ctrl.configs, _isArray = Array.isArray(_iterator), _i2 = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {
          var _ref2;

          if (_isArray) {
            if (_i2 >= _iterator.length) break;
            _ref2 = _iterator[_i2++];
          } else {
            _i2 = _iterator.next();
            if (_i2.done) break;
            _ref2 = _i2.value;
          }

          var config = _ref2;
          if (config.idle) continue;

          if (_this.advance(config, changes)) {
            idle = false;
          }
        }

        updates.push([id, idle, changes]);
      } // Notify the controllers!


      _this.onFrame(updates); // Are we done yet?


      if (!_this.controllers.size) {
        return !(_this.idle = true);
      } // Keep going.


      _this.requestFrame(_this.update);

      return true;
    };
  }

  var _proto = FrameLoop.prototype;

  _proto.start = function start(ctrl) {
    this.controllers.set(ctrl.id, ctrl);

    if (this.idle) {
      this.idle = false;
      this.requestFrame(this.update);
    }
  };

  _proto.stop = function stop(ctrl) {
    this.controllers.delete(ctrl.id);
  }
  /** Advance an animation forward one frame. */
  ;

  _proto.advance = function advance(config, changes) {
    var time = G.now();
    var active = false;
    var changed = false;

    for (var i = 0; i < config.animatedValues.length; i++) {
      var animated$1 = config.animatedValues[i];
      if (animated$1.done) continue;
      changed = true;
      var to = config.toValues[i];
      var target = to instanceof animated.Animated ? to : null;
      if (target) to = target.getValue(); // Jump to end value for immediate animations

      if (config.immediate) {
        animated$1.setValue(to);
        animated$1.done = true;
        continue;
      }

      var from = config.fromValues[i];
      var startTime = animated$1.startTime; // Break animation when string values are involved

      if (typeof from === 'string' || typeof to === 'string') {
        animated$1.setValue(to);
        animated$1.done = true;
        continue;
      }

      var finished = false;
      var position = animated$1.lastPosition;
      var velocity = Array.isArray(config.initialVelocity) ? config.initialVelocity[i] : config.initialVelocity; // Duration easing

      if (config.duration !== void 0) {
        position = from + config.easing((time - startTime) / config.duration) * (to - from);
        finished = time >= startTime + config.duration;
      } // Decay easing
      else if (config.decay) {
          var decay = config.decay === true ? 0.998 : config.decay;
          position = from + velocity / (1 - decay) * (1 - Math.exp(-(1 - decay) * (time - startTime)));
          finished = Math.abs(animated$1.lastPosition - position) < 0.1;
          if (finished) to = position;
        } // Spring easing
        else {
            var lastTime = animated$1.lastTime !== void 0 ? animated$1.lastTime : time;

            if (animated$1.lastVelocity !== void 0) {
              velocity = animated$1.lastVelocity;
            } // If we lost a lot of frames just jump to the end.


            if (time > lastTime + 64) lastTime = time; // http://gafferongames.com/game-physics/fix-your-timestep/

            var numSteps = Math.floor(time - lastTime);

            for (var n = 0; n < numSteps; ++n) {
              var force = -config.tension * (position - to);
              var damping = -config.friction * velocity;
              var acceleration = (force + damping) / config.mass;
              velocity = velocity + acceleration * 1 / 1000;
              position = position + velocity * 1 / 1000;
            }

            animated$1.lastTime = time;
            animated$1.lastVelocity = velocity; // Conditions for stopping the spring animation

            var isOvershooting = config.clamp && config.tension !== 0 ? from < to ? position > to : position < to : false;
            var isVelocity = Math.abs(velocity) <= config.precision;
            var isDisplacement = config.tension !== 0 ? Math.abs(to - position) <= config.precision : true;
            finished = isOvershooting || isVelocity && isDisplacement;
          } // Trails aren't done until their parents conclude


      if (finished && !(target && !target.done)) {
        // Ensure that we end up with a round value
        if (animated$1.value !== to) position = to;
        animated$1.done = true;
      } else {
        active = true;
      }

      animated$1.setValue(position);
      animated$1.lastPosition = position;
    }

    if (changes && changed) {
      changes.push([config.key, config.animated.getValue()]);
    }

    return active;
  };

  return FrameLoop;
}();

shared.Globals.assign({
  frameLoop: new FrameLoop(),
  createStringInterpolator: stringInterpolation.createStringInterpolator,
  applyAnimatedValues: function applyAnimatedValues() {
    return false;
  }
});
/** Advance all animations forward one frame */

var update = function update() {
  return shared.Globals.frameLoop.update();
};

// The `mass` prop defaults to 1
var config = {
  default: {
    tension: 170,
    friction: 26
  },
  gentle: {
    tension: 120,
    friction: 14
  },
  wobbly: {
    tension: 180,
    friction: 12
  },
  stiff: {
    tension: 210,
    friction: 20
  },
  slow: {
    tension: 280,
    friction: 60
  },
  molasses: {
    tension: 280,
    friction: 120
  }
};

Object.defineProperty(exports, 'Globals', {
  enumerable: true,
  get: function () {
    return shared.Globals;
  }
});
Object.defineProperty(exports, 'createInterpolator', {
  enumerable: true,
  get: function () {
    return shared.createInterpolator;
  }
});
Object.defineProperty(exports, 'interpolate', {
  enumerable: true,
  get: function () {
    return animated.interpolate;
  }
});
Object.defineProperty(exports, 'isAnimated', {
  enumerable: true,
  get: function () {
    return animated.isAnimated;
  }
});
Object.defineProperty(exports, 'to', {
  enumerable: true,
  get: function () {
    return animated.to;
  }
});
exports.Controller = Controller;
exports.FrameLoop = FrameLoop;
exports.Spring = Spring;
exports.Trail = Trail;
exports.Transition = Transition;
exports.config = config;
exports.update = update;
exports.useChain = useChain;
exports.useSpring = useSpring;
exports.useSprings = useSprings;
exports.useTrail = useTrail;
exports.useTransition = useTransition;
//# sourceMappingURL=index.cjs.js.map
