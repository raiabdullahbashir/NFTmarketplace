import { RefObject, ReactNode } from 'react';
import { Remap, EasingFunction, SpringValue } from '@react-spring/shared';
export { Globals, createInterpolator } from '@react-spring/shared';
import { AnimatedValue, Animated } from '@react-spring/animated';
export { interpolate, isAnimated, to } from '@react-spring/animated';
import { Indexable, OnEnd, Falsy, Merge, OneOrMore, Remap as Remap$1, Arrify, Solve } from '@react-spring/shared/types/common';
import { FrameRequestCallback } from '@react-spring/shared/types';
export * from '@react-spring/shared/types/animated';
export * from '@react-spring/shared/types/interpolation';

/** Extract string keys from an object type */
declare type StringKeys<T extends object> = Extract<keyof T, string>;
/** Intersected with other object types to allow for unknown properties */
declare type UnknownProps = {
    [key: string]: unknown;
};
/** Infer an object type from an object, array, or function type */
declare type InferObject<T> = T extends ReadonlyArray<infer U> | ((...args: any[]) => infer U) ? (U extends object ? U : {}) : (T extends object ? T : {});
/** Extract a union of animated props from a `useTransition` config */
declare type TransitionValues<T extends object> = TransitionPhase extends infer Phase ? Phase extends keyof T ? NoVoid<InferObject<T[Phase]>> : {} : never;
/** The phases of a `useTransition` item */
declare type TransitionPhase = 'initial' | 'enter' | 'update' | 'leave';
/** String union of the transition phases defined in `T` */
declare type TransitionPhases<T extends object> = {
    [P in TransitionPhase]: P extends keyof T ? P : never;
}[TransitionPhase];
declare type NoVoid<T extends object> = {
    [P in keyof T]-?: T[P] extends void ? never : T[P];
};
/** Pick the properties that will be animated */
declare type PickAnimated<T extends object> = ObjectFromUnion<(T extends {
    from: infer FromProp;
} ? NoVoid<InferObject<FromProp>> : {}) | (TransitionPhases<T> extends never ? ToValues<T> : TransitionValues<T>)>;
/** Extract `to` values from a `useSpring` config */
declare type ToValues<T extends object> = T extends {
    to: infer ToProp;
} ? ToProp extends Function ? {} : ToProp extends ReadonlyArray<infer U> ? (U extends object ? U : {}) : (ToProp extends object ? ToProp : {}) : ForwardProps<T>;
/** Intersect a union of objects but merge property types with _unions_ */
declare type ObjectFromUnion<T extends object> = Remap<{
    [P in keyof Intersect<T>]: T extends infer U ? P extends keyof U ? U[P] : never : never;
}>;
/** Convert a union to an intersection */
declare type Intersect<U> = (U extends any ? (k: U) => void : never) extends ((k: infer I) => void) ? I : never;
/**
 * Extract the custom props that are treated like `to` values
 */
declare type ForwardProps<T extends object> = Remap<Pick<T, Exclude<keyof T, keyof ReservedProps>>>;
/**
 * Property names that are reserved for animation config
 */
interface ReservedProps {
    children?: any;
    config?: any;
    from?: any;
    to?: any;
    ref?: any;
    reset?: any;
    cancel?: any;
    reverse?: any;
    immediate?: any;
    delay?: any;
    lazy?: any;
    items?: any;
    trail?: any;
    unique?: any;
    initial?: any;
    enter?: any;
    leave?: any;
    update?: any;
    onAnimate?: any;
    onStart?: any;
    onRest?: any;
    onFrame?: any;
    onDestroyed?: any;
    timestamp?: any;
    attach?: any;
}

/**
 * A tuple containing:
 *
 *   [0] `controllerID`: The controller being updated
 *
 *   [1] `idle`: True when all animations have finished
 *
 *   [2] `changes`: An array of `[key, value]` tuples
 */
declare type FrameUpdate<State extends object = any> = [number, boolean, [keyof State, State[keyof State]][] | null];
/** Controller props in pending updates */
declare type PendingProps<State extends object> = Merge<AnimationProps<State>, {
    to?: ToProp<State>;
    from?: Partial<State>;
    parent?: Controller | null;
    attach?: (ctrl: Controller) => Controller | null;
    timestamp?: number;
}>;
/** Controller props from previous updates */
declare type CachedProps<State extends object> = Merge<PendingProps<State>, {
    to?: Partial<State>;
    asyncTo?: ReadonlyArray<SpringUpdate<State>> | SpringAsyncFn<State>;
}>;
declare class Controller<State extends Indexable = any> {
    id: number;
    idle: boolean;
    runCount: number;
    destroyed: boolean;
    props: CachedProps<State>;
    queue: any[];
    timestamps: Indexable<number>;
    values: State;
    merged: State;
    animated: AnimatedNodes<State>;
    animations: AnimationMap<State>;
    configs: AnimationList<State>;
    children: Controller[];
    onEndQueue: OnEnd[];
    cancelledAt: number;
    constructor(props?: Partial<State> & PendingProps<State>);
    /**
     * Push props into the update queue. The props are used after `start` is
     * called and any delay is over. The props are intelligently diffed to ensure
     * that later calls to this method properly override any delayed props.
     * The `propsArg` argument is always copied before mutations are made.
     */
    update(propsArg: (Partial<State> & PendingProps<State>) | Falsy): this;
    /**
     * Flush the update queue, and call `onEnd` when they have settled.
     *
     * The `onEnd` callback does **not** wait for unsettled updates from previous `start` calls.
     */
    start(onEnd?: OnEnd): this;
    /** Stop one animation or all animations */
    stop(...keys: StringKeys<State>[]): this;
    /** Revert the controller to its initial state */
    reset(): this;
    /** Prevent all current and future animation */
    destroy(): void;
    /** @internal Called by the frameloop */
    onFrame([id, idle, changes]: FrameUpdate<State>): void;
    /**
     * Set a prop for the next animations where the prop is undefined. The given
     * value is overridden by the next update where the prop is defined.
     *
     * Ongoing animations are not changed.
     */
    setProp<P extends keyof CachedProps<State>>(key: P & string, value: CachedProps<State>[P]): this;
    /** @internal Get the `AnimatedValue` nodes for the given key */
    getPayload(key: string): AnimatedValue[] | undefined;
    private _ensureAnimated;
    private _start;
    private _attach;
    private _stop;
    private _flush;
    private _run;
    private _runAsync;
    private _diff;
    private _isModified;
    private _animate;
    /**
     * Stop an animation by its key.
     *
     * This mutates the `timestamps.to[key]`, `props.to[key]`, and `animations[key]` properties.
     * Notably, it does *not* mutate the `configs[key]` or `animated[key]` properties.
     */
    private _stopAnimation;
}

/**
 * The map of `Animated` objects passed into `animated()` components.
 *
 * The `T` parameter is the props object passed to `useSpring` or similar.
 */
declare type SpringValues<T extends object> = AnimationValues<PickAnimated<T>>;
/**
 * The map of `Animated` objects passed into `animated()` components.
 *
 * The `T` parameter should only contain animated props.
 */
declare type AnimationValues<T extends object> = Remap$1<{
    [key: string]: SpringValue<any>;
} & ({} extends Required<T> ? unknown : {
    [P in keyof T]: SpringValue<Exclude<T[P], void>>;
})>;
interface SpringStopFn<T extends object = any> {
    /** Stop the animations and delays of the given keys */
    (...keys: StringKeys<T>[]): void;
}
/**
 * An imperative update to the props of a spring.
 *
 * The `T` parameter should only contain animated props.
 */
declare type SpringUpdate<T extends object = {}> = Partial<T> & SpringProps<{
    to: T;
}> & UnknownProps;
/**
 * Imperative API for updating the props of a spring.
 *
 * The `T` parameter should only contain animated props.
 */
interface SpringUpdateFn<T extends object = {}> {
    /** Update the props of a spring */
    (props: SpringUpdate<T>): void;
}
/**
 * Imperative API for the useSprings hook, allowing to update individually or over the array
 *
 * The `T` parameter should only contain animated props.
 */
interface SpringsUpdateFn<T extends object = {}> {
    /** Update the props of a spring */
    (props: SpringUpdate<T> | SpringUpdate<T>[] | ((index: number, spring: Controller<T>) => SpringUpdate<T>)): void;
}
/**
 * An async function that can update or cancel the animations of a spring.
 *
 * The `T` parameter should only contain animated props.
 */
interface SpringAsyncFn<T extends object = {}> {
    (next: SpringUpdateFn<T>, stop: SpringStopFn<T>): Promise<void>;
}
/**
 * Imperative animation controller
 *
 * Created by `useSpring` or `useSprings` for the `ref` prop
 */
interface SpringHandle {
    /** Start any pending animations */
    start: () => void;
    /** Stop one or more animations */
    stop: SpringStopFn;
}
/** Spring animation config */
interface SpringConfig {
    mass?: number;
    tension?: number;
    friction?: number;
    velocity?: number;
    clamp?: boolean;
    precision?: number;
    delay?: number;
    decay?: number | boolean;
    duration?: number;
    easing?: EasingFunction;
}
/**
 * Animation-related props
 *
 * The `T` parameter is the props object passed to `useSpring` or similar.
 */
declare type SpringProps<T extends object> = Merge<AnimationProps<PickAnimated<T>>, AnimationEvents<PickAnimated<T>>>;
declare type UnknownPartial<T extends object> = UnknownProps & Partial<T>;
/**
 * The `to` prop type.
 *
 * The `T` parameter should only contain animated props.
 */
declare type ToProp<T extends object = {}> = UnknownPartial<T> | ReadonlyArray<UnknownPartial<T> & AnimationProps<T>> | SpringAsyncFn<T>;
declare type Animation<T = unknown, P extends string = string> = IdleAnimation<T, P> | ActiveAnimation<T, P>;
/** The array of animation configs for a set of animated props */
declare type AnimationList<State extends object> = Animation<State[StringKeys<State>], StringKeys<State>>[];
/** The dictionary of animation configs for a set of animated props */
declare type AnimationMap<State extends object> = {
    [P in StringKeys<State>]: Animation<State[P], P>;
};
/** The dictionary of animated nodes for a set of animated props */
declare type AnimatedNodes<State extends object> = {
    [P in StringKeys<State>]: Animation<State[P]>['animated'];
};
/** These properties exist in every animation config. */
interface AnimationConfig<T = unknown, P extends string = string> {
    key: P;
    isNew?: boolean;
    goalValue: T;
    animatedValues: AnimatedValue[];
    animated: Animated & SpringValue<T> & {
        /**
         * Set the animated value. The `flush` argument is true by default.
         */
        setValue?: (newValue: T, flush?: boolean) => void;
    };
}
/** An animation ignored by the frameloop */
interface IdleAnimation<T = unknown, P extends string = string> extends AnimationConfig<T, P> {
    idle: true;
}
/** An animation being executed by the frameloop */
interface ActiveAnimation<T = unknown, P extends string = string> extends AnimationConfig<T, P>, Omit<SpringConfig, 'velocity'> {
    idle: false;
    config: SpringConfig;
    initialVelocity: number;
    immediate: boolean;
    toValues: Arrify<T>;
    fromValues: Arrify<T>;
}
/**
 * Animation-related props
 *
 * The `T` parameter should only contain animated props.
 *
 * Note: The `onFrame` and `onRest` props do *not* have entirely accurate
 * argument types, because the ambiguity helps with inference.
 */
interface AnimationProps<T extends object = {}> extends AnimationEvents {
    /**
     * Configure the spring behavior for each key.
     */
    config?: SpringConfig | ((key: keyof T) => SpringConfig);
    /**
     * Milliseconds to wait before applying the other props.
     */
    delay?: number;
    /**
     * When true, props jump to their goal values instead of animating.
     */
    immediate?: boolean | ((key: keyof T) => boolean);
    /**
     * Cancel all animations by using `true`, or some animations by using a key
     * or an array of keys.
     */
    cancel?: boolean | OneOrMore<keyof T>;
    /**
     * Start the next animations at their values in the `from` prop.
     */
    reset?: boolean;
    /**
     * Swap the `to` and `from` props.
     */
    reverse?: boolean;
}
/**
 * The event props of an animation.
 *
 * The `T` parameter should only contain animated props.
 */
interface AnimationEvents<T extends object = {}> {
    /**
     * Called when a controller is told to animate
     */
    onAnimate?: (props: AnimationProps<T & UnknownProps>, controller: Controller<T & UnknownProps>) => void;
    /**
     * Called when an animation is about to start
     */
    onStart?: (animation: ActiveAnimation) => void;
    /**
     * Called when all animations come to a stand-still
     */
    onRest?: (restValues: Readonly<T & UnknownProps>) => void;
    /**
     * Called on every frame when animations are active
     */
    onFrame?: (currentValues: Readonly<T & UnknownProps>) => void;
}

declare function useChain(
  refs: ReadonlyArray<RefObject<SpringHandle>>,
  timeSteps?: number[],
  timeFrame?: number
): void

declare function useSpring<Props extends object>(
  props: () => Props & UseSpringProps<Props>
): [SpringValues<Props>, SpringUpdateFn<PickAnimated<Props>>, SpringStopFn]

declare function useSpring<Props extends object>(
  props: Props extends Function ? UseSpringProps : Props & UseSpringProps<Props>
): SpringValues<Props>

/**
 * The props that `useSpring` recognizes.
 */
interface UseSpringProps<Props extends object = {}>
  extends AnimationProps {
  /**
   * Used to access the imperative API.
   *
   * Animations never auto-start when `ref` is defined.
   */
  ref?: RefObject<SpringHandle>
  /**
   * The start values of the first animations.
   *
   * The `reset` prop also uses these values.
   */
  from?: Partial<PickAnimated<Props>> | Falsy
  /**
   * The end values of the current animations.
   *
   * As an array, it creates a chain of animations.
   *
   * As an async function, it can create animations on-the-fly.
   */
  to?: ToProp | Falsy
}

declare function useSprings<Props extends object>(
  count: number,
  props: (i: number) => Props & UseSpringProps<Props>
): [SpringValues<Props>[], SpringsUpdateFn<PickAnimated<Props>>, SpringStopFn]

declare function useSprings<Props extends object>(
  count: number,
  props: ReadonlyArray<Props & UseSpringProps<Props>>
): SpringValues<Props>[]

declare function useTrail<Props extends object>(
  count: number,
  props: () => Props & UseSpringProps<Props>
): [SpringValues<Props>[], SpringUpdateFn<PickAnimated<Props>>, SpringStopFn]

declare function useTrail<Props extends object>(
  count: number,
  props: Props extends Function ? UseSpringProps : Props & UseSpringProps<Props>
): SpringValues<Props>[]

type ItemsProp<T> = ReadonlyArray<T> | T | null | undefined
type ItemKeys<T> =
  | ((item: T) => string | number)
  | ReadonlyArray<string | number>
  | string
  | number
  | null

/**
 * Animate a set of values whenever one changes.
 *
 * The returned array can be safely mutated.
 */
declare function useTransition<
  Item,
  Props extends UnknownProps & UseTransitionProps<Item>
>(
  items: ItemsProp<Item>,
  keys: ItemKeys<Item>,
  props: Props
): ItemTransition<Item, Props>[]

/** The transition state of a single item */
type ItemTransition<Item, Props extends object = {}> = Solve<{
  key: string | number
  item: Item
  phase: TransitionPhase
  props: SpringValues<Props>
}>

/** For props that provide animated keys */
type TransitionProp<Item> =
  | SpringUpdate
  | readonly SpringUpdate[]
  | ((item: Item) => SpringUpdate | SpringAsyncFn)

type UseTransitionProps<Item = any> = {
  /**
   * Base values (from -> enter), or: item => values
   * @default {}
   */
  from?: TransitionProp<Item>
  /**
   * Values that apply to new elements, or: item => values
   * @default {}
   */
  enter?: TransitionProp<Item>
  /**
   * Values that apply to leaving elements, or: item => values
   * @default {}
   */
  leave?: TransitionProp<Item>
  /**
   * Values that apply to elements that are neither entering nor leaving (you
   * can use this to update present elements), or: item => values
   */
  update?: TransitionProp<Item>
  /**
   * First-render initial values, if present overrides "from" on the first
   * render pass. It can be "null" to skip first mounting transition. Otherwise
   * it can take an object or a function (item => object)
   */
  initial?: TransitionProp<Item> | null
  /**
   * Configure the spring behavior for each item.
   */
  config?: SpringConfig | ((item: Item, phase: TransitionPhase) => SpringConfig)
  /**
   * The same keys you would normally hand over to React in a list.
   */
  keys?:
    | ((item: Item) => string | number)
    | ReadonlyArray<string | number>
    | string
    | number
  /**
   * When this and `unique` are both true, items in the "enter" phase start from
   * their values in the "from" prop instead of their current positions.
   */
  reset?: boolean
  /**
   * Milliseconds of delay before animating the next item.
   *
   * This applies to all transition phases.
   */
  trail?: number
  /**
   * When true, no two items can have the same key. Reuse any items that
   * re-enter before they finish leaving.
   */
  unique?: boolean
  /**
   * Called when an animation is about to start
   */
  onStart?: (item: Item, phase: TransitionPhase, animation: any) => void
  /**
   * Called when all animations come to a stand-still
   */
  onRest?: (
    item: Item,
    phase: TransitionPhase,
    restValues: UnknownProps
  ) => void
  /**
   * Called on every frame when animations are active
   */
  onFrame?: (
    item: Item,
    phase: TransitionPhase,
    currentValues: UnknownProps
  ) => void
  /**
   * Called after an object has finished its "leave" transition
   */
  onDestroyed?: (item: Item) => void
}

declare const Spring: <Props extends object>(
  props: Props &
    UseSpringProps<Props> & {
      children: (props: SpringValues<Props>) => ReactNode
    }
) => JSX.Element

declare const Trail: <Item, Props extends object>(
  props: Merge<
    Props & UseSpringProps<Props>,
    {
      items: readonly Item[]
      children: (
        item: Item,
        index: number
      ) =>
        | ((props: SpringValues<Props>) => ReactNode)
        | false
        | null
        | undefined
    }
  >
) => JSX.Element

declare const Transition: <Item, Props extends object>(
  props: Merge<
    Props,
    UseTransitionProps<Item> & {
      keys?: ItemKeys<Item>
      items: ItemsProp<Item>
      children: (
        item: Item,
        phase: TransitionPhase,
        index: number
      ) =>
        | ((props: SpringValues<Props>) => ReactNode)
        | false
        | null
        | undefined
    }
  >
) => JSX.Element

/** Advance all animations forward one frame */
declare const update: () => boolean;

declare const config: {
    default: {
        readonly tension: 170;
        readonly friction: 26;
    };
    gentle: {
        readonly tension: 120;
        readonly friction: 14;
    };
    wobbly: {
        readonly tension: 180;
        readonly friction: 12;
    };
    stiff: {
        readonly tension: 210;
        readonly friction: 20;
    };
    slow: {
        readonly tension: 280;
        readonly friction: 60;
    };
    molasses: {
        readonly tension: 280;
        readonly friction: 120;
    };
};

declare type FrameUpdater = (this: FrameLoop) => boolean;
declare type FrameListener = (this: FrameLoop, updates: FrameUpdate[]) => void;
declare type RequestFrameFn = (cb: FrameRequestCallback) => number | void;
declare class FrameLoop {
    /**
     * On each frame, these controllers are searched for values to animate.
     */
    controllers: Map<number, Controller<any>>;
    /**
     * True when no controllers are animating.
     */
    idle: boolean;
    /**
     * Process the next animation frame.
     *
     * Can be passed to `requestAnimationFrame` quite nicely.
     *
     * This advances any `Controller` instances added to it with the `start` function.
     */
    update: FrameUpdater;
    /**
     * This is called at the end of every frame.
     *
     * The listener is passed an array of key-value pairs for each controller that
     * was updated in the most recent frame. The indices are directly mapped to
     * the `controllers` array, so empty arrays may exist.
     */
    onFrame: FrameListener;
    /**
     * The `requestAnimationFrame` function or a custom scheduler.
     */
    requestFrame: RequestFrameFn;
    constructor({ update, onFrame, requestFrame, }?: {
        update?: FrameUpdater;
        onFrame?: FrameListener;
        requestFrame?: RequestFrameFn;
    });
    start(ctrl: Controller): void;
    stop(ctrl: Controller): void;
    /** Advance an animation forward one frame. */
    advance(config: ActiveAnimation, changes: FrameUpdate[2]): boolean;
}

export { AnimationEvents, AnimationProps, Controller, ForwardProps, FrameLoop, FrameUpdate, ItemKeys, ItemTransition, ItemsProp, ReservedProps, Spring, SpringAsyncFn, SpringConfig, SpringHandle, SpringProps, SpringStopFn, SpringUpdate, SpringUpdateFn, SpringsUpdateFn, Trail, Transition, TransitionPhase, UnknownProps, UseSpringProps, UseTransitionProps, config, update, useChain, useSpring, useSprings, useTrail, useTransition };
