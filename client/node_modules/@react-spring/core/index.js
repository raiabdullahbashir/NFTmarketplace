import React, { useEffect, useRef, useMemo, useImperativeHandle } from 'react';
import _extends from '@babel/runtime/helpers/esm/extends';
import { is, each, toArray, usePrev, useOnce, useForceUpdate, Globals } from '@react-spring/shared';
export { Globals, createInterpolator } from '@react-spring/shared';
import _objectWithoutPropertiesLoose from '@babel/runtime/helpers/esm/objectWithoutPropertiesLoose';
import { useMemoOne, useCallbackOne } from 'use-memo-one';
import { now, createStringInterpolator, frameLoop, skipAnimation, colorNames, requestAnimationFrame } from '@react-spring/shared/globals';
import { AnimatedArray, AnimatedValue, Animated } from '@react-spring/animated';
export { interpolate, isAnimated, to } from '@react-spring/animated';
import { createStringInterpolator as createStringInterpolator$1 } from '@react-spring/shared/stringInterpolation';

/** API
 *  useChain(references, timeSteps, timeFrame)
 */

function useChain(refs, timeSteps, timeFrame) {
  if (timeFrame === void 0) {
    timeFrame = 1000;
  }

  useEffect(() => {
    if (timeSteps) {
      let prevDelay = 0;
      refs.forEach((ref, i) => {
        if (!ref.current) return;
        const controllers = ref.current.controllers;

        if (controllers.length) {
          let delay = timeFrame * timeSteps[i]; // Use the previous delay if none exists.

          if (isNaN(delay)) delay = prevDelay;else prevDelay = delay;
          controllers.forEach(ctrl => {
            ctrl.queue.forEach(props => props.delay += delay);
            ctrl.start();
          });
        }
      });
    } else {
      let p = Promise.resolve();
      refs.forEach(ref => {
        const _ref = ref.current || {},
              controllers = _ref.controllers,
              start = _ref.start;

        if (controllers && controllers.length) {
          // Take the queue of each controller
          const updates = controllers.map(ctrl => {
            const q = ctrl.queue;
            ctrl.queue = [];
            return q;
          }); // Apply the queue when the previous ref stops animating

          p = p.then(() => {
            controllers.forEach((ctrl, i) => ctrl.queue.push(...updates[i]));
            return start();
          });
        } else {
          console.warn('useChain ref has no animations:', ref);
        }
      });
    }
  });
}

function fillArray(length, mapIndex) {
  const arr = [];

  for (let i = 0; i < length; i++) arr.push(mapIndex(i));

  return arr;
}
function withDefault(value, defaultValue) {
  return value == null ? defaultValue : value;
}
function callProp(obj) {
  for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    args[_key - 1] = arguments[_key];
  }

  return is.fun(obj) ? obj(...args) : obj;
}
/**
 * Extract any properties whose keys are *not* reserved for customizing your
 * animations. All hooks use this function, which means `useTransition` props
 * are reserved for `useSpring` calls, etc.
 */

function getForwardProps(props) {
  const children = props.children,
        config = props.config,
        from = props.from,
        to = props.to,
        ref = props.ref,
        reset = props.reset,
        cancel = props.cancel,
        reverse = props.reverse,
        immediate = props.immediate,
        delay = props.delay,
        lazy = props.lazy,
        items = props.items,
        trail = props.trail,
        unique = props.unique,
        initial = props.initial,
        enter = props.enter,
        leave = props.leave,
        update = props.update,
        onAnimate = props.onAnimate,
        onStart = props.onStart,
        onRest = props.onRest,
        onFrame = props.onFrame,
        onDestroyed = props.onDestroyed,
        timestamp = props.timestamp,
        attach = props.attach,
        forward = _objectWithoutPropertiesLoose(props, ["children", "config", "from", "to", "ref", "reset", "cancel", "reverse", "immediate", "delay", "lazy", "items", "trail", "unique", "initial", "enter", "leave", "update", "onAnimate", "onStart", "onRest", "onFrame", "onDestroyed", "timestamp", "attach"]);

  return forward;
}

function interpolateTo(props) {
  const to = getForwardProps(props);
  const out = {
    to
  };
  each(props, (val, key) => key in to || (out[key] = val));
  return out;
}
/**
 * This tries to put deleted items back into the given `out` list in correct
 * order. Deleted items must have a `left` and `right` property with key of
 * their sibling which is used to find the correct placement.
 */

function reconcileDeleted(deleted, current) {
  // Copy as we will be mutating the arrays
  deleted = [...deleted];
  current = [...current]; // Used to detect deadlock (when a pass finds 0 siblings)

  let failedTries = 0; // Track where the current pass start/ends

  let passIndex = 0;
  let nextPassIndex = deleted.length; // Insert all deleted items into `current`

  for (let i = 0; i < deleted.length; i++) {
    if (i === nextPassIndex) {
      // Sanity test: Push to end if somehow no siblings were found
      if (passIndex + failedTries === nextPassIndex) {
        for (let j = i; j < deleted.length; j++) {
          const _deleted$j = deleted[j],
                left = _deleted$j.left,
                right = _deleted$j.right,
                deletedItem = _objectWithoutPropertiesLoose(_deleted$j, ["left", "right"]);

          current.push(deletedItem);
        }

        break;
      } // Update local state at the end of each pass


      passIndex = nextPassIndex;
      nextPassIndex = deleted.length;
      failedTries = 0;
    } // The index of the deleted item in `current`


    let index = -1; // Look for the left or right sibling in `current`

    const _deleted$i = deleted[i],
          left = _deleted$i.left,
          right = _deleted$i.right,
          deletedItem = _objectWithoutPropertiesLoose(_deleted$i, ["left", "right"]);

    for (let j = current.length; --j >= 0;) {
      const key = current[j].originalKey;

      if (key === right) {
        index = j;
        break;
      }

      if (key === left) {
        index = j + 1;
        break;
      }
    } // Items with no index are revisited in the next pass


    if (index < 0) {
      failedTries++;
      deleted.push(deleted[i]);
    } else {
      current.splice(index, 0, deletedItem);
    }
  }

  return current;
}
function freeze(obj) {
  if (typeof process !== 'undefined' && process.env.NODE_ENV === 'development') {
    return Object.freeze(obj);
  }

  return obj;
}

const linear = t => t;

const emptyObj = Object.freeze({});
let nextId = 1;
class Controller {
  constructor(props) {
    this.id = nextId++;
    this.idle = true;
    this.runCount = 0;
    this.destroyed = false;
    this.props = {};
    this.queue = [];
    this.timestamps = {};
    this.values = {};
    this.merged = {};
    this.animated = {};
    this.animations = {};
    this.configs = [];
    this.children = [];
    this.onEndQueue = [];
    this.cancelledAt = 0;
    if (props) this.update(props).start();
  }
  /**
   * Push props into the update queue. The props are used after `start` is
   * called and any delay is over. The props are intelligently diffed to ensure
   * that later calls to this method properly override any delayed props.
   * The `propsArg` argument is always copied before mutations are made.
   */


  update(propsArg) {
    if (!propsArg || this.destroyed) return this;
    const props = interpolateTo(propsArg); // For async animations, the `from` prop must be defined for
    // the Animated nodes to exist before animations have started.

    this._ensureAnimated(props.from, true);

    this._ensureAnimated(props.to);

    props.timestamp = now(); // The `delay` prop of every update must be a number >= 0

    if (is.fun(props.delay) && is.obj(props.to)) {
      const from = props.from || emptyObj;

      for (const key in props.to) {
        this.queue.push(_extends({}, props, {
          to: {
            [key]: props.to[key]
          },
          from: key in from ? {
            [key]: from[key]
          } : void 0,
          delay: Math.max(0, Math.round(props.delay(key)))
        }));
      }
    } else {
      props.delay = is.num(props.delay) ? Math.max(0, Math.round(props.delay)) : 0; // Coerce falsy values to undefined for these props

      if (!props.to) props.to = void 0;
      if (!props.from) props.from = void 0;
      this.queue.push(props);
    }

    return this;
  }
  /**
   * Flush the update queue, and call `onEnd` when they have settled.
   *
   * The `onEnd` callback does **not** wait for unsettled updates from previous `start` calls.
   */


  start(onEnd) {
    if (this.queue.length) this._flush(onEnd);else if (onEnd) onEnd();
    return this;
  }
  /** Stop one animation or all animations */


  stop() {
    for (var _len = arguments.length, keys = new Array(_len), _key = 0; _key < _len; _key++) {
      keys[_key] = arguments[_key];
    }

    // Stop animations by key
    if (keys.length) {
      for (const key of keys) {
        const index = this.configs.findIndex(config => key === config.key);

        this._stopAnimation(key);

        this.configs[index] = this.animations[key];
      }
    } // Stop all animations
    else if (this.runCount) {
        this.cancelledAt = now(); // Update the animation configs

        each(this.configs, config => this._stopAnimation(config.key));
        this.configs = Object.values(this.animations); // Exit the frameloop

        if (!this.idle) {
          this._stop();
        }
      }

    return this;
  }
  /** Revert the controller to its initial state */


  reset() {
    // Stop all current animations
    this.stop(); // Revert the internal state

    this.destroyed = false;
    this.props = {};
    this.queue = [];
    this.timestamps = {};
    this.values = {};
    this.merged = {};
    this.animated = {};
    this.animations = {};
    this.configs = [];
    return this;
  }
  /** Prevent all current and future animation */


  destroy() {
    if (!this.destroyed) {
      this.stop();
      this.destroyed = true;
    }
  }
  /** @internal Called by the frameloop */


  onFrame(_ref) {
    let id = _ref[0],
        idle = _ref[1],
        changes = _ref[2];
    if (id !== this.id) return;

    if (changes && changes.length) {
      for (const _ref2 of changes) {
        const key = _ref2[0];
        const value = _ref2[1];
        this.values[key] = value;
      } // The `onFrame` prop always exists when `changes` exists.


      this.props.onFrame(_extends({}, this.values));
    }

    if (idle) {
      this._stop();
    }
  }
  /**
   * Set a prop for the next animations where the prop is undefined. The given
   * value is overridden by the next update where the prop is defined.
   *
   * Ongoing animations are not changed.
   */


  setProp(key, value) {
    this.props[key] = value;
    this.timestamps[key] = now();
    return this;
  }
  /** @internal Get the `AnimatedValue` nodes for the given key */


  getPayload(key) {
    const anim = this.animations[key];
    return anim && anim.animatedValues;
  } // Create an Animated node if none exists.


  _ensureAnimated(values, shouldUpdate) {
    if (shouldUpdate === void 0) {
      shouldUpdate = false;
    }

    if (!is.obj(values)) return;

    for (const key in values) {
      const value = values[key];
      let animated = this.animated[key];

      if (animated && shouldUpdate && this.animations[key].isNew) {
        // Ensure the initial value is up-to-date.
        if (animated.setValue) {
          animated.setValue(computeGoalValue(value));
        } else {
          // Derived nodes need to be swapped out.
          animated = null;
        }
      }

      if (!animated) {
        animated = createAnimated(value);

        if (this.animated[key]) {
          // Swap out the old node with the new node.
          moveChildren(this.animated[key], animated);
        }

        this.animated[key] = animated;

        this._stopAnimation(key, true);
      }
    }
  } // Add this controller to the frameloop.


  _start(onEnd) {
    if (this.idle) {
      if (this.configs.some(config => !config.idle)) {
        this.idle = false;
        frameLoop.start(this);
      } else if (onEnd) {
        return onEnd();
      }
    }

    if (onEnd) {
      this.onEndQueue.push(onEnd);
    }
  } // Attach our children to the given keys if possible.


  _attach(keys, visited) {
    if (visited === void 0) {
      visited = {};
    }

    each(this.children, c => {
      if (visited[this.id]) return;
      visited[this.id] = true;
      const attached = keys.filter(key => {
        const payload = c.getPayload(key);

        if (payload) {
          each(payload, node => node.done && node.reset(true));
          return true;
        }
      });

      if (attached.length) {
        c._attach(attached, visited);

        c._start();
      }
    });
  } // Remove this controller from the frameloop, and notify any listeners.


  _stop() {
    this.idle = true;
    frameLoop.stop(this);
    const onRest = this.props.onRest;

    if (is.fun(onRest)) {
      onRest(this.merged);
    }

    const onEndQueue = this.onEndQueue;

    if (onEndQueue.length) {
      this.onEndQueue = [];
      each(onEndQueue, onEnd => onEnd());
    }
  } // Execute the current queue of prop updates.


  _flush(onEnd) {
    const queue = this.queue.reduce(reduceDelays, []);
    this.queue.length = 0; // Track the number of unsettled updates.

    let runsLeft = Object.keys(queue).length;
    this.runCount += runsLeft; // Any run can finish last.

    const onRunEnd = () => {
      this.runCount--;

      if (! --runsLeft && onEnd) {
        onEnd();
      }
    };

    each(queue, (props, delay) => {
      if (delay) {
        setTimeout(() => {
          // Cancelling methods touch the `cancelledAt` property
          if (props.timestamp < this.cancelledAt) return;

          this._run(props, onRunEnd);
        }, delay);
      } else {
        this._run(props, onRunEnd);
      }
    });
  } // Update the props and animations


  _run(props, onEnd) {
    if (is.arr(props.to) || is.fun(props.to)) {
      this._runAsync(props, onEnd);
    } else if (this._diff(props)) {
      this._animate(props)._start(onEnd);
    } else {
      onEnd();
    }
  } // Start an async chain or an async script.


  _runAsync(_ref3, onEnd) {
    let to = _ref3.to,
        props = _objectWithoutPropertiesLoose(_ref3, ["to"]);

    // Merge other props immediately.
    if (this._diff(props)) {
      this._animate(props);
    } // Async scripts can be declaratively cancelled.


    if (props.cancel === true) {
      this.props.asyncTo = void 0;
      return onEnd();
    } // Never run more than one script at a time


    const timestamp = props.timestamp;

    if (!this._diff({
      asyncTo: to,
      timestamp
    })) {
      return onEnd();
    }

    const isCancelled = () => // Cancelling methods touch the `cancelledAt` property
    timestamp < this.cancelledAt || // Async scripts are also cancelled when a new chain/script begins
    is.fun(to) && to !== this.props.asyncTo;

    let last;

    const next = props => {
      if (isCancelled()) throw this;
      return (last = new Promise(done => {
        this.update(props).start(done);
      })).then(() => {
        if (isCancelled()) throw this;
      });
    };

    let queue = Promise.resolve();

    if (is.arr(to)) {
      each(to, props => {
        queue = queue.then(() => next(props));
      });
    } else if (is.fun(to)) {
      queue = queue.then(() => to(next, this.stop.bind(this)) // Always wait for the last update.
      .then(() => last));
    }

    queue.catch(err => err !== this && console.error(err)).then(onEnd);
  } // Merge every fresh prop. Returns true if one or more props changed.
  // These props cannot trigger an update by themselves:
  //   [delay, config, immediate, reverse, attach]


  _diff(_ref4) {
    let timestamp = _ref4.timestamp,
        delay = _ref4.delay,
        config = _ref4.config,
        immediate = _ref4.immediate,
        reverse = _ref4.reverse,
        attach = _ref4.attach,
        props = _objectWithoutPropertiesLoose(_ref4, ["timestamp", "delay", "config", "immediate", "reverse", "attach"]);

    let changed = false; // Generalized diffing algorithm

    const diffProp = (keys, value, owner) => {
      if (is.und(value)) return;
      const lastKey = keys[keys.length - 1];

      if (is.obj(value)) {
        if (!is.obj(owner[lastKey])) owner[lastKey] = {};

        for (const key in value) {
          diffProp(keys.concat(key), value[key], owner[lastKey]);
        }
      } else {
        const keyPath = keys.join('.');
        const oldTimestamp = this.timestamps[keyPath];

        if (is.und(oldTimestamp) || timestamp >= oldTimestamp) {
          this.timestamps[keyPath] = timestamp;
          const oldValue = owner[lastKey];

          if (!isEqual(value, oldValue)) {
            changed = true;
            owner[lastKey] = value;
          }
        }
      }
    };

    if (reverse) {
      const to = props.to;
      props.to = props.from;
      props.from = is.obj(to) ? to : void 0;
    } // The "attach" prop is called on every diff. It overwrites the "parent" prop.


    props.parent = (attach ? attach(this) : props.parent) || null;
    const oldParent = this.props.parent || null;

    if (props.parent !== oldParent) {
      if (oldParent) oldParent.children.splice(oldParent.children.indexOf(this), 1);
      if (props.parent) props.parent.children.push(this);
    }

    for (const key in props) {
      diffProp([key], props[key], this.props);
    } // These props only affect one update


    if ('reset' in props) this.props.reset = false;
    if ('cancel' in props) this.props.cancel = void 0;
    return changed;
  } // Return true if the given prop was changed by this update


  _isModified(props, prop) {
    return this.timestamps[prop] === props.timestamp;
  } // Update the animation configs. The given props override any default props.


  _animate(props) {
    const _this$props = this.props,
          _this$props$from = _this$props.from,
          from = _this$props$from === void 0 ? emptyObj : _this$props$from,
          _this$props$to = _this$props.to,
          to = _this$props$to === void 0 ? emptyObj : _this$props$to,
          parent = _this$props.parent,
          onAnimate = _this$props.onAnimate,
          onStart = _this$props.onStart;

    if (is.fun(onAnimate)) {
      onAnimate(props, this);
    }

    let isPrevented = _ => false;

    if (props.cancel && this._isModified(props, 'cancel')) {
      // Stop all animations when `cancel` is true
      if (props.cancel === true) {
        this.stop(); // Prevent pending updates from *before* this update only!
        // (This must come after the `stop` call above)

        this.cancelledAt = props.timestamp;
        return this;
      } // Prevent matching properties from animating when
      // `cancel` is a string or array of strings


      const keys = toArray(props.cancel);

      if (is.arr(keys) && keys.length) {
        isPrevented = key => keys.indexOf(key) >= 0;

        this.stop(...keys);
      }
    } // Merge `from` values with `to` values


    this.merged = freeze(_extends({}, from, to)); // True if any animation was updated

    let changed = false; // The animations that are starting or restarting

    const started = []; // Attach when a new "parent" controller exists.

    const isAttaching = parent && this._isModified(props, 'parent'); // Reduces input { key: value } pairs into animation objects


    for (const key in this.merged) {
      if (isPrevented(key)) continue;
      const state = this.animations[key];

      if (!state) {
        console.warn(`Failed to animate key: "${key}"\n` + `Did you forget to define "from.${key}" for an async animation?`);
        continue;
      } // Reuse the Animated nodes whenever possible


      let animated = state.animated,
          animatedValues = state.animatedValues;
      const value = this.merged[key];
      const goalValue = computeGoalValue(value);
      const currValue = animated.getValue(); // Stop animations with a goal value equal to its current value.

      if (!props.reset && !isAttaching && isEqual(goalValue, currValue)) {
        // The animation might be stopped already.
        if (!state.idle) {
          changed = true;

          this._stopAnimation(key);
        }

        continue;
      } // Replace an animation when its goal value is changed (or it's been reset)


      if (props.reset || isAttaching || !isEqual(goalValue, state.isNew ? currValue : state.goalValue)) {
        const immediate = !!callProp((is.und(props.immediate) ? this.props : props).immediate, key);
        const isActive = animatedValues.some(node => !node.done);
        const fromValue = !is.und(from[key]) ? computeGoalValue(from[key]) : goalValue; // Animatable strings use interpolation

        const isInterpolated = isAnimatableString(value);

        if (isInterpolated) {
          const output = [props.reset ? fromValue : currValue, goalValue];
          let input = animatedValues[0];

          if (input) {
            input.setValue(0, false);
            input.reset(isActive);
          } else {
            input = new AnimatedValue(0);
          }

          try {
            const prev = animated;
            animated = input.to({
              output
            });
            moveChildren(prev, animated);
          } catch (err) {
            console.warn('Failed to interpolate string from "%s" to "%s"', output[0], output[1]);
            console.error(err);
            continue;
          }

          if (skipAnimation) {
            input.setValue(1);

            this._stopAnimation(key);

            continue;
          }

          if (immediate) {
            input.setValue(1, false);
          }
        } else {
          // Convert values into Animated nodes (reusing nodes whenever possible)
          if (is.arr(value)) {
            if (animated instanceof AnimatedArray) {
              if (props.reset) animated.setValue(fromValue, false);
              each(animatedValues, node => node.reset(isActive));
            } else {
              const prev = animated;
              animated = createAnimated(fromValue);
              moveChildren(prev, animated);
            }
          } else {
            if (animated instanceof AnimatedValue) {
              if (props.reset) animated.setValue(fromValue, false);
              animated.reset(isActive);
            } else {
              const prev = animated;
              animated = new AnimatedValue(fromValue);
              moveChildren(prev, animated);
            }
          }

          if (skipAnimation) {
            animated.setValue(goalValue);

            this._stopAnimation(key);

            continue;
          }

          if (immediate) {
            animated.setValue(goalValue, false);
          }
        } // Only change the "config" of updated animations.


        const config = callProp(props.config, key) || callProp(this.props.config, key) || emptyObj;

        if (!(immediate || skipAnimation)) {
          started.push(key);
        }

        const fromValues = animatedValues.map(v => v.getValue());
        const toValues = parent && parent.getPayload(key) || toArray(isInterpolated ? 1 : goalValue);
        changed = true;
        this.animations[key] = {
          key,
          idle: false,
          goalValue,
          toValues,
          fromValues,
          animated,
          animatedValues: Array.from(animated.getPayload()),
          immediate,
          duration: config.duration,
          easing: withDefault(config.easing, linear),
          decay: config.decay,
          mass: withDefault(config.mass, 1),
          tension: withDefault(config.tension, 170),
          friction: withDefault(config.friction, 26),
          initialVelocity: withDefault(config.velocity, 0),
          clamp: withDefault(config.clamp, false),
          precision: withDefault(config.precision, 0.005),
          config
        };
      }
    }

    if (changed) {
      if (started.length) {
        this._attach(started);

        if (is.fun(onStart)) each(started, key => {
          onStart(this.animations[key]);
        });
      } // Make animations available to the frameloop


      const keys = Object.keys(this.animations);
      this.configs.length = keys.length;
      each(keys, (key, i) => {
        const config = this.animations[key];
        this.configs[i] = config;
        this.values[key] = config.animated.getValue();
        this.animated[key] = config.animated;
      });
    }

    return this;
  }
  /**
   * Stop an animation by its key.
   *
   * This mutates the `timestamps.to[key]`, `props.to[key]`, and `animations[key]` properties.
   * Notably, it does *not* mutate the `configs[key]` or `animated[key]` properties.
   */


  _stopAnimation(key, isNew) {
    const animated = this.animated[key];

    if (!animated) {
      return console.warn(`Cannot stop an animation for a key that isn't animated: "${key}"`);
    } // Prevent any pending updates to this key


    this.timestamps['to.' + key] = now(); // Idle animations are skipped unless their Animated node changed

    const state = this.animations[key] || emptyObj;
    if (state.idle && animated === state.animated) return; // Use the previous `isNew` value if nothing was passed

    if (is.und(isNew)) {
      isNew = !!state.isNew;
    } // Tell the frameloop to skip animating these values


    const animatedValues = Array.from(animated.getPayload());
    each(animatedValues, node => {
      node.done = true;
    }); // The current value becomes the goal value,
    // which ensures the integrity of the diffing algorithm.

    const goalValue = animated.getValue();

    if (this.props.to) {
      this.props.to[key] = goalValue;
    } // Remove unused data from this key's animation config


    this.animations[key] = {
      key,
      idle: true,
      isNew,
      goalValue,
      animated,
      animatedValues
    };
  }

}
/** Wrap any value with an `Animated` node */

function createAnimated(value) {
  return is.arr(value) ? new AnimatedArray(value.map(createAnimated)) : isAnimatableString(value) ? // Convert "red" into "rgba(255, 0, 0, 1)" etc
  new AnimatedValue(0).to({
    output: [value, value]
  }) : // The `AnimatedValue` class supports any type, but only numbers are
  // interpolated by the frameloop.
  new AnimatedValue(value);
}
/**
 * Replace an `Animated` node in the graph.
 * This is most useful for async updates, which don't cause a re-render.
 */


function moveChildren(prev, next) {
  each(Array.from(prev.getChildren()), child => {
    child.updatePayload(prev, next);
    prev.removeChild(child);
    next.addChild(child);
  });
} // Merge updates with the same delay.
// NOTE: Mutation of `props` may occur!


function reduceDelays(merged, props) {
  const prev = merged[props.delay];

  if (prev) {
    props.to = merge(prev.to, props.to);
    props.from = merge(prev.from, props.from);
    Object.assign(prev, props);
  } else {
    merged[props.delay] = props;
  }

  return merged;
}

function merge(dest, src) {
  return is.obj(dest) && is.obj(src) ? _extends({}, dest, src) : src || dest;
} // Not all strings can be animated (eg: {display: "none"})


function isAnimatableString(value) {
  if (!is.str(value)) return false;
  return value.startsWith('#') || /\d/.test(value) || !!(colorNames && colorNames[value]);
} // Compute the goal value, converting "red" to "rgba(255, 0, 0, 1)" in the process


function computeGoalValue(value) {
  return is.arr(value) ? value.map(computeGoalValue) : isAnimatableString(value) ? createStringInterpolator({
    range: [0, 1],
    output: [value, value]
  })(1) : value;
} // Compare animatable values


function isEqual(a, b) {
  if (is.arr(a)) {
    if (!is.arr(b) || a.length !== b.length) return false;

    for (let i = 0; i < a.length; i++) {
      if (a[i] !== b[i]) return false;
    }

    return true;
  }

  return a === b;
}

/** API
 * const props = useSprings(number, [{ ... }, { ... }, ...])
 * const [props, set] = useSprings(number, (i, controller) => ({ ... }))
 */

const useSprings = (length, propsArg, deps) => {
  const hasNewSprings = length !== usePrev(length);
  const isFn = is.fun(propsArg);
  const state = useRef({
    springs: [],
    ref: null
  }).current; // The `propsArg` coerced into an array

  const props = isFn ? [] : propsArg; // Recreate the controllers whenever `length` changes

  const springs = useMemoOne(() => fillArray(length, i => {
    const s = new Controller();
    const p = props[i] || (props[i] = callProp(propsArg, i, s));
    return s.update(p);
  }), [length]);

  const _useMemo = useMemo(() => ({
    /** Apply any pending updates */
    start: () => Promise.all(state.springs.map(s => new Promise(done => s.start(done)))),

    /** Update the spring controllers */
    update: props => {
      const isFn = is.fun(props);
      const isArr = is.arr(props);
      state.springs.forEach((spring, i) => {
        spring.update(isFn ? callProp(props, i, spring) : isArr ? props[i] : props);
        if (!state.ref) spring.start();
      });
    },

    /** Stop one key or all keys from animating */
    stop: function stop() {
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      return state.springs.forEach(s => s.stop(...args));
    }
  }), []),
        start = _useMemo.start,
        update = _useMemo.update,
        stop = _useMemo.stop;

  const ref = props[0] ? props[0].ref : isFn ? state.ref : null;
  useImperativeHandle(ref, () => ({
    start,
    stop,

    get controllers() {
      return state.springs;
    }

  })); // Once mounted, update the local state and start any animations.

  useEffect(() => {
    if (!isFn || hasNewSprings) {
      props.forEach((p, i) => {
        // Set default props for async updates
        springs[i].setProp('config', p.config);
        springs[i].setProp('immediate', p.immediate);
      });
    }

    if (hasNewSprings) {
      state.springs.forEach(s => s.destroy());
      state.springs = springs;
      state.ref = ref;

      if (!ref) {
        springs.forEach(s => s.start());
      }
    } else if (!isFn) {
      update(props);
    }
  }, deps); // Destroy the controllers on unmount

  useOnce(() => () => {
    state.springs.forEach(s => s.destroy());
  });
  const values = springs.map(s => _extends({}, s.animated));
  return isFn ? [values, update, stop] : values;
};

/** API
 * const props = useSpring({ ... })
 * const [props, set] = useSpring(() => ({ ... }))
 */

const useSpring = (props, deps) => {
  const isFn = is.fun(props);

  const _useSprings = useSprings(1, isFn ? props : [props], deps),
        result = _useSprings[0],
        set = _useSprings[1],
        stop = _useSprings[2];

  return isFn ? [result[0], set, stop] : result;
};

/** API
 * const trails = useTrail(number, { ... })
 * const [trails, set] = useTrail(number, () => ({ ... }))
 */

const useTrail = (length, propsArg) => {
  const hasNewSprings = length !== usePrev(length);
  const isFn = is.fun(propsArg); // The `propsArg` coerced into an object

  let props = isFn ? null : propsArg; // Retain the controllers so we can update them.

  const springsRef = useRef([]);
  const springs = springsRef.current;
  if (hasNewSprings) springs.length = length; // The controllers are recreated whenever `length` changes.

  const _useSprings = useSprings(length, (i, spring) => {
    if (isFn && !props) {
      props = callProp(propsArg, spring) || {};
    }

    springs[i] = spring;
    return _extends({}, props, i > 0 && {
      attach: () => springs[i - 1],
      onStart: withArgument(props.onStart, i),
      onFrame: withArgument(props.onFrame, i),
      onRest: withArgument(props.onRest, i)
    }, {
      config: callProp(props.config, i)
    });
  }),
        values = _useSprings[0],
        animate = _useSprings[1],
        stop = _useSprings[2];
  /** For imperative updates to the props of all springs in the trail */


  const update = useCallbackOne(propsArg => animate((i, spring) => {
    const props = callProp(propsArg, i, spring) || {};
    const parent = springsRef.current[props.reverse ? i + 1 : i - 1];
    return _extends({}, props, {
      attach: () => parent,
      config: callProp(props.config, i)
    });
  }), []); // Update the animations on re-render when `propsArg` is an object
  // and the controllers were *not* created in the current render.

  useEffect(() => {
    if (!isFn && !hasNewSprings) {
      update(propsArg);
    }
  }); // Return the update/stop functions when the `propsArg` is a function.

  return isFn ? [values, update, stop] : values;
};

function withArgument(fn, arg) {
  return is.fun(fn) ? function () {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return fn(...args, arg);
  } : fn;
}

/** API
 * const transitions = useTransition(items, itemKeys, { ... })
 * const [transitions, update] = useTransition(items, itemKeys, () => ({ ... }))
 */

let guid = 0;
const INITIAL = 'initial';
const ENTER = 'enter';
const UPDATE = 'update';
const LEAVE = 'leave';

const makeKeys = (items, keys) => (typeof keys === 'function' ? items.map(keys) : toArray(keys)).map(String);

const makeConfig = props => {
  let items = props.items,
      keys = props.keys,
      rest = _objectWithoutPropertiesLoose(props, ["items", "keys"]);

  items = toArray(is.und(items) ? null : items);
  return _extends({
    items,
    keys: makeKeys(items, keys)
  }, rest);
};

function useTransition(input, keyTransform, props) {
  props = makeConfig(_extends({}, props, {
    items: input,
    keys: keyTransform || (i => i)
  }));

  const _props = props,
        _props$lazy = _props.lazy,
        lazy = _props$lazy === void 0 ? false : _props$lazy,
        _props$unique = _props.unique,
        from = _props.from,
        enter = _props.enter,
        leave = _props.leave,
        update = _props.update,
        onDestroyed = _props.onDestroyed,
        keys = _props.keys,
        items = _props.items,
        onFrame = _props.onFrame,
        _onRest = _props.onRest,
        onStart = _props.onStart,
        ref = _props.ref,
        extra = _objectWithoutPropertiesLoose(_props, ["lazy", "unique", "from", "enter", "leave", "update", "onDestroyed", "keys", "items", "onFrame", "onRest", "onStart", "ref"]);

  const forceUpdate = useForceUpdate();
  const mounted = useRef(false);
  const state = useRef({
    mounted: false,
    first: true,
    deleted: [],
    current: {},
    transitions: [],
    prevProps: {},
    paused: !!ref,
    instances: !mounted.current && new Map(),
    forceUpdate
  });
  useImperativeHandle(ref, () => ({
    start: () => Promise.all(Array.from(state.current.instances).map((_ref) => {
      let c = _ref[1];
      return new Promise(r => c.start(r));
    })),
    stop: finished => Array.from(state.current.instances).forEach((_ref2) => {
      let c = _ref2[1];
      return c.stop(finished);
    }),

    get controllers() {
      return Array.from(state.current.instances).map((_ref3) => {
        let c = _ref3[1];
        return c;
      });
    }

  })); // Update state

  state.current = diffItems(state.current, props);

  if (state.current.changed) {
    // Update state
    state.current.transitions.forEach(transition => {
      const phase = transition.phase,
            key = transition.key,
            item = transition.item,
            props = transition.props;
      if (!state.current.instances.has(key)) state.current.instances.set(key, new Controller()); // Avoid calling `onStart` more than once per transition.

      let started = false; // update the map object

      const ctrl = state.current.instances.get(key);

      const itemProps = _extends({}, extra, props, {
        onRest: values => {
          if (state.current.mounted) {
            if (transition.destroyed) {
              // If no ref is given delete destroyed items immediately
              if (!ref && !lazy) cleanUp(state, key);
              if (onDestroyed) onDestroyed(item);
            } // A transition comes to rest once all its springs conclude


            const curInstances = Array.from(state.current.instances);
            const active = curInstances.some((_ref4) => {
              let c = _ref4[1];
              return !c.idle;
            });

            if (!active && (ref || lazy) && state.current.deleted.length > 0) {
              cleanUp(state);
            }

            if (is.fun(_onRest)) {
              _onRest(item, phase, values);
            }
          }
        },
        onFrame: is.fun(onFrame) && (values => onFrame(item, phase, values)),
        onStart: is.fun(onStart) && (animation => started || (started = (onStart(item, phase, animation), true))) // Update controller

      });

      ctrl.update(itemProps);
      if (!state.current.paused) ctrl.start();
    });
  }

  useOnce(() => {
    state.current.mounted = mounted.current = true;
    return () => {
      state.current.mounted = mounted.current = false;
      Array.from(state.current.instances).map((_ref5) => {
        let c = _ref5[1];
        return c.destroy();
      });
      state.current.instances.clear();
    };
  });
  return state.current.transitions.map((_ref6) => {
    let item = _ref6.item,
        phase = _ref6.phase,
        key = _ref6.key;
    return {
      item,
      key,
      phase,
      props: _extends({}, state.current.instances.get(key).animated)
    };
  });
}

function cleanUp(_ref7, filterKey) {
  let state = _ref7.current;
  const deleted = state.deleted;

  for (let _ref8 of deleted) {
    let key = _ref8.key;

    const filter = t => t.key !== key;

    if (is.und(filterKey) || filterKey === key) {
      state.instances.delete(key);
      state.transitions = state.transitions.filter(filter);
      state.deleted = state.deleted.filter(filter);
    }
  }

  state.forceUpdate();
}

function diffItems(_ref9, props) {
  let first = _ref9.first,
      current = _ref9.current,
      deleted = _ref9.deleted,
      prevProps = _ref9.prevProps,
      state = _objectWithoutPropertiesLoose(_ref9, ["first", "current", "deleted", "prevProps"]);

  let items = props.items,
      keys = props.keys,
      initial = props.initial,
      from = props.from,
      enter = props.enter,
      leave = props.leave,
      update = props.update,
      _props$trail = props.trail,
      trail = _props$trail === void 0 ? 0 : _props$trail,
      unique = props.unique,
      config = props.config,
      _props$order = props.order,
      order = _props$order === void 0 ? [ENTER, LEAVE, UPDATE] : _props$order;

  let _makeConfig = makeConfig(prevProps),
      _keys = _makeConfig.keys,
      _items = _makeConfig.items;

  if (props.reset) {
    current = {};
    state.transitions = [];
  } // Compare next keys with current keys


  const currentKeys = Object.keys(current);
  const currentSet = new Set(currentKeys);
  const nextSet = new Set(keys);
  const addedKeys = keys.filter(key => !currentSet.has(key));
  const updatedKeys = update ? keys.filter(key => currentSet.has(key)) : [];
  const deletedKeys = state.transitions.filter(t => !t.destroyed && !nextSet.has(t.originalKey)).map(t => t.originalKey);
  let delay = -trail;

  while (order.length) {
    let phase = order.shift();

    if (phase === ENTER) {
      if (first && !is.und(initial)) {
        phase = INITIAL;
        from = initial;
      }

      addedKeys.forEach(key => {
        // In unique mode, remove fading out transitions if their key comes in again
        if (unique && deleted.find(d => d.originalKey === key)) {
          deleted = deleted.filter(t => t.originalKey !== key);
        }

        const i = keys.indexOf(key);
        const item = items[i];
        const enterProps = callProp(enter, item, i);
        current[key] = {
          phase,
          originalKey: key,
          key: unique ? String(key) : guid++,
          item,
          props: _extends({
            delay: delay += trail,
            config: callProp(config, item, phase),
            from: callProp(from, item, i),
            to: enterProps
          }, is.obj(enterProps) && interpolateTo(enterProps))
        };
      });
    } else if (phase === LEAVE) {
      deletedKeys.forEach(key => {
        const i = _keys.indexOf(key);

        const item = _items[i];
        const leaveProps = callProp(leave, item, i);
        deleted.push(_extends({}, current[key], {
          phase,
          destroyed: true,
          left: _keys[i - 1],
          right: _keys[i + 1],
          props: _extends({
            delay: delay += trail,
            config: callProp(config, item, phase),
            to: leaveProps
          }, is.obj(leaveProps) && interpolateTo(leaveProps))
        }));
        delete current[key];
      });
    } else if (phase === UPDATE) {
      updatedKeys.forEach(key => {
        const i = keys.indexOf(key);
        const item = items[i];
        const updateProps = callProp(update, item, i);
        current[key] = _extends({}, current[key], {
          phase,
          props: _extends({
            delay: delay += trail,
            config: callProp(config, item, phase),
            to: updateProps
          }, is.obj(updateProps) && interpolateTo(updateProps))
        });
      });
    }
  }

  let out = keys.map(key => current[key]);
  out = reconcileDeleted(deleted, out);
  return _extends({}, state, {
    first: first && !addedKeys.length,
    changed: !!(addedKeys.length || deletedKeys.length || updatedKeys.length),
    transitions: out,
    current,
    deleted,
    prevProps: props
  });
}

function Spring(_ref) {
  let children = _ref.children,
      props = _objectWithoutPropertiesLoose(_ref, ["children"]);

  return children(useSpring(props));
}
function Trail(_ref2) {
  let items = _ref2.items,
      children = _ref2.children,
      props = _objectWithoutPropertiesLoose(_ref2, ["items", "children"]);

  const trails = useTrail(items.length, props);
  return items.map((item, index) => {
    const result = children(item, index);
    return is.fun(result) ? result(trails[index]) : result;
  });
}
function Transition(_ref3) {
  let items = _ref3.items,
      _ref3$keys = _ref3.keys,
      keys = _ref3$keys === void 0 ? null : _ref3$keys,
      children = _ref3.children,
      props = _objectWithoutPropertiesLoose(_ref3, ["items", "keys", "children"]);

  const transitions = useTransition(items, keys, props);
  return transitions.map((_ref4, index) => {
    let item = _ref4.item,
        key = _ref4.key,
        props = _ref4.props,
        phase = _ref4.phase;
    const result = children(item, phase, index);
    const element = is.fun(result) ? result(props) : result;
    return element && element.type ? React.createElement(element.type, _extends({}, element.props, {
      key: key,
      ref: element.ref
    })) : element;
  });
}

class FrameLoop {
  constructor(_temp) {
    let _ref = _temp === void 0 ? {} : _temp,
        update = _ref.update,
        onFrame = _ref.onFrame,
        requestFrame = _ref.requestFrame;

    /**
     * On each frame, these controllers are searched for values to animate.
     */
    this.controllers = new Map();
    /**
     * True when no controllers are animating.
     */

    this.idle = true;

    this.requestFrame = // The global `requestAnimationFrame` must be dereferenced to avoid "Illegal invocation" errors
    requestFrame || (fn => (0, requestAnimationFrame)(fn));

    this.onFrame = onFrame && onFrame.bind(this) || (updates => {
      updates.forEach(update => {
        const ctrl = this.controllers.get(update[0]);
        if (ctrl) ctrl.onFrame(update);
      });
    });

    this.update = update && update.bind(this) || (() => {
      if (this.idle) {
        return false;
      } // Update the animations.


      const updates = [];

      for (const id of Array.from(this.controllers.keys())) {
        let idle = true;
        const ctrl = this.controllers.get(id);
        const changes = ctrl.props.onFrame ? [] : null;

        for (const config of ctrl.configs) {
          if (config.idle) continue;

          if (this.advance(config, changes)) {
            idle = false;
          }
        }

        updates.push([id, idle, changes]);
      } // Notify the controllers!


      this.onFrame(updates); // Are we done yet?

      if (!this.controllers.size) {
        return !(this.idle = true);
      } // Keep going.


      this.requestFrame(this.update);
      return true;
    });
  }

  start(ctrl) {
    this.controllers.set(ctrl.id, ctrl);

    if (this.idle) {
      this.idle = false;
      this.requestFrame(this.update);
    }
  }

  stop(ctrl) {
    this.controllers.delete(ctrl.id);
  }
  /** Advance an animation forward one frame. */


  advance(config, changes) {
    const time = now();
    let active = false;
    let changed = false;

    for (let i = 0; i < config.animatedValues.length; i++) {
      const animated = config.animatedValues[i];
      if (animated.done) continue;
      changed = true;
      let to = config.toValues[i];
      const target = to instanceof Animated ? to : null;
      if (target) to = target.getValue(); // Jump to end value for immediate animations

      if (config.immediate) {
        animated.setValue(to);
        animated.done = true;
        continue;
      }

      const from = config.fromValues[i];
      const startTime = animated.startTime; // Break animation when string values are involved

      if (typeof from === 'string' || typeof to === 'string') {
        animated.setValue(to);
        animated.done = true;
        continue;
      }

      let finished = false;
      let position = animated.lastPosition;
      let velocity = Array.isArray(config.initialVelocity) ? config.initialVelocity[i] : config.initialVelocity; // Duration easing

      if (config.duration !== void 0) {
        position = from + config.easing((time - startTime) / config.duration) * (to - from);
        finished = time >= startTime + config.duration;
      } // Decay easing
      else if (config.decay) {
          const decay = config.decay === true ? 0.998 : config.decay;
          position = from + velocity / (1 - decay) * (1 - Math.exp(-(1 - decay) * (time - startTime)));
          finished = Math.abs(animated.lastPosition - position) < 0.1;
          if (finished) to = position;
        } // Spring easing
        else {
            let lastTime = animated.lastTime !== void 0 ? animated.lastTime : time;

            if (animated.lastVelocity !== void 0) {
              velocity = animated.lastVelocity;
            } // If we lost a lot of frames just jump to the end.


            if (time > lastTime + 64) lastTime = time; // http://gafferongames.com/game-physics/fix-your-timestep/

            const numSteps = Math.floor(time - lastTime);

            for (let n = 0; n < numSteps; ++n) {
              const force = -config.tension * (position - to);
              const damping = -config.friction * velocity;
              const acceleration = (force + damping) / config.mass;
              velocity = velocity + acceleration * 1 / 1000;
              position = position + velocity * 1 / 1000;
            }

            animated.lastTime = time;
            animated.lastVelocity = velocity; // Conditions for stopping the spring animation

            const isOvershooting = config.clamp && config.tension !== 0 ? from < to ? position > to : position < to : false;
            const isVelocity = Math.abs(velocity) <= config.precision;
            const isDisplacement = config.tension !== 0 ? Math.abs(to - position) <= config.precision : true;
            finished = isOvershooting || isVelocity && isDisplacement;
          } // Trails aren't done until their parents conclude


      if (finished && !(target && !target.done)) {
        // Ensure that we end up with a round value
        if (animated.value !== to) position = to;
        animated.done = true;
      } else {
        active = true;
      }

      animated.setValue(position);
      animated.lastPosition = position;
    }

    if (changes && changed) {
      changes.push([config.key, config.animated.getValue()]);
    }

    return active;
  }

}

Globals.assign({
  frameLoop: new FrameLoop(),
  createStringInterpolator: createStringInterpolator$1,
  applyAnimatedValues: () => false
});
/** Advance all animations forward one frame */

const update = () => Globals.frameLoop.update();

// The `mass` prop defaults to 1
const config = {
  default: {
    tension: 170,
    friction: 26
  },
  gentle: {
    tension: 120,
    friction: 14
  },
  wobbly: {
    tension: 180,
    friction: 12
  },
  stiff: {
    tension: 210,
    friction: 20
  },
  slow: {
    tension: 280,
    friction: 60
  },
  molasses: {
    tension: 280,
    friction: 120
  }
};

export { Controller, FrameLoop, Spring, Trail, Transition, config, update, useChain, useSpring, useSprings, useTrail, useTransition };
//# sourceMappingURL=index.js.map
