'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

var shared = require('@react-spring/shared');
var _extends = _interopDefault(require('@babel/runtime/helpers/extends'));
var _inheritsLoose = _interopDefault(require('@babel/runtime/helpers/inheritsLoose'));
var G = require('@react-spring/shared/globals');
var deprecations = require('@react-spring/shared/deprecations');
var _assertThisInitialized = _interopDefault(require('@babel/runtime/helpers/assertThisInitialized'));
var invariant = _interopDefault(require('tiny-invariant'));
var React = require('react');
var React__default = _interopDefault(React);

var _a;

var animatedTag = Symbol.for('isAnimated');
var isAnimated = function isAnimated(val) {
  return !!(val && val[animatedTag]);
};
var Animated =
/*#__PURE__*/
function () {
  function Animated() {
    this[_a] = true;
    this.children = new Set();
  }
  /** Returns the set of `AnimatedValue` nodes contained by this node. */


  var _proto = Animated.prototype;

  _proto.getPayload = function getPayload() {
    return this.payload;
  }
  /** Returns the set of animated nodes that depend on this node. */
  ;

  _proto.getChildren = function getChildren() {
    return this.children;
  };

  _proto.addChild = function addChild(child) {
    this.children.size || this._attach();
    this.children.add(child);
  };

  _proto.removeChild = function removeChild(child) {
    this.children.delete(child);
    this.children.size || this._detach();
  };

  return Animated;
}();
_a = animatedTag;

var AnimatedObject =
/*#__PURE__*/
function (_Animated) {
  _inheritsLoose(AnimatedObject, _Animated);

  function AnimatedObject(source) {
    var _this;

    _this = _Animated.call(this) || this;
    _this.source = source;
    _this.payload = toPayload(source);
    return _this;
  }

  var _proto = AnimatedObject.prototype;

  _proto.getValue = function getValue(animated) {
    var obj = {};
    shared.each(this.source, function (val, key) {
      if (isAnimated(val)) {
        obj[key] = val.getValue(animated);
      } else if (!animated) {
        obj[key] = val;
      }
    });
    return obj;
  };

  _proto.updatePayload = function updatePayload(prev, next) {
    var source = _extends({}, this.source);

    shared.each(source, function (val, key) {
      if (val === prev) source[key] = next;
    });
    this.source = source;
    this.payload = toPayload(source);
  };

  _proto._attach = function _attach() {
    shared.each(this.source, addChild, this);
  };

  _proto._detach = function _detach() {
    shared.each(this.source, removeChild, this);
  };

  return AnimatedObject;
}(Animated);
/** Convert an array or object to a flat payload */

function toPayload(source) {
  var payload = new Set();
  shared.each(source, function (val) {
    if (isAnimated(val)) {
      shared.each(val.getPayload(), function (node) {
        return payload.add(node);
      });
    }
  });
  return payload;
}
function addChild(parent) {
  if (isAnimated(parent)) parent.addChild(this);
}
function removeChild(parent) {
  if (isAnimated(parent)) parent.removeChild(this);
}

var AnimatedStyle =
/*#__PURE__*/
function (_AnimatedObject) {
  _inheritsLoose(AnimatedStyle, _AnimatedObject);

  function AnimatedStyle(style) {
    if (style === void 0) {
      style = {};
    }

    return _AnimatedObject.call(this, style.transform && G.createAnimatedTransform ? _extends({}, style, {
      transform: G.createAnimatedTransform(style.transform)
    }) : style) || this;
  }

  return AnimatedStyle;
}(AnimatedObject);

var AnimatedInterpolation =
/*#__PURE__*/
function (_Animated) {
  _inheritsLoose(AnimatedInterpolation, _Animated);

  function AnimatedInterpolation(source, args) {
    var _this;

    _this = _Animated.call(this) || this;
    _this.source = source;
    _this.calc = shared.createInterpolator.apply(void 0, args);
    return _this;
  }

  var _proto = AnimatedInterpolation.prototype;

  _proto.getValue = function getValue(animated) {
    var args = shared.is.arr(this.source) ? this.source.map(function (node) {
      return node.getValue(animated);
    }) : shared.toArray(this.source.getValue(animated));
    return this.calc.apply(this, args);
  };

  _proto.to = function to() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return new AnimatedInterpolation(this, args);
  };

  _proto.interpolate = function interpolate() {
    deprecations.deprecateInterpolate();
    return this.to.apply(this, arguments);
  };

  _proto.getPayload = function getPayload() {
    return shared.is.arr(this.source) ? this.payload || (this.payload = toPayload(this.source)) : this.source.getPayload();
  };

  _proto.updatePayload = function updatePayload(prev, next) {
    this.payload = void 0;

    if (shared.is.arr(this.source)) {
      var source = [].concat(this.source);
      shared.each(source, function (val, index) {
        if (val === prev) source[index] = next;
      });
      this.source = source;
    } else {
      this.source = next;
    }
  };

  _proto._attach = function _attach() {
    shared.each(shared.toArray(this.source), addChild, this);
  };

  _proto._detach = function _detach() {
    shared.each(shared.toArray(this.source), removeChild, this);
  };

  return AnimatedInterpolation;
}(Animated);

shared.Globals.assign({
  createAnimatedStyle: function createAnimatedStyle(style) {
    return new AnimatedStyle(style);
  },
  createAnimatedInterpolation: function createAnimatedInterpolation(parents) {
    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      args[_key - 1] = arguments[_key];
    }

    return new AnimatedInterpolation(parents, args);
  }
});

var interpolate = function interpolate() {
  deprecations.deprecateInterpolate();
  return G.createAnimatedInterpolation.apply(void 0, arguments);
};

/** An animated number or a native attribute value */

var AnimatedValue =
/*#__PURE__*/
function (_Animated) {
  _inheritsLoose(AnimatedValue, _Animated);

  function AnimatedValue(value) {
    var _this;

    _this = _Animated.call(this) || this;
    _this.views = new Set();
    _this.done = false;
    _this.value = value;
    _this.payload = new Set([_assertThisInitialized(_this)]);

    if (shared.is.num(value)) {
      _this.startPosition = value;
      _this.lastPosition = value;
    }

    return _this;
  }

  var _proto = AnimatedValue.prototype;

  _proto.getValue = function getValue() {
    return this.value;
  };

  _proto.setValue = function setValue(value, flush) {
    this.value = value;

    if (flush !== false) {
      if (!this.views.size) {
        collectViews(this, this.views);
      }

      shared.each(this.views, function (view) {
        return view.update();
      });
    }
  };

  _proto.to = function to() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return G.createAnimatedInterpolation.apply(void 0, [this].concat(args));
  };

  _proto.interpolate = function interpolate() {
    deprecations.deprecateInterpolate();
    return this.to.apply(this, arguments);
  };

  _proto.reset = function reset(isActive) {
    if (shared.is.num(this.value)) {
      this.startPosition = this.value;
      this.lastPosition = this.value;
      this.lastVelocity = isActive ? this.lastVelocity : undefined;
      this.lastTime = isActive ? this.lastTime : undefined;
      this.startTime = G.now();
    }

    this.done = false;
    this.views.clear();
  } // Do nothing for either of these.
  ;

  _proto._attach = function _attach() {};

  _proto._detach = function _detach() {};

  return AnimatedValue;
}(Animated);
/**
 * This library works by building a directed acyclic graph of dependencies
 * transparently whenever you render your Animated components.
 *
 *               new Animated.Value(0)
 *     .interpolate()        .interpolate()    new Animated.Value(1)
 *         opacity               translateY      scale
 *          style                         transform
 *         View#234                         style
 *                                         View#123
 *
 * A) Top Down phase
 * When an AnimatedValue is updated, we recursively go down through this
 * graph in order to find leaf nodes: the components that depend on our value.
 *
 * B) Bottom Up phase
 * When a view is flagged as needing an update, we recursively go back up
 * in order to build the new props that it needs. This two-phase process is
 * necessary because some props (eg: "transform") can have multiple parents.
 */

function collectViews(node, views) {
  if ('update' in node) {
    views.add(node);
  } else {
    shared.each(node.getChildren(), function (child) {
      return collectViews(child, views);
    });
  }
}

/** An array of animated nodes */

var AnimatedArray =
/*#__PURE__*/
function (_AnimatedObject) {
  _inheritsLoose(AnimatedArray, _AnimatedObject);

  function AnimatedArray(source) {
    return _AnimatedObject.call(this, source) || this;
  }

  var _proto = AnimatedArray.prototype;

  _proto.getValue = function getValue(animated) {
    return this.source.map(function (node) {
      return node.getValue(animated);
    });
  };

  _proto.setValue = function setValue(value, flush) {
    var nodes = this.payload;

    if (shared.is.arr(value)) {
      invariant(value.length == nodes.size);
      var i = 0;
      shared.each(nodes, function (node) {
        return node.setValue(value[i++], flush);
      });
    } else {
      shared.each(nodes, function (node) {
        return node.setValue(value, flush);
      });
    }
  };

  _proto.to = function to() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return G.createAnimatedInterpolation.apply(void 0, [this].concat(args));
  };

  _proto.interpolate = function interpolate() {
    deprecations.deprecateInterpolate();
    return this.to.apply(this, arguments);
  };

  _proto.updatePayload = function updatePayload(prev, next) {
    var source = [].concat(this.source);
    shared.each(source, function (val, index) {
      if (val === prev) source[index] = next;
    });
    this.source = source;
    this.payload = toPayload(source);
  };

  return AnimatedArray;
}(AnimatedObject);

var AnimatedProps =
/*#__PURE__*/
function (_AnimatedObject) {
  _inheritsLoose(AnimatedProps, _AnimatedObject);

  function AnimatedProps(props, update) {
    var _this;

    _this = _AnimatedObject.call(this, props.style && G.createAnimatedStyle ? _extends({}, props, {
      style: G.createAnimatedStyle(props.style)
    }) : props) || this;
    _this.update = update;
    return _this;
  }

  return AnimatedProps;
}(AnimatedObject);

var cacheKey = Symbol.for('AnimatedComponent');
var withAnimated = function withAnimated(Component) {
  return shared.is.str(Component) ? createAnimatedComponent(Component) : Component[cacheKey] || (Component[cacheKey] = createAnimatedComponent(Component));
};

var createAnimatedComponent = function createAnimatedComponent(Component) {
  return React.forwardRef(function (rawProps, ref) {
    var node = React.useRef(null);
    var props = React.useRef(null);
    var forceUpdate = shared.useForceUpdate();
    var nextProps = new AnimatedProps(rawProps, function () {
      if (!node.current) return;
      var didUpdate = G.applyAnimatedValues(node.current, nextProps.getValue(true)); // Re-render the component when native updates fail.

      if (didUpdate === false) {
        forceUpdate();
      }
    });
    React.useEffect(function () {
      var prevProps = props.current;
      props.current = nextProps; // To avoid causing a cascade of detachment, we must detach
      // the old props only *after* the new props are attached.

      nextProps._attach();

      if (prevProps) {
        prevProps._detach();
      }
    }); // Ensure the latest props are detached on unmount.

    shared.useOnce(function () {
      return function () {
        props.current._detach();
      };
    }); // Functions cannot have refs (see #569)

    var refFn = !shared.is.fun(Component) || Component.prototype.isReactComponent ? function (value) {
      return node.current = updateRef(ref, value);
    } : void 0;
    rawProps = G.getComponentProps(nextProps.getValue());
    return React__default.createElement(Component, Object.assign({}, rawProps, {
      ref: refFn
    }));
  });
};

function updateRef(ref, value) {
  if (ref) {
    if (shared.is.fun(ref)) ref(value);else ref.current = value;
  }

  return value;
}
/**
 * Pass the given components to `withAnimated` and add the newly animated
 * components to `withAnimated` as properties.
 */


var extendAnimated = function extendAnimated(withAnimated, components, lowercase) {
  components.forEach(function (Component) {
    var key = getDisplayName(Component);

    if (lowercase) {
      key = key[0].toLowerCase() + key.slice(1);
    }

    withAnimated[key] = withAnimated(Component);
  });
  return withAnimated;
};

var getDisplayName = function getDisplayName(arg) {
  return shared.is.str(arg) ? arg : arg && shared.is.str(arg.displayName) ? arg.displayName : shared.is.fun(arg) && arg.name || null;
};

Object.defineProperty(exports, 'to', {
  enumerable: true,
  get: function () {
    return G.createAnimatedInterpolation;
  }
});
exports.Animated = Animated;
exports.AnimatedArray = AnimatedArray;
exports.AnimatedInterpolation = AnimatedInterpolation;
exports.AnimatedObject = AnimatedObject;
exports.AnimatedProps = AnimatedProps;
exports.AnimatedStyle = AnimatedStyle;
exports.AnimatedValue = AnimatedValue;
exports.addChild = addChild;
exports.animatedTag = animatedTag;
exports.extendAnimated = extendAnimated;
exports.interpolate = interpolate;
exports.isAnimated = isAnimated;
exports.removeChild = removeChild;
exports.toPayload = toPayload;
exports.withAnimated = withAnimated;
//# sourceMappingURL=index.cjs.js.map
