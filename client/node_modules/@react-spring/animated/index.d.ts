import { SpringValue, Animatable, InterpolatorArgs, Indexable, Interpolatable, OneOrMore, Interpolator, ElementType, SpringInterpolator } from '@react-spring/shared';
export { createAnimatedInterpolation as to } from '@react-spring/shared/globals';

/** An animated number or a native attribute value */
declare class AnimatedValue<T = unknown> extends Animated implements SpringValue<T> {
    private views;
    value: T;
    startPosition: number;
    lastPosition: number;
    lastVelocity?: number;
    startTime?: number;
    lastTime?: number;
    done: boolean;
    constructor(value: T);
    getValue(): T;
    setValue(value: T, flush?: boolean): void;
    to<Out extends Animatable>(...args: InterpolatorArgs<T, Out>): SpringValue<Out>;
    interpolate<Out extends Animatable>(...args: InterpolatorArgs<T, Out>): SpringValue<Out>;
    reset(isActive: boolean): void;
    updatePayload: any;
    _attach(): void;
    _detach(): void;
}

declare const animatedTag: unique symbol;
declare const isAnimated: (val: any) => val is Animated;
declare abstract class Animated {
    protected [animatedTag]: boolean;
    protected children: Set<Animated>;
    protected payload?: Set<AnimatedValue>;
    /** Returns all values contained by this node. Pass true for only the animated values. */
    abstract getValue(animated?: boolean): any;
    /** Returns the set of `AnimatedValue` nodes contained by this node. */
    getPayload(): ReadonlySet<AnimatedValue>;
    /** Replace an `AnimatedValue` node in the payload. */
    abstract updatePayload(prev: Animated, next: Animated): void;
    /** Returns the set of animated nodes that depend on this node. */
    getChildren(): ReadonlySet<Animated>;
    addChild(child: Animated): void;
    removeChild(child: Animated): void;
    /** Called when this node goes from 0 children to 1+ children. */
    abstract _attach(): void;
    /** Called when this node goes from 1+ children to 0 children. */
    abstract _detach(): void;
}

declare class AnimatedObject extends Animated {
    protected source: Indexable;
    protected payload: Set<AnimatedValue>;
    constructor(source: Indexable);
    getValue(animated?: boolean): any;
    updatePayload(prev: Animated, next: Animated): void;
    _attach(): void;
    _detach(): void;
}
/** Convert an array or object to a flat payload */
declare function toPayload(source: Indexable): Set<AnimatedValue<unknown>>;
declare function addChild(this: Animated, parent: any): void;
declare function removeChild(this: Animated, parent: any): void;

/** An array of animated nodes */
declare class AnimatedArray extends AnimatedObject implements SpringValue<any[]> {
    protected source: Animated[];
    constructor(source: Animated[]);
    getValue(animated?: boolean): any[];
    setValue(value: any, flush?: boolean): void;
    to<Out extends Animatable>(...args: InterpolatorArgs<any[], Out>): SpringValue<Out>;
    interpolate<Out extends Animatable>(...args: InterpolatorArgs<any[], Out>): SpringValue<Out>;
    updatePayload(prev: Animated, next: Animated): void;
}

declare class AnimatedInterpolation<In extends Interpolatable = Interpolatable, Out extends Animatable = Animatable> extends Animated implements SpringValue<Out> {
    source: OneOrMore<Animated>;
    calc: Interpolator<In>;
    constructor(source: OneOrMore<Animated>, args: InterpolatorArgs<In, Out>);
    getValue(animated?: boolean): Out;
    to<T extends Animatable>(...args: InterpolatorArgs<Out, T>): SpringValue<T>;
    interpolate<T extends Animatable>(...args: InterpolatorArgs<Out, T>): SpringValue<T>;
    getPayload(): ReadonlySet<AnimatedValue>;
    updatePayload(prev: Animated, next: Animated): void;
    _attach(): void;
    _detach(): void;
}

declare type Props = object & {
    style?: any;
};
declare class AnimatedProps extends AnimatedObject {
    update: () => void;
    constructor(props: Props, update: () => void);
}

declare type Style = object & {
    transform?: any;
};
declare class AnimatedStyle extends AnimatedObject {
    constructor(style?: Style);
}

declare type AnimatableComponent = string | Exclude<ElementType, string>;
declare type WithAnimated = {
    (Component: AnimatableComponent): any;
    [key: string]: any;
};
declare const withAnimated: WithAnimated;
/**
 * Pass the given components to `withAnimated` and add the newly animated
 * components to `withAnimated` as properties.
 */
declare const extendAnimated: (withAnimated: WithAnimated, components: AnimatableComponent[], lowercase?: boolean | undefined) => any;

declare const interpolate: SpringInterpolator;

export { Animated, AnimatedArray, AnimatedInterpolation, AnimatedObject, AnimatedProps, AnimatedStyle, AnimatedValue, addChild, animatedTag, extendAnimated, interpolate, isAnimated, removeChild, toPayload, withAnimated };
