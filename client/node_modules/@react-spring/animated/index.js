import { each, createInterpolator, is, toArray, Globals, useForceUpdate, useOnce } from '@react-spring/shared';
import _extends from '@babel/runtime/helpers/esm/extends';
import { createAnimatedTransform, createAnimatedInterpolation, now, createAnimatedStyle, applyAnimatedValues, getComponentProps } from '@react-spring/shared/globals';
export { createAnimatedInterpolation as to } from '@react-spring/shared/globals';
import { deprecateInterpolate } from '@react-spring/shared/deprecations';
import invariant from 'tiny-invariant';
import React, { forwardRef, useRef, useEffect } from 'react';

var _a;

const animatedTag = Symbol.for('isAnimated');
const isAnimated = val => !!(val && val[animatedTag]);
class Animated {
  constructor() {
    this[_a] = true;
    this.children = new Set();
  }
  /** Returns the set of `AnimatedValue` nodes contained by this node. */


  getPayload() {
    return this.payload;
  }
  /** Returns the set of animated nodes that depend on this node. */


  getChildren() {
    return this.children;
  }

  addChild(child) {
    this.children.size || this._attach();
    this.children.add(child);
  }

  removeChild(child) {
    this.children.delete(child);
    this.children.size || this._detach();
  }

}
_a = animatedTag;

class AnimatedObject extends Animated {
  constructor(source) {
    super();
    this.source = source;
    this.payload = toPayload(source);
  }

  getValue(animated) {
    const obj = {};
    each(this.source, (val, key) => {
      if (isAnimated(val)) {
        obj[key] = val.getValue(animated);
      } else if (!animated) {
        obj[key] = val;
      }
    });
    return obj;
  }

  updatePayload(prev, next) {
    const source = _extends({}, this.source);

    each(source, (val, key) => {
      if (val === prev) source[key] = next;
    });
    this.source = source;
    this.payload = toPayload(source);
  }

  _attach() {
    each(this.source, addChild, this);
  }

  _detach() {
    each(this.source, removeChild, this);
  }

}
/** Convert an array or object to a flat payload */

function toPayload(source) {
  const payload = new Set();
  each(source, val => {
    if (isAnimated(val)) {
      each(val.getPayload(), node => payload.add(node));
    }
  });
  return payload;
}
function addChild(parent) {
  if (isAnimated(parent)) parent.addChild(this);
}
function removeChild(parent) {
  if (isAnimated(parent)) parent.removeChild(this);
}

class AnimatedStyle extends AnimatedObject {
  constructor(style) {
    if (style === void 0) {
      style = {};
    }

    super(style.transform && createAnimatedTransform ? _extends({}, style, {
      transform: createAnimatedTransform(style.transform)
    }) : style);
  }

}

class AnimatedInterpolation extends Animated {
  constructor(source, args) {
    super();
    this.source = source;
    this.calc = createInterpolator(...args);
  }

  getValue(animated) {
    const args = is.arr(this.source) ? this.source.map(node => node.getValue(animated)) : toArray(this.source.getValue(animated));
    return this.calc(...args);
  }

  to() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return new AnimatedInterpolation(this, args);
  }

  interpolate() {
    deprecateInterpolate();
    return this.to(...arguments);
  }

  getPayload() {
    return is.arr(this.source) ? this.payload || (this.payload = toPayload(this.source)) : this.source.getPayload();
  }

  updatePayload(prev, next) {
    this.payload = void 0;

    if (is.arr(this.source)) {
      const source = [...this.source];
      each(source, (val, index) => {
        if (val === prev) source[index] = next;
      });
      this.source = source;
    } else {
      this.source = next;
    }
  }

  _attach() {
    each(toArray(this.source), addChild, this);
  }

  _detach() {
    each(toArray(this.source), removeChild, this);
  }

}

Globals.assign({
  createAnimatedStyle: style => new AnimatedStyle(style),
  createAnimatedInterpolation: function createAnimatedInterpolation(parents) {
    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      args[_key - 1] = arguments[_key];
    }

    return new AnimatedInterpolation(parents, args);
  }
});

const interpolate = function interpolate() {
  deprecateInterpolate();
  return createAnimatedInterpolation(...arguments);
};

/** An animated number or a native attribute value */

class AnimatedValue extends Animated {
  constructor(value) {
    super();
    this.views = new Set();
    this.done = false;
    this.value = value;
    this.payload = new Set([this]);

    if (is.num(value)) {
      this.startPosition = value;
      this.lastPosition = value;
    }
  }

  getValue() {
    return this.value;
  }

  setValue(value, flush) {
    this.value = value;

    if (flush !== false) {
      if (!this.views.size) {
        collectViews(this, this.views);
      }

      each(this.views, view => view.update());
    }
  }

  to() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return createAnimatedInterpolation(this, ...args);
  }

  interpolate() {
    deprecateInterpolate();
    return this.to(...arguments);
  }

  reset(isActive) {
    if (is.num(this.value)) {
      this.startPosition = this.value;
      this.lastPosition = this.value;
      this.lastVelocity = isActive ? this.lastVelocity : undefined;
      this.lastTime = isActive ? this.lastTime : undefined;
      this.startTime = now();
    }

    this.done = false;
    this.views.clear();
  } // Do nothing for either of these.


  _attach() {}

  _detach() {}

}
/**
 * This library works by building a directed acyclic graph of dependencies
 * transparently whenever you render your Animated components.
 *
 *               new Animated.Value(0)
 *     .interpolate()        .interpolate()    new Animated.Value(1)
 *         opacity               translateY      scale
 *          style                         transform
 *         View#234                         style
 *                                         View#123
 *
 * A) Top Down phase
 * When an AnimatedValue is updated, we recursively go down through this
 * graph in order to find leaf nodes: the components that depend on our value.
 *
 * B) Bottom Up phase
 * When a view is flagged as needing an update, we recursively go back up
 * in order to build the new props that it needs. This two-phase process is
 * necessary because some props (eg: "transform") can have multiple parents.
 */

function collectViews(node, views) {
  if ('update' in node) {
    views.add(node);
  } else {
    each(node.getChildren(), child => collectViews(child, views));
  }
}

/** An array of animated nodes */

class AnimatedArray extends AnimatedObject {
  constructor(source) {
    super(source);
  }

  getValue(animated) {
    return this.source.map(node => node.getValue(animated));
  }

  setValue(value, flush) {
    const nodes = this.payload;

    if (is.arr(value)) {
      invariant(value.length == nodes.size);
      let i = 0;
      each(nodes, node => node.setValue(value[i++], flush));
    } else {
      each(nodes, node => node.setValue(value, flush));
    }
  }

  to() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return createAnimatedInterpolation(this, ...args);
  }

  interpolate() {
    deprecateInterpolate();
    return this.to(...arguments);
  }

  updatePayload(prev, next) {
    const source = [...this.source];
    each(source, (val, index) => {
      if (val === prev) source[index] = next;
    });
    this.source = source;
    this.payload = toPayload(source);
  }

}

class AnimatedProps extends AnimatedObject {
  constructor(props, update) {
    super(props.style && createAnimatedStyle ? _extends({}, props, {
      style: createAnimatedStyle(props.style)
    }) : props);
    this.update = update;
  }

}

const cacheKey = Symbol.for('AnimatedComponent');
const withAnimated = Component => is.str(Component) ? createAnimatedComponent(Component) : Component[cacheKey] || (Component[cacheKey] = createAnimatedComponent(Component));

const createAnimatedComponent = Component => forwardRef((rawProps, ref) => {
  const node = useRef(null);
  const props = useRef(null);
  const forceUpdate = useForceUpdate();
  const nextProps = new AnimatedProps(rawProps, () => {
    if (!node.current) return;
    const didUpdate = applyAnimatedValues(node.current, nextProps.getValue(true)); // Re-render the component when native updates fail.

    if (didUpdate === false) {
      forceUpdate();
    }
  });
  useEffect(() => {
    const prevProps = props.current;
    props.current = nextProps; // To avoid causing a cascade of detachment, we must detach
    // the old props only *after* the new props are attached.

    nextProps._attach();

    if (prevProps) {
      prevProps._detach();
    }
  }); // Ensure the latest props are detached on unmount.

  useOnce(() => () => {
    props.current._detach();
  }); // Functions cannot have refs (see #569)

  const refFn = !is.fun(Component) || Component.prototype.isReactComponent ? value => node.current = updateRef(ref, value) : void 0;
  rawProps = getComponentProps(nextProps.getValue());
  return React.createElement(Component, Object.assign({}, rawProps, {
    ref: refFn
  }));
});

function updateRef(ref, value) {
  if (ref) {
    if (is.fun(ref)) ref(value);else ref.current = value;
  }

  return value;
}
/**
 * Pass the given components to `withAnimated` and add the newly animated
 * components to `withAnimated` as properties.
 */


const extendAnimated = (withAnimated, components, lowercase) => {
  components.forEach(Component => {
    let key = getDisplayName(Component);

    if (lowercase) {
      key = key[0].toLowerCase() + key.slice(1);
    }

    withAnimated[key] = withAnimated(Component);
  });
  return withAnimated;
};

const getDisplayName = arg => is.str(arg) ? arg : arg && is.str(arg.displayName) ? arg.displayName : is.fun(arg) && arg.name || null;

export { Animated, AnimatedArray, AnimatedInterpolation, AnimatedObject, AnimatedProps, AnimatedStyle, AnimatedValue, addChild, animatedTag, extendAnimated, interpolate, isAnimated, removeChild, toPayload, withAnimated };
//# sourceMappingURL=index.js.map
