{"version":3,"file":"interpolation.js","sourceRoot":"","sources":["../../src/types/interpolation.ts"],"names":[],"mappings":"","sourcesContent":["import { Animatable, SpringValue } from './animated'\nimport { Arrify } from './common'\n\nexport type EasingFunction = (t: number) => number\n\nexport type ExtrapolateType = 'identity' | 'clamp' | 'extend'\n\n/** These types can be interpolated */\nexport type Interpolatable = ReadonlyArray<number | string>\n\n/**\n * Interpolate the value with a custom interpolation function,\n * a configuration object or keyframe-like ranges.\n *\n * @example\n *\n * interpolate(alpha => `rgba(255, 165, 0, ${alpha})`)\n * interpolate({ range: [0, 1], output: ['yellow', 'red'], extrapolate: 'clamp' })\n * interpolate([0, 0.25, 1], ['yellow', 'orange', 'red'])\n */\nexport interface Interpolator<In extends ReadonlyArray<any> = any[]> {\n  <Out extends Animatable = Animatable>(\n    range: readonly number[],\n    output: readonly Out[],\n    extrapolate?: ExtrapolateType\n  ): SpringValue<Animatable<Out>>\n\n  <Out extends Animatable = Animatable>(\n    config: InterpolatorConfig<Out> | InterpolatorFn<In, Out>\n  ): SpringValue<Out>\n}\n\n// Parameters<Interpolation> is insufficient ðŸ˜¢\nexport type InterpolatorArgs<In = any, Out extends Animatable = Animatable> =\n  | [InterpolatorConfig<Out> | InterpolatorFn<Arrify<In>, Out>]\n  | [readonly number[], readonly Out[], (ExtrapolateType | undefined)?]\n\n/**\n * An \"interpolator\" transforms an animated value. Animated arrays are spread\n * into the interpolator.\n */\nexport type InterpolatorFn<In extends ReadonlyArray<any> = any[], Out = any> = (\n  ...input: In\n) => Out\n\nexport type InterpolatorConfig<Out extends Animatable = Animatable> = {\n  /**\n   * What happens when the spring goes below its target value.\n   *\n   *  - `extend` continues the interpolation past the target value\n   *  - `clamp` limits the interpolation at the max value\n   *  - `identity` sets the value to the interpolation input as soon as it hits the boundary\n   *\n   * @default 'extend'\n   */\n  extrapolateLeft?: ExtrapolateType\n\n  /**\n   * What happens when the spring exceeds its target value.\n   *\n   *  - `extend` continues the interpolation past the target value\n   *  - `clamp` limits the interpolation at the max value\n   *  - `identity` sets the value to the interpolation input as soon as it hits the boundary\n   *\n   * @default 'extend'\n   */\n  extrapolateRight?: ExtrapolateType\n\n  /**\n   * What happens when the spring exceeds its target value.\n   * Shortcut to set `extrapolateLeft` and `extrapolateRight`.\n   *\n   *  - `extend` continues the interpolation past the target value\n   *  - `clamp` limits the interpolation at the max value\n   *  - `identity` sets the value to the interpolation input as soon as it hits the boundary\n   *\n   * @default 'extend'\n   */\n  extrapolate?: ExtrapolateType\n\n  /**\n   * Input ranges mapping the interpolation to the output values.\n   *\n   * @example\n   *\n   *   range: [0, 0.5, 1], output: ['yellow', 'orange', 'red']\n   *\n   * @default [0,1]\n   */\n  range?: readonly number[]\n\n  /**\n   * Output values from the interpolation function. Should match the length of the `range` array.\n   */\n  output: readonly Out[]\n\n  /**\n   * Transformation to apply to the value before interpolation.\n   */\n  map?: (value: number) => number\n\n  /**\n   * Custom easing to apply in interpolator.\n   */\n  easing?: EasingFunction\n}\n"]}