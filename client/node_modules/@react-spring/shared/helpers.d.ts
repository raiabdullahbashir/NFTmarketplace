/// <reference types="react" />
import { Indexable } from './types';
interface IsArray {
    <T>(a: T): a is T & readonly any[];
}
export declare const is: {
    arr: IsArray;
    obj: <T extends any>(a: T) => a is Exclude<T & Indexable<any>, Function | readonly any[]>;
    fun: (a: unknown) => a is Function;
    str: (a: unknown) => a is string;
    num: (a: unknown) => a is number;
    und: (a: unknown) => a is undefined;
};
interface EachFn {
    <T = any, This = any>(obj: ReadonlySet<T>, cb: (this: This, value: T) => void, ctx?: This): void;
    <T = any, This = any>(arr: readonly T[], cb: (this: This, value: T, index: number) => void, ctx?: This): void;
    <T = any, This = any>(obj: Indexable<T>, cb: (this: This, value: T, key: string) => void, ctx?: This): void;
}
/** An unsafe object/array/set iterator that allows for better minification */
export declare const each: EachFn;
export declare const toArray: <T>(a?: T | readonly T[] | undefined) => T[];
export declare const useOnce: (effect: import("react").EffectCallback) => void;
export declare const useForceUpdate: () => () => void;
/** Use a value from the previous render */
export declare function usePrev<T>(value: T): T | undefined;
export {};
