{"version":3,"file":"helpers.js","sourceRoot":"","sources":["../src/helpers.ts"],"names":[],"mappings":";;AAAA,+BAAqD;AASxC,QAAA,EAAE,GAAG;IAChB,GAAG,EAAE,KAAK,CAAC,OAAkB;IAC7B,GAAG,EAAE,UAAgB,CAAI;QACvB,OAAA,CAAC,CAAC,CAAC,IAAI,CAAC,CAAC,WAAW,CAAC,IAAI,KAAK,QAAQ;IAAtC,CAAsC;IACxC,GAAG,EAAE,UAAC,CAAU,IAAoB,OAAA,OAAO,CAAC,KAAK,UAAU,EAAvB,CAAuB;IAC3D,GAAG,EAAE,UAAC,CAAU,IAAkB,OAAA,OAAO,CAAC,KAAK,QAAQ,EAArB,CAAqB;IACvD,GAAG,EAAE,UAAC,CAAU,IAAkB,OAAA,OAAO,CAAC,KAAK,QAAQ,EAArB,CAAqB;IACvD,GAAG,EAAE,UAAC,CAAU,IAAqB,OAAA,CAAC,KAAK,KAAK,CAAC,EAAZ,CAAY;CAClD,CAAA;AAsBD,8EAA8E;AACjE,QAAA,IAAI,GAAW,UAAC,GAAc,EAAE,EAAO,EAAE,GAAQ;IAC5D,IAAI,UAAE,CAAC,GAAG,CAAC,GAAG,CAAC,OAAO,CAAC,EAAE;QACvB,GAAG,CAAC,OAAO,CAAC,EAAE,EAAE,GAAG,CAAC,CAAA;KACrB;SAAM;QACL,MAAM,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC,OAAO,CAAC,UAAA,GAAG,IAAI,OAAA,EAAE,CAAC,IAAI,CAAC,GAAG,EAAE,GAAG,CAAC,GAAG,CAAC,EAAE,GAAG,CAAC,EAA3B,CAA2B,CAAC,CAAA;KAC7D;AACH,CAAC,CAAA;AAEY,QAAA,OAAO,GAAG,UAAI,CAAgB;IACzC,OAAA,UAAE,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,KAAK,CAAC,OAAO,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AAA3C,CAA2C,CAAA;AAEhC,QAAA,OAAO,GAAG,UAAC,MAA4B,IAAK,OAAA,iBAAS,CAAC,MAAM,EAAE,EAAE,CAAC,EAArB,CAAqB,CAAA;AAEjE,QAAA,cAAc,GAAG,cAAM,OAAA,kBAAU,CAAC,cAAM,OAAA,CAAC,EAAE,CAAC,EAAJ,CAAI,EAAE,CAAC,CAAC,CAAC,CAAC,CAAiB,EAA5C,CAA4C,CAAA;AAEhF,2CAA2C;AAC3C,SAAgB,OAAO,CAAI,KAAQ;IACjC,IAAM,OAAO,GAAG,cAAM,CAAM,SAAS,CAAC,CAAA;IACtC,iBAAS,CAAC;QACR,OAAO,CAAC,OAAO,GAAG,KAAK,CAAA;IACzB,CAAC,CAAC,CAAA;IACF,OAAO,OAAO,CAAC,OAAO,CAAA;AACxB,CAAC;AAND,0BAMC","sourcesContent":["import { useEffect, useReducer, useRef } from 'react'\nimport { Indexable, OneOrMore } from './types'\n\ninterface IsArray {\n  <T>(a: T): a is T & readonly any[]\n}\n\ntype PlainObject<T> = Exclude<T & Indexable, Function | readonly any[]>\n\nexport const is = {\n  arr: Array.isArray as IsArray,\n  obj: <T extends any>(a: T): a is PlainObject<T> =>\n    !!a && a.constructor.name === 'Object',\n  fun: (a: unknown): a is Function => typeof a === 'function',\n  str: (a: unknown): a is string => typeof a === 'string',\n  num: (a: unknown): a is number => typeof a === 'number',\n  und: (a: unknown): a is undefined => a === void 0,\n}\n\ninterface EachFn {\n  <T = any, This = any>(\n    obj: ReadonlySet<T>,\n    cb: (this: This, value: T) => void,\n    ctx?: This\n  ): void\n\n  <T = any, This = any>(\n    arr: readonly T[],\n    cb: (this: This, value: T, index: number) => void,\n    ctx?: This\n  ): void\n\n  <T = any, This = any>(\n    obj: Indexable<T>,\n    cb: (this: This, value: T, key: string) => void,\n    ctx?: This\n  ): void\n}\n\n/** An unsafe object/array/set iterator that allows for better minification */\nexport const each: EachFn = (obj: Indexable, cb: any, ctx: any) => {\n  if (is.fun(obj.forEach)) {\n    obj.forEach(cb, ctx)\n  } else {\n    Object.keys(obj).forEach(key => cb.call(ctx, obj[key], key))\n  }\n}\n\nexport const toArray = <T>(a?: OneOrMore<T>): T[] =>\n  is.und(a) ? [] : Array.isArray(a) ? a : [a]\n\nexport const useOnce = (effect: React.EffectCallback) => useEffect(effect, [])\n\nexport const useForceUpdate = () => useReducer(() => ({}), 0)[1] as (() => void)\n\n/** Use a value from the previous render */\nexport function usePrev<T>(value: T): T | undefined {\n  const prevRef = useRef<any>(undefined)\n  useEffect(() => {\n    prevRef.current = value\n  })\n  return prevRef.current\n}\n"]}